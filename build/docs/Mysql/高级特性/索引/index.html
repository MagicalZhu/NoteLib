<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Mysql/高级特性/索引">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">索引 | 花裤衩Wiki</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://huakucha.com/img/fav.png"><meta data-rh="true" name="twitter:image" content="https://huakucha.com/img/fav.png"><meta data-rh="true" property="og:url" content="https://huakucha.com/docs/Mysql/高级特性/索引"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="索引 | 花裤衩Wiki"><meta data-rh="true" name="description" content="为什么使用索引"><meta data-rh="true" property="og:description" content="为什么使用索引"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://huakucha.com/docs/Mysql/高级特性/索引"><link data-rh="true" rel="alternate" href="https://huakucha.com/docs/Mysql/高级特性/索引" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://huakucha.com/docs/Mysql/高级特性/索引" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://QZ9YPBGUYT-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="花裤衩Wiki RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="花裤衩Wiki Atom Feed">
<link rel="alternate" type="application/json" href="/blog/feed.json" title="花裤衩Wiki JSON Feed">




<link rel="search" type="application/opensearchdescription+xml" title="花裤衩Wiki" href="/opensearch.xml">

<link rel="preconnect" href="https://fonts.gstatic.com">
<link rel="stylesheet" href="https://fonts.font.im/css?family=Raleway:500,700&amp;display=swap"><link rel="stylesheet" href="/assets/css/styles.864d50a7.css">
<link rel="preload" href="/assets/js/runtime~main.bf86732a.js" as="script">
<link rel="preload" href="/assets/js/main.98457ee6.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,t("light"))}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a href="#" class="skipToContent_D8pK">跳到主要内容</a></div><div class="announcementBar_s0pr" style="background-color:#fafbfc;color:#091E42" role="banner"><div class="announcementBarPlaceholder_qxfj"></div><div class="content_zf74 announcementBarContent_dpRF">🌟欢迎来到花裤衩的博客🌟</div><button type="button" aria-label="关闭" class="clean-btn close closeButton_ZdWa announcementBarClose_iXyO"><svg viewBox="0 0 15 15" width="14" height="14"><g stroke="currentColor" stroke-width="3.1"><path d="M.75.75l13.5 13.5M14.25.75L.75 14.25"></path></g></svg></button></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="花裤衩的博客" class="themedImage_Pn4p themedImage--light_PnYV"><img src="/img/logo.svg" alt="花裤衩的博客" class="themedImage_Pn4p themedImage--dark_eYgw"></div><b class="navbar__title text--truncate">花裤衩</b></a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">基础知识🤖</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/currency">并发编程</a></li><li><a class="dropdown__link" href="/docs/networrk-basic">计算机网络</a></li><li><a class="dropdown__link" href="/docs/linuxCommand">Linux</a></li><li><a class="dropdown__link" href="/docs/dataStructure">数据结构与算法</a></li><li><a class="dropdown__link" href="/docs/leetCode">LeetCode</a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/mysql">MySQL</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">后端框架👨‍💻</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/spring">Spring</a></li><li><a class="dropdown__link" href="/docs/springCloud">SpringCloud</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">方法论🚧</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/distribute/protol">分布式理论</a></li><li><a class="dropdown__link" href="/docs/distribute/basicTech">分布式技术点</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">中间件🚀</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/middleware/basicMiddleware">基础中间件</a></li><li><a class="dropdown__link" href="/docs/middleware/job">定时任务</a></li><li><a class="dropdown__link" href="/docs/middleware/cache">缓存</a></li><li><a class="dropdown__link" href="/docs/middleware/searchEngine">搜索引擎</a></li><li><a class="dropdown__link" href="/docs/middleware/messageQueue">消息队列</a></li><li><a class="dropdown__link" href="/docs/middleware/database">数据库</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">底层⛽️</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/JVM">JVM</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">前端技术👩‍💻</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/front/Vue">Vue</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">其他工具👹</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/Gradle">Gradle</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">物料中心👏</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/website/BE">后端产品</a></li><li><a class="dropdown__link" href="/website/COM">其他产品</a></li><li><a class="dropdown__link" href="/website/FE">前端产品</a></li></ul></div><a class="navbar__item navbar__link" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><a href="https://blog.huakucha.top" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">关于<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_2l9O"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://github.com/MagicalZhu" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="toggle_MW0i colorModeToggle_x44X"><button class="clean-btn toggleButton_yw5v toggleButtonDisabled_BJd7" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_SFTY"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_ekgs"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_H2mL"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_eExm docsWrapper_W2AM"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_ntye" type="button"></button><div class="docPage_qMb8"><aside class="theme-doc-sidebar-container docSidebarContainer_rpaz"><div class="sidebar_mhZE"><nav class="menu thin-scrollbar menu_Y1UP menuWithAnnouncementBar_fPny"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/mysql">简介</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/mysql基础与高级">MySQL基础与高级</a><button aria-label="打开/收起侧边栏菜单「MySQL基础与高级」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/基础知识">基础知识</a><button aria-label="打开/收起侧边栏菜单「基础知识」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/数据库管理">数据库管理</a><button aria-label="打开/收起侧边栏菜单「数据库管理」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/架构与引擎">架构与引擎</a><button aria-label="打开/收起侧边栏菜单「架构与引擎」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/docs/category/存储结构与索引">存储结构与索引</a><button aria-label="打开/收起侧边栏菜单「存储结构与索引」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Mysql/高级特性/索引">索引</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Mysql/高级特性/索引的应用">索引的应用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Mysql/高级特性/设计索引">设计索引</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Mysql/高级特性/InnoDB数据页结构">InnoDB数据页结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Mysql/高级特性/InnoDB表空间">InnoDB表空间</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/性能优化">性能优化</a><button aria-label="打开/收起侧边栏菜单「性能优化」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/事务与锁">事务与锁</a><button aria-label="打开/收起侧边栏菜单「事务与锁」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/运维">运维</a><button aria-label="打开/收起侧边栏菜单「运维」" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/Mysql/MySQL参数与命令">MySQL参数与命令</a></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_JQG6"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_Iseg"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_RiV8"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_z5aJ"><div class="docItemContainer_c0TR"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Alpn" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_SLhD"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/mysql基础与高级"><span itemprop="name">MySQL基础与高级</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/存储结构与索引"><span itemprop="name">存储结构与索引</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">索引</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_IbkY theme-doc-toc-mobile tocMobile_bxCs"><button type="button" class="clean-btn tocCollapsibleButton_p7nN">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>索引</h1></header><h2 class="anchor anchorWithStickyNavbar_loeA" id="为什么使用索引">为什么使用索引<a class="hash-link" href="#为什么使用索引" title="标题的直接链接">​</a></h2><blockquote><p>索引是存储引擎用于快速找到数据记录的一种数据结构 , MySQL 在进行数据查询的时候,首先查看查询条件是否命中某条索引。如果命中则<code>通过索引查找数据</code>,如果不符合就<code>全表扫描</code>,直到找到为止!</p></blockquote><p><img loading="lazy" alt="image-20220529153631832" src="/assets/images/image-20220529153631832-f18e5c4a72f2b5244a787dffda57aaac.png" width="922" height="280" class="img_CujE"></p><ol><li>最左边数据库没有索引的情况下,<code>数据分散在磁盘的不同位置</code>,读取数据的时候，摆臂需要前后摆动查询数据，非常耗时</li><li>按中间的方式对上面的一种方式优化,如果<code>数据顺序存储</code>,那么也需要从第一行开始逐行读取,将数据从磁盘加载到内存中。那么查询 第六行数据也需要进行 N 次的磁盘 IO 操作，仍然十分耗时</li><li>最后一种方式对 Col2 添加了索引,<code>相当于在磁盘上为 Col2 维护了一个索引的数据结构 -&gt; 二叉搜索树</code>。二叉搜索树是的每个节点存储的是<code>K-V 结构</code>, key 是 Col2，value 是该 key 对应的<code>文件指针(地址)</code></li></ol><mark>所以建立索引的目的就是: 减少<strong>磁盘 IO</strong> 的次数，加快查询效率</mark><h2 class="anchor anchorWithStickyNavbar_loeA" id="索引优缺点">索引优缺点<a class="hash-link" href="#索引优缺点" title="标题的直接链接">​</a></h2><blockquote><p>MySQL 官方对索引的定义为: <code>索引(index)是帮助 MySQL 高效获取数据的数据结构</code></p></blockquote><ul><li><p>索引的本质是<code>数据结构</code>, 可以简单的理解为<strong><code>排好序</code></strong>的快速查找数据结构,满足特定查找算法。这些数据结构以某种方式执行数据,这样就可以在这些数据结构的基础上实现<code>高级查找算法</code></p></li><li><p><code>索引是在存储引擎中实现的</code>, 所以每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有的索引类型。同时存储引擎可以定义每个表的<code>最大索引数、最大索引长度</code>。</p></li><li><p><strong>所有存储引擎支持每个表至少 <code>16</code> 个索引,总索引长度至少为 <code>256</code> 个字节</strong></p></li><li><p><strong>索引的优点</strong></p><ol><li><strong>通过建立索引,可以提高检索效率,从而降低数据库IO 的成本</strong></li><li><strong>通过创建索引来保证每一行数据的唯一性</strong></li><li>可以加速表与表之间的连接,即<strong>对于有依赖关系的父子表联合查询时,可以提高查询速度</strong></li><li>在使用分组和排序子句进行数据查询时,可以显著<strong>减少查询中分组和排序的时间</strong>,降低了 CPU 的消耗</li></ol></li><li><p><strong>索引的缺点</strong></p><ol><li><strong>创建和维护索引需要耗费时间,耗费的时间会随着数据量的增加而增加</strong></li><li><strong>索引需要占用磁盘空间, 如果有大量的索引,索引文件就可能比数据文件更快达到最大文件尺寸</strong></li><li><strong>索引虽然可以提高查询速度,但是会降低表更新速度。因为对表数据进行增删改时,索引也需要动态的维护</strong></li></ol></li></ul><div class="theme-admonition theme-admonition-tip alert alert--success admonition_WoCw"><div class="admonitionHeading_TMsN"><span class="admonitionIcon_Ibzs"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>提示</div><div class="admonitionContent_vXIg"><p>索引可以提高查询的速度,但是会影响插入速度，因为每次插入数据都需要动态的维护索引。这种情况下,最好的办法就是先删除表中的索引后再插入数据,插入完成后再创建索引</p></div></div><h2 class="anchor anchorWithStickyNavbar_loeA" id="innodb-索引的推演">InnoDb 索引的推演<a class="hash-link" href="#innodb-索引的推演" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_loeA" id="索引前的查找">索引前的查找<a class="hash-link" href="#索引前的查找" title="标题的直接链接">​</a></h3><blockquote><p>一个精确匹配的 Sql 语句: </p><div class="language-sql codeBlockContainer_APcc theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_m3Ux"><pre tabindex="0" class="prism-code language-sql codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187"><span class="token-line" style="color:#403f53"><span class="token keyword" style="color:rgb(12, 150, 155)">SELECT</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">[</span><span class="token plain">列名列表</span><span class="token punctuation" style="color:rgb(153, 76, 195)">]</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">FROM</span><span class="token plain"> 表名 </span><span class="token keyword" style="color:rgb(12, 150, 155)">WHERE</span><span class="token plain"> 列名 </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> xxx</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><br></span></code></pre><div class="buttonGroup_6DOT"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_FhaS" aria-hidden="true"><svg class="copyButtonIcon_phi_" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_FfTR" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></blockquote><p><strong>一个页中查询</strong></p><p>假设表的数据较少,所有的记录都可以放到一个页中,在查询记录的时候可以按照搜索条件的不同分为下面两种情况</p><ol><li><strong>以主键为搜索条件</strong><ul><li>可以在页目录使用<code>二分法</code> 快速定位到对应的槽,然后再遍历该槽对应分组中的记录就可以快速找到指定的记录</li></ul></li><li><strong>以其他列作为搜索条件</strong><ul><li>因为数据页中没有对非主键列建立页目录,所以无法通过二分法快速定位槽，这样只能从<code>最小记录</code>开始<code>依次遍历</code>单链表中的每条记录，然后对比每条记录是否符合搜索条件</li><li>这里单链表指的是某条数据记录下一条数据的内存地址</li></ul></li></ol><p><strong>很多页中查询</strong></p><p>大部分情况下,表中存放的数据是很多的,需要很多的数据页来存储数据。在很多页中查询的话分为两个步骤</p><ol><li>定位到记录的页</li><li>从所在的页中查找相应的记录</li></ol><p>在没有索引的情况下，无论是否按照主键列还是其他列进行查询。由于无法快速定位到记录所在的数据页,所以<code>只能从第一页开始沿着双向链表一致往下找</code>,每一页都会按照上面单页的方式查询指定的记录。由于要遍历所有的数据页,那么所以效率极其低下。</p><h3 class="anchor anchorWithStickyNavbar_loeA" id="设计索引">设计索引<a class="hash-link" href="#设计索引" title="标题的直接链接">​</a></h3><blockquote><p>建一个表</p><div class="language-sql codeBlockContainer_APcc theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_m3Ux"><pre tabindex="0" class="prism-code language-sql codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187"><span class="token-line" style="color:#403f53"><span class="token keyword" style="color:rgb(12, 150, 155)">CREATE</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">TABLE</span><span class="token plain"> index_demo</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    c1 </span><span class="token keyword" style="color:rgb(12, 150, 155)">INT</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    c2 </span><span class="token keyword" style="color:rgb(12, 150, 155)">INT</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    c3 </span><span class="token keyword" style="color:rgb(12, 150, 155)">CHAR</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">PRIMARY</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">KEY</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token plain">c1</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token plain"> ROW_FORMAT </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain">Compact</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><br></span></code></pre><div class="buttonGroup_6DOT"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_FhaS" aria-hidden="true"><svg class="copyButtonIcon_phi_" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_FfTR" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></blockquote><p>新建的 index_demo 表有 2 个 INT 类型的列，1个 Char(1) 类型的列,并且c1为主键。这个表使用<code>Compact</code>行格式来实际存储数据</p><p><img loading="lazy" alt="image-20220529172547929" src="/assets/images/image-20220529172547929-0dcc6a6d813af84625ef31e9c476b9b8.png" width="878" height="657" class="img_CujE"></p><p><strong>Compact行格式展示记录的这几个部分(部分信息)</strong></p><ol><li><p><code>record_type</code></p><ul><li>记录头信息的一项属性，<strong>表示记录的类型</strong><ul><li><code>0</code> : 表示普通记录</li><li><code>1</code> : B+树节点指针</li><li><code>2</code> : 表示最小记录</li><li><code>3</code> : 表示最大记录</li></ul></li></ul></li><li><p><code>next_record</code></p><ul><li>记录头信息的一项属性，<strong>表示下一条地址相对于本条记录的地址偏移量</strong></li></ul></li><li><p><code>各个列的值</code></p><ul><li>记录在表中列</li></ul></li></ol><p><strong>基本数据页的模型：</strong></p><blockquote><p>如下图所示：</p><ol><li><p>head 头部的 record_type=2，说明 next_record 指向当前页的最小记录</p></li><li><p>中间的 record_type=0,说明都是普通的记录,并且 next_record指向下一条记录。并且最后一条普通记录指向 record_type=3 的最大记录</p></li><li><p>tail 尾部的 record_type=3，说明 next_record 指向<strong>下一页</strong>的最小记录(对于当前页面来说是最大值)</p></li></ol></blockquote><p><img loading="lazy" alt="image-20220529163641319" src="/assets/images/image-20220529163641319-12cd9e4cb938a8c4b89c0e5deaa4da3f.png" width="899" height="501" class="img_CujE"></p><h4 class="anchor anchorWithStickyNavbar_loeA" id="简单的索引方案">简单的索引方案<a class="hash-link" href="#简单的索引方案" title="标题的直接链接">​</a></h4><p>由于各页中的数据没有规律,所以在查询的时候不得不遍历所有的数据。如果我们想要快速的定位到记录所在的数据页,需要建立一个<strong>目录</strong>,建立目录需要完成一下的事情:</p><ol><li><strong>下一个数据页中记录的主键值必须大于上一页中所有记录的主键值</strong><ul><li>在对记录进行增删改的时候,我们需要通过一些比如<code>记录移动</code> 的操作来保证当前数据页的最小记录的主键值大于上一页的最大记录的主键值,这个过程称为<strong><code>页分裂</code></strong></li></ul></li><li><strong>给所有的页建立一个目录项</strong><ul><li>数据页在物理存储上是不连续的,但是为了保证连续性,需要建立<code>目录(索引)</code>,每一个数据页对应一个<code>目录项</code><ul><li><code>目录项</code> 记录了: <strong>页号</strong> 和 <strong>数据页中用户记录的最小值</strong></li></ul></li><li>通过维护目录可以得到一个 <strong>在逻辑上连续存储的数据页</strong></li></ul></li></ol><div class="theme-admonition theme-admonition-info alert alert--info admonition_WoCw"><div class="admonitionHeading_TMsN"><span class="admonitionIcon_Ibzs"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>简单索引方案示例</div><div class="admonitionContent_vXIg"><p><strong>1. 下一个数据页中记录的主键值必须大于上一页中所有记录的主键值</strong></p><p>向 index_demo的表中添加数据</p><div class="language-sql codeBlockContainer_APcc theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_m3Ux"><pre tabindex="0" class="prism-code language-sql codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187"><span class="token-line" style="color:#403f53"><span class="token comment" style="color:rgb(152, 159, 177);font-style:normal"># 插入的数据中主键不是递增的</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token keyword" style="color:rgb(12, 150, 155)">insert</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">into</span><span class="token plain"> index_demo </span><span class="token keyword" style="color:rgb(12, 150, 155)">values</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token number" style="color:rgb(170, 9, 130)">4</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token string" style="color:rgb(72, 118, 214)">&#x27;u&#x27;</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token number" style="color:rgb(170, 9, 130)">5</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token number" style="color:rgb(170, 9, 130)">3</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token string" style="color:rgb(72, 118, 214)">&#x27;y&#x27;</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">3</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token number" style="color:rgb(170, 9, 130)">9</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token string" style="color:rgb(72, 118, 214)">&#x27;d&#x27;</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><br></span></code></pre><div class="buttonGroup_6DOT"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_FhaS" aria-hidden="true"><svg class="copyButtonIcon_phi_" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_FfTR" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在插入的数据中主键不是递增的,但是数据页中数据递增的，便得到下面的图:</p><p><img loading="lazy" alt="image-20220605125955396" src="/assets/images/image-20220605125955396-187c0afa84cc10f1d0566915971f9edc.png" width="524" height="363" class="img_CujE"></p><p>此时我们再插入一条数据:</p><div class="language-sql codeBlockContainer_APcc theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_m3Ux"><pre tabindex="0" class="prism-code language-sql codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187"><span class="token-line" style="color:#403f53"><span class="token keyword" style="color:rgb(12, 150, 155)">insert</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">into</span><span class="token plain"> index_demo </span><span class="token keyword" style="color:rgb(12, 150, 155)">values</span><span class="token plain">  </span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token number" style="color:rgb(170, 9, 130)">4</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token number" style="color:rgb(170, 9, 130)">4</span><span class="token punctuation" style="color:rgb(153, 76, 195)">,</span><span class="token string" style="color:rgb(72, 118, 214)">&#x27;a&#x27;</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><br></span></code></pre><div class="buttonGroup_6DOT"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_FhaS" aria-hidden="true"><svg class="copyButtonIcon_phi_" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_FfTR" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们假设数据页最多只能存储 3 条数据,那么需要在分配一个数据页。当然数据页在物理上不一定是连续的,只需要在逻辑上保持连续即可。</p><p><img loading="lazy" alt="image-20220605130339882" src="/assets/images/image-20220605130339882-37e4f1ad5cb20fbc28b64e9e6aa6433f.png" width="793" height="268" class="img_CujE"></p><p>上图中 页28 的主键最大值是 4，而 页10 的主键最大值为 5，这个不符合要求，所以在插入这条 主键值=4 的记录时,需要伴随着一次<code>记录移动</code>,将 主键值=5 的数据移动到 页28 里面,插入的这条主键值=4的记录移动到 页10 里面,得到的模型图如下:</p><p><img loading="lazy" alt="image-20220605130906729" src="/assets/images/image-20220605130906729-b33940a890421d2f25dda60220dba586.png" width="782" height="381" class="img_CujE"></p><p><strong>2.给所有目录建立一个目录项</strong></p><p>由于数据页的<code>编号不一定是连续的</code>,所以在向index_demo 表中插入多条数据的时候,可能得到的结果是这样的:</p><p><img loading="lazy" alt="image-20220605131755873" src="/assets/images/image-20220605131755873-3ecd95f9380978ee0017206e229a3920.png" width="1290" height="203" class="img_CujE"></p><p>因为这些<code>16kb</code>的页在物理存储上是不连续的,如果想从多个数据页中根据主键值<code>快速定位某些记录所在的页</code>,我们需要给这些数据页做一个<strong><code>目录</code></strong>，每个页对应一个<code>目录项</code>，每个目录项包含一下的内容</p><ul><li><strong>页的用户记录中最小的主键值，我们用<code>key</code> 来表示</strong></li><li><strong>页号,我们用<code>page_no</code>来表示</strong></li></ul><p>那么上述的几个数据页得到的命令就如图所示:</p><p><img loading="lazy" alt="image-20220605132249255" src="/assets/images/image-20220605132249255-5e3045068d148131697c4b3cb84026ab.png" width="1008" height="398" class="img_CujE"></p><p>以页28 为例,它对应目录项2,包含了该页的 <code>页号28</code> 以及<code>该页中用户记录的最小主键值 5</code>。</p><p><strong>我们只需要把几个目录项在物理存储器上连续存储(比如:数组)，就可以实现根据主键值快速查找某条记录的功能了</strong></p><p>比如:查找主键值为 20 的记录，具体查找过程分两步:</p><ul><li><p>先从目录项中根据 <code>二分法</code> 快速确定出主键值为 20 的记录在 目录项3 中(因为 12 &lt; 20 &lt; 209 )，它对应的页是<code>页9</code></p></li><li><p>再根据前边说的在页中查找记录的方式去 <code>页9</code> 中定位具体的记录</p></li></ul><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 <strong><code>索引</code></strong> 。</p></div></div><h4 class="anchor anchorWithStickyNavbar_loeA" id="innodb索引方案1">InnoDb索引方案(1)<a class="hash-link" href="#innodb索引方案1" title="标题的直接链接">​</a></h4><blockquote><p>到这里我们认识到,通过建立逻辑连续的索引，以及目录项可以帮助我们快速的定位到查询的数据。但是我们有需要如何存储索引呢?</p></blockquote><p><strong>目录项纪录的页</strong></p><p>我们把前边使用到的目录项放到数据页中的样子就是这样:</p><p><img loading="lazy" alt="image-20220605135545068" src="/assets/images/image-20220605135545068-5aa1e9447d066594aa6c03a18ee191c9.png" width="1046" height="514" class="img_CujE"></p><p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录,这里<code>目录项记录</code> 和 <code>普通的用户记录</code>的不同点在于:</p><ul><li><p><code>目录项的 record_type = 1</code>,而 普通的用户记录 record_type = 0</p></li><li><p>目录项记录只有<code>主键值</code> 和 <code>页编号</code>两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列 ，另外还有InnoDB自己添加的隐藏列</p></li></ul><p>两个记录的<strong>相同点</strong>:</p><ul><li>两者用的是一样的数据页，都会为主键值生成 <code>Page Directory(页目录)</code>, 通过<strong>页目录</strong>可以按照主键值进行查找时可以使用 <code>二分法</code> 来加快查询速度</li></ul><div class="theme-admonition theme-admonition-info alert alert--info admonition_WoCw"><div class="admonitionHeading_TMsN"><span class="admonitionIcon_Ibzs"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>查询示例</div><div class="admonitionContent_vXIg"><p>现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步:</p><ol><li>先到存储 <strong>目录项记录</strong> 的页，也就是页30中通过 <strong>二分法</strong> 快速定位到对应目录项，因为 <em>12 &lt; 20 &lt; 209</em> ，所以定位到对应的记录所在的页就是页9</li><li>再到存储用户记录的页9中根据 <strong>二分法</strong> 快速定位到主键值为 20 的用户记录。</li></ol></div></div><h4 class="anchor anchorWithStickyNavbar_loeA" id="innodb索引方案2">InnoDb索引方案(2)<a class="hash-link" href="#innodb索引方案2" title="标题的直接链接">​</a></h4><blockquote><p>上述的方案中,将目录项存储到了数据页中,但是当目录项很多以至于一个数据页中存储不了的时候，会分配一个新的数据页来存储目录项</p></blockquote><p><strong>多个目录项纪录的页</strong></p><p><img loading="lazy" alt="image-20220605140247250" src="/assets/images/image-20220605140247250-a8d1f88f524208fdf83ef16ab2d36a7e.png" width="1088" height="471" class="img_CujE"></p><p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页:</p><ul><li>为存储该用户记录而新生成了 <strong>页31</strong> </li><li>因为原先存储目录项记录的 页30 的容量已满 (我们前边假设只能存储4条目录项记录)，所以需要一个新的 页32 来存放 页31 对应的目录项</li></ul><div class="theme-admonition theme-admonition-info alert alert--info admonition_WoCw"><div class="admonitionHeading_TMsN"><span class="admonitionIcon_Ibzs"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>查询示例</div><div class="admonitionContent_vXIg"><p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例：</p><ol><li><p>确定 <strong>目录项记录页</strong>, 我们现在的存储目录项记录的页有两个: 页30 和 页32 </p></li><li><p>通过 目录项记录页 确定用户记录真实所在的页</p></li><li><p>在真实存储用户记录的页中定位到具体的记录</p></li></ol></div></div><h4 class="anchor anchorWithStickyNavbar_loeA" id="innodb索引方案3">InnoDb索引方案(3)<a class="hash-link" href="#innodb索引方案3" title="标题的直接链接">​</a></h4><p>经历上述的推演后,我们对目录页在创建一个数据页，维护目录信息，最后大致推演出一个索引的数据的数据结构，这个数据结构就是 <strong><code>B+树</code></strong></p><ul><li><strong>B+ 树底层节点(叶子节点)存储的是用户记录,其他节点(非叶子节点、内节点)存储的是目录项记录，最顶上的称为根节点</strong></li><li><strong>单个数据页中的记录之间采用单链表的形式连接</strong></li><li><strong>多个数据页之间使用双链表连接</strong></li></ul><p><img loading="lazy" alt="image-20220605162335284" src="/assets/images/image-20220605162335284-55f76a9e228931beaa6a4b57b7c45a06.png" width="1065" height="643" class="img_CujE"></p><h4 class="anchor anchorWithStickyNavbar_loeA" id="b树">B+树<a class="hash-link" href="#b树" title="标题的直接链接">​</a></h4><ol><li>一个 B+ 树可以分为好几层，<code>规定最下边的那层，也就是存放我们用户记录的那层为 第 0 层</code>, 之后依次往上加</li><li>实际上<code>B+树一般都不会超过4层</code>，因为 4 层已经存储到很大的数据量了，并且树层次越低，磁盘 IO 的次数越少</li><li>通过主键值去查找某条记录最多只需要做4个页面内的查找(查找3个目录项页和一个用户记录页)，又因为在每个页面内有<code>Page Directory(页目录)</code>,所以在页面内也可以通过 <code>二分法</code> 实现快速定位记录。</li></ol><h3 class="anchor anchorWithStickyNavbar_loeA" id="常见索引概念">常见索引概念<a class="hash-link" href="#常见索引概念" title="标题的直接链接">​</a></h3><blockquote><p>索引按照<strong>物理实现方式</strong>，索引可以分为 2 种:</p><ol><li><strong>聚簇(聚集)索引</strong></li><li><strong>非聚簇(非聚集)索引</strong>，也加做二级索引或者是辅助索引</li></ol></blockquote><h4 class="anchor anchorWithStickyNavbar_loeA" id="聚簇索引">聚簇索引<a class="hash-link" href="#聚簇索引" title="标题的直接链接">​</a></h4><blockquote><p><strong>聚簇</strong> 表示数据行和相邻的键值聚簇的存储在一起</p></blockquote><ul><li><p><strong>聚簇索引不是单独的索引类型，而是一种<code>数据存储方式</code></strong>(所有的用户记录都存储在叶子节点)，也就是所谓的 <strong>数据即索引，索引即数据</strong></p><ul><li>比如 InnoDb 的索引中，底层叶子节点存储的是数据，上层存储的是目录项组成的目录(索引)。所以说索引也是数据</li></ul></li><li><p><strong>特点</strong></p><ol><li><mark>使用记录主键值的大小进行记录和页的排序</mark>，这包括三个方面的含义<ul><li><strong><code>数据页</code>内的记录是按照 <code>主键的大小顺序</code> 排成一个 <code>单向链表</code></strong></li><li><strong>各个存储 <code>用户记录的数据页</code> 也是根据页中<code>用户记录的主键大小顺序</code>排成一个<code>双向链表</code></strong></li><li><strong>存放 <code>目录项记录的页</code>, 分为不同的层次，在同一层次中的页也是根据页中<code>目录项记录的主键大小顺序</code>排成一个 <code>双向链表</code></strong></li></ul></li><li><mark>B+树的<strong>叶子节点</strong>存储的是完整的用户记录</mark><ul><li>所谓完整的用户记录，就是指这个记录中存储了所有列的值(包括隐藏列)</li></ul></li></ol><div class="theme-admonition theme-admonition-tip alert alert--success admonition_WoCw"><div class="admonitionHeading_TMsN"><span class="admonitionIcon_Ibzs"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>说明</div><div class="admonitionContent_vXIg"><p>把具有上面两种特性的的 B+树称之为<code>聚簇索引</code>,所有完整的用户记录都会放在这个<code>聚簇索引</code>的叶子节点处。</p><p>这种聚簇索引不需要再 MySQL 语句中显式的使用<code>INDEX</code>语句去创建,<code>InnoDB</code>存储引擎会<code>自动</code>的为我们创建聚簇索引 =》 添加数据的时候 InnoDb 引擎会适时的维护索引数据，而不是等所有数据插入完成后最后区分数据与索引</p></div></div></li><li><p><strong>优点</strong></p><ul><li><code>数据访问更快</code>,因为聚簇索引将 <strong>索引和数据保存在同一个 B+ 树中</strong>，所以从聚簇索引中获取数据比非 聚簇索引更快</li><li>聚簇索引对于主键的 <code>排序查找</code> 和 <code>范围查找</code> 速度非常快<ul><li>按照聚簇索引排列顺序，查询一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据,所以节省了大量的磁盘 IO</li></ul></li></ul></li><li><p><strong>缺点</strong></p><ul><li><p><code>插入速度严重依赖于插入顺序</code>, 按照主键的顺序插入是最快的方式，否则将会出现<code>页分裂</code>，严重影响性能</p><ul><li>对于InnoDB表，我们一般都会定义一个 <strong>自增主键 ID</strong></li></ul></li><li><p><code>更新主键的代价很高</code>, 因为将会导致被更新的用户记录移动到其他数据页</p><ul><li>对于InnoDB表，我们一般定义 <strong>主键不可更新</strong></li></ul></li><li><p><code>二级索引需要两次索引查找</code>, 第一次找到主键值，第二次根据主键值找到行数据</p></li></ul></li><li><p><strong>限制</strong></p><ul><li>对于 MySQL 来说,目前只有<strong>InnoDB</strong>支持聚簇索引,而<strong>MyISAM</strong>不支持聚簇索引</li><li>由于数据在物理存储上只能有一种,所以<code>每个 MySQL 表只能有一个聚簇索引</code>。一般情况来说就是主键</li><li><strong>如果表中没有定义主键,那么 InnoDb 会选择<code>非空的唯一索引</code>代替。如果也没有这样的索引，那么 InnoDb 会<code>隐式的定义一个主键来作为聚簇索引</code></strong></li><li><strong>为了充分的利用聚簇索引的特性，所以 InnoDB 表的主键应该尽量的使用<code>有顺序的ID</code>,而不建议使用无需的ID(UUID、MD5、HASH、字符串…)作为主键</strong></li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_loeA" id="非聚簇索引">非聚簇索引<a class="hash-link" href="#非聚簇索引" title="标题的直接链接">​</a></h4><h5 class="anchor anchorWithStickyNavbar_loeA" id="概述">概述<a class="hash-link" href="#概述" title="标题的直接链接">​</a></h5><blockquote><p><code>聚簇索引</code>只能在搜索条件是<strong><code>主键值</code></strong>的时候才能发挥作用，因为 B+树中的数据是按照主键进行排序的。</p><p>如果需要以其他列作为搜索条件呢？肯定不能按照 B+树从头到尾依次遍历。</p><p>这个时候就需要<code>二级索引</code>,我们可以<code>多建几个 B+树</code>,不同树中的数据采用不同的<code>排序规则</code>，<strong>此时叶子节点<code>不再存储表中的所有数据</code>，而是存储 <code>索引列的数据 + 主键列的数据</code></strong></p></blockquote><div class="theme-admonition theme-admonition-info alert alert--info admonition_WoCw"><div class="admonitionHeading_TMsN"><span class="admonitionIcon_Ibzs"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>非聚簇索引 B+树示例</div><div class="admonitionContent_vXIg"><p>比如我们需要对 C2 列进行查询，那我们可以对 C2 建立索引，再建一个 B+树。下图中的 B+树中，叶子节点就是存储了索引列C2，以及主键列 C1</p><p><img loading="lazy" alt="image-20220611173240139" src="/assets/images/image-20220611173240139-23a4874f4f8a2f0c8a05af80b1efee4b.png" width="1005" height="573" class="img_CujE"></p></div></div><p><strong>非聚簇索引的 B+树与聚簇索引有下面的几个区别</strong></p><ol><li>使用指定的记录列的大小进行记录和页的排序<ul><li>数据页内的数据按照 <code>指定列</code>的大小排序形成<code>单向链表</code></li><li>各个<code>数据页</code> 也是按照页中记录的<code>指定列</code>大小顺序形成的双向链表</li></ul></li><li>B+树的叶子节点存储的并不是完整的用户记录,而只是<code>指定列 + 主键列</code> 的值</li><li>目录项记录的不再是<code>主键+页号</code>了,也变成了<code>指定列 + 主键列 + 页号</code></li></ol><h5 class="anchor anchorWithStickyNavbar_loeA" id="回表">回表<a class="hash-link" href="#回表" title="标题的直接链接">​</a></h5><p><strong>我们可以考虑执行下面的 sql 语句</strong></p><div class="language-sql codeBlockContainer_APcc theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_m3Ux"><pre tabindex="0" class="prism-code language-sql codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187"><span class="token-line" style="color:#403f53"><span class="token comment" style="color:rgb(152, 159, 177);font-style:normal">-- 假设需要执行下面的 SQL 语句</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token keyword" style="color:rgb(12, 150, 155)">Select</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">*</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">from</span><span class="token plain"> index_demo </span><span class="token keyword" style="color:rgb(12, 150, 155)">where</span><span class="token plain"> c2</span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token number" style="color:rgb(170, 9, 130)">4</span><br></span></code></pre><div class="buttonGroup_6DOT"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_FhaS" aria-hidden="true"><svg class="copyButtonIcon_phi_" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_FfTR" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上面的这个 sql 的在 B+树的执行就是，先根据 c2 的二级索引找到对应的数据,但是 c2索引列查询出来仅包含 c2 的值 和 主键列 c1 的值,而这里是查询所有的字段，包含 c3， 所以再拿主键列 c1 的值去聚簇索引中查询，这时候就可以查询到完整的用户记录，并将所有的数据查询并返回,这个过程就被称为<strong><code>回表</code>, 回表完成后再根据其余的 WHERE 条件过滤记录</strong></p><p>因为这种按照<code>非主键列</code>建立的 B+树需要一次回表操作才可以定位到完整的用户记录,所以这种 B+树也叫做<code>二级索引、辅助索引</code></p><mark>注意：<strong>非聚簇索引的存在不会影响聚簇索引中的结构,所以一张表可以有多个非聚簇索引</strong></mark><div class="theme-admonition theme-admonition-caution alert alert--warning admonition_WoCw"><div class="admonitionHeading_TMsN"><span class="admonitionIcon_Ibzs"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>为什么需要回表?</div><div class="admonitionContent_vXIg"><p><strong>为什么还需要一次回表呢?不能干脆将完整的用户记录放在非聚簇索引的叶子节点中吗?</strong></p><p>如果将完整的用户记录放在叶子节点中的话,那么就太<code>占用地方</code>了。相当于每次建立一颗 B+树,都需要将所有的用户记录都拷贝一遍,有点太浪费存储空间了。</p></div></div><h5 class="anchor anchorWithStickyNavbar_loeA" id="回表的代价">回表的代价<a class="hash-link" href="#回表的代价" title="标题的直接链接">​</a></h5><ul><li><strong>使用二级索引执行查询的时候,每获取一条二级索引的记录,就会立刻对它进行回表,而不是将所有的二级索引记录的主键值汇总后统一进行回表</strong></li><li>对于非聚簇索引来说,直接访问它是<code>顺序 IO</code>,因为记录之间是连续的</li><li>回表访问聚簇索引使用<code>随机I/O</code>,因为回表时主键值是毫无规律的,只能依赖随机 IO<ul><li>需要执行的回表操作越多,那么非聚簇索引的查询性能就越低</li></ul></li></ul><h4 class="anchor anchorWithStickyNavbar_loeA" id="联合索引">联合索引<a class="hash-link" href="#联合索引" title="标题的直接链接">​</a></h4><p>我们也可以同时将多个列的大小作为排序规则,也就是<strong><code>同时为多个列建立索引</code></strong> ,比如想让 B+树按照 (C2、C3) 的大小进行排序,对应的排序操作是:</p><ol><li><strong>先把各个记录和页按照 C2 列进行排序</strong></li><li><strong>在记录的 C2 列相同的时候,采用 C3 列进行排序</strong></li></ol><p>为 C2 和 C3 列建立的索引示意图如下:</p><p><img loading="lazy" alt="image-20220612152037402" src="/assets/images/image-20220612152037402-ff49be51f2b8d9002d9d9df0b39f9f04.png" width="942" height="543" class="img_CujE"></p><br>**以 C2 和 C3 列的大小为排序规则建立的 B+树被称为 `联合索引`**, <mark>可以看出来,<strong>它的本质上也是二级索引</strong></mark>。查询的时候也会将查询条件与 C2 和 C3 同时比较,并找到对应的叶子节点<h3 class="anchor anchorWithStickyNavbar_loeA" id="b树注意点innodb">B+树注意点(InnoDB)<a class="hash-link" href="#b树注意点innodb" title="标题的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_loeA" id="1-根页面位置不变">1. 根页面位置不变<a class="hash-link" href="#1-根页面位置不变" title="标题的直接链接">​</a></h4><p>前面在推演 B+树的时候,<strong>先将存储用户记录的叶子节点画出来,再接着画目录项记录的内节点</strong>,实际上 B+树不是这样形成的，而是下面的过程</p><ol><li>每为一个表创建 B+树索引(<strong>聚簇索引是不是人为创建的,默认就有</strong>)的时候,都会为这个索引创建一个<strong><code>根节点</code></strong>页面。一开始表中没有数据的时候,每个 B+树中的<code>根节点</code>中没有用户记录,也没有目录项</li><li>之后向表中插入数据的时候,先把用户记录存储在<code>根节点</code>中 (开始的时候只有<em>叶子节点</em>，然后数据都存放在根节点中)</li><li>当<code>根节点中的可用空间用完时</code>继续插入数据,此时会将<strong><code>根节点中的所有记录复制得到一个新分配的页中，而不是直接新分配一个新的数据页</code></strong>，比如页 A ，然后对这个新页(页 A)进行<code>页分裂</code>的操作，得到一个新页,比如页 B。这时新插入的记录根据索引列值的大小排序，并被分配到页 A 或者 页 B 中,而<code>根节点</code> 便<strong>升级</strong>为存储目录项记录的页，<strong>同时更新根节点中的记录值，从用户记录变为目录项记录</strong><ul><li><strong>即 B+树的节点是<code>自上而下</code>逐渐生成的</strong></li></ul></li></ol><div class="theme-admonition theme-admonition-tip alert alert--success admonition_WoCw"><div class="admonitionHeading_TMsN"><span class="admonitionIcon_Ibzs"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>说明</div><div class="admonitionContent_vXIg"><ol><li><p>开始的时候只有一个<strong>根节点</strong>存储用户记录,当<strong>根节点</strong>中存储的数据满了之后,会复制一份根节点作为<strong>叶子节点存储数据</strong>。</p></li><li><p>然后根节点去维护叶子节点的<strong>目录项信息</strong>，之后叶子节点数据满了之后,进行<strong>页分裂</strong>的操作</p></li><li><p>当根节点维护的<strong>目录项</strong>记录满了之后,再次复制根节点得到第二层维护<strong>目录项</strong>的内节点,根节点转而维护内节点信息</p></li></ol><p>所以一个 B+树索引的根节点从生成开始,就不会再移动。这样在对某个表建立索引之后，那么根节点的页号就会被记录存储。然后 InnoDb 需要用到这个索引时，就可以通过这个页号找到并使用对应的索引</p></div></div><h4 class="anchor anchorWithStickyNavbar_loeA" id="2目录项记录的唯一性">2.目录项记录的唯一性<a class="hash-link" href="#2目录项记录的唯一性" title="标题的直接链接">​</a></h4><p>我们知道了 B+树索引的内节点中目录项记录的内容是<code>索引列 + 页号</code> 的形式，但其实对二级索引来说并不严谨,因为二级索引可以有指定非唯一的字段列</p><table><thead><tr><th>C1</th><th>C2</th><th>C3</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>‘u’</td></tr><tr><td>3</td><td>1</td><td>‘d’</td></tr><tr><td>5</td><td>1</td><td>‘y’</td></tr><tr><td>7</td><td>1</td><td>‘a’</td></tr></tbody></table><p><img loading="lazy" alt="image-20220615201501848" src="/assets/images/image-20220615201501848-ff0e2f067539b27cc12303435c4a3c88.png" width="526" height="459" class="img_CujE"></p><p>问题: <strong>我们需要新插入一行数据(9,1,c)的数据,那么问题来了:在添加数据的时候,由于索引列的数据都相同，而 页3 中只存储了索引列数据与页号,所以不知道数据应该添加到 页4 还是 页5</strong></p><p>为了保证新的数据可以找到并插入到所在的数据页,需要保证<strong><code>B+树的同一层内节点的目录项记录除去页号以外是唯一的</code></strong>,所以二级索引的内节点的目录项记录的内容有三部分组成</p><ol><li><code>索引列的值</code></li><li><code>主键的值</code></li><li><code>页号</code></li></ol><p>通过将<strong>主键值</strong>页添加到二级索引的内节点的目录项记录中,可以保证 B+树内节点中<strong>各个目录项记录的唯一性</strong>, 实际上二级索引的 B+树结构图大致如下:</p><p><img loading="lazy" alt="image-20220615203233735" src="/assets/images/image-20220615203233735-29ddd70b7c0d8a265d844315df5171f1.png" width="537" height="457" class="img_CujE"></p><br><mark>也就是说如果是</mark><h4 class="anchor anchorWithStickyNavbar_loeA" id="3一个页面最少存储2条记录">3.一个页面最少存储2条记录<a class="hash-link" href="#3一个页面最少存储2条记录" title="标题的直接链接">​</a></h4><p>一个 B+树只需要很少的层级就可以轻松存储数亿条记录,并且查询速度相当不错。本质上因为 B+树这种<strong><code>多层级目录</code></strong>的设计。每经过一个目录就可以过滤掉很多无效的目录,直到找到最终的数据。<strong>一般来说一个数据页最少也会有两层</strong></p><h2 class="anchor anchorWithStickyNavbar_loeA" id="myisam-索引方案">MyISAM 索引方案<a class="hash-link" href="#myisam-索引方案" title="标题的直接链接">​</a></h2><p>B树索引适用存储引擎如表所示(都支持 B 树索引,但是它们的实现原理是不同的):</p><table><thead><tr><th>索引/存储引擎</th><th>MYISAM</th><th>InooDB</th><th>Memory</th></tr></thead><tbody><tr><td>B+树索引</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table><ul><li><p><strong><code>InnoDb、MyISAM 默认使用 B+树索引,Memroy默认使用 Hash 索引</code></strong></p></li><li><p><strong>MyISAM使用 B+树索引,叶子节点的 data 域存放的是<code>数据记录的地址</code></strong></p></li></ul><h3 class="anchor anchorWithStickyNavbar_loeA" id="myisam-索引原理">MyISAM 索引原理<a class="hash-link" href="#myisam-索引原理" title="标题的直接链接">​</a></h3><p>在 InnoDB 中<strong>索引即数据</strong>,也就是聚簇索引的 B+树的叶子节点存储了完整的用户记录,而 MyISAM 索引方案是将<em><code>数据和索引分开存储</code></em>：</p><ol><li>将表中的记录<code>按照记录的插入顺序</code>单独存储在<strong><code>数据文件(MYD)</code></strong>中。在数据文件中不会去划分若干个数据页,而是一股脑的将数据存储在文件中。由于在插入数据的时候<code>没有按照主键进行排序</code>,所以也无法通过二分法查询数据</li><li>使用 MyISAM 存储引擎会将索引信息存储在<strong><code>索引文件(MYI)</code></strong>中。MyISAM默认会为表的主键创建一个索引,<strong>不过索引的叶子节点存储的不是完整的用户记录</strong>,而是<strong><code>主键值 + 数据记录的地址</code></strong></li></ol><div class="theme-admonition theme-admonition-tip alert alert--success admonition_WoCw"><div class="admonitionHeading_TMsN"><span class="admonitionIcon_Ibzs"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>索引示意图</div><div class="admonitionContent_vXIg"><p>①、<strong>主键为索引键</strong></p><p>在 MyISAM 引擎中,叶子节点存储的是数据的地址。聚簇索引中存储就是主键的数据的地址</p><p><img loading="lazy" alt="image-20220618160644663" src="/assets/images/image-20220618160644663-b182244dedb241a872ec2a3d473a99af.png" width="1740" height="1268" class="img_CujE"></p><p>这里假设表一共有 3 列,假设我们以 Col1 为主键,上图就是一个 MyISAM表的<code>主索引(Primary Key)</code>的示意图。可以看出<strong><code>MyISAM 的索引文件仅仅保存数据记录的地址</code></strong>。在 MyISAM 中主键索引和二级索引没有任何区别,<strong>只是主键索引要求 Key 是唯一的,而二级索引的 key 是可以重复的。</strong></p><p>如果我们再 Col2 上建立一个二级索引,那么索引的结构如下图所示:</p><p>②、<strong>非主键为索引键的二级索引</strong></p><p>​	<img loading="lazy" alt="image-20220618161123376" src="/assets/images/image-20220618161123376-33ace922598843b3b072a1970e2ecb54.png" width="1760" height="1304" class="img_CujE"></p></div></div><h3 class="anchor anchorWithStickyNavbar_loeA" id="myisam-与-innodb对比">MyISAM 与 InnoDB对比<a class="hash-link" href="#myisam-与-innodb对比" title="标题的直接链接">​</a></h3><blockquote><p>同样也是一棵 B+树,MyISAM 中的 data 域保存数据记录的地址。因此 MyISAM 中索引检索的算法为: </p><ol><li><strong><code>首先按照 B+树搜索算法去上搜索索引,如果指定的 key 存在，就取出其 data 域的值</code></strong></li><li><strong><code>然后按照 data 域的值作为地址,去 MYD 文件中找到并读取相应的数据记录</code></strong></li></ol></blockquote><p>小结两种引擎中索引的区别:</p><ol><li><strong>MyISAM的索引方式都是 “非聚簇” 的，与InnoDB包含1个聚簇索引是不同的</strong> </li><li>在 InnoDB 存储引擎中, 我们可以通过主键值对<code>聚簇索引</code>进行一次查询并找到对应的记录。而在 MyISAM 中需要多进行一次<code>回表</code>的操作,这个是因为 MyISAM 中建立的索引相当于都是<code>二级索引</code></li><li>InnoDB的数据文件本身就是索引文件,而 MyISAM 的索引文件和数据文件是<code>分开的</code>, 索引文件仅仅保存数据文件中数据记录的地址</li><li>InnoDB中索引 data 域存储的是<code>索引列的值</code>,而MyISAM 索引记录的是<code>索引列的地址</code>。</li><li>MyISAM 的回表操作是十分<code>快速</code>的,因为是<strong>直接拿着地址去数据文件中读取数据的。</strong>但是 InnoDB通过获取主键值后，再去<strong>聚簇索引</strong>中找记录，虽然也不慢,但是也还是需要通过多次二分查询去查找数据,比不上用地址直接去访问</li><li>InnoDB 要求表<code>必须有主键(MyISAM 可以没有)</code><ul><li>如果没有显式指定的话,则 MySQL 会自动选择一个非空且唯一标识数据记录的列作为主键</li><li>如果也没有,则 MySQL 会自动为 InnoDB 生成一个隐含字段作为主键, <strong>这个字段有 6 个字节,类型为长整型</strong></li></ul></li></ol><p><img loading="lazy" alt="image-20220618173041394" src="/assets/images/image-20220618173041394-9f11e2399b6b21c579835b03d1325255.png" width="1726" height="1240" class="img_CujE"></p><div class="theme-admonition theme-admonition-tip alert alert--success admonition_WoCw"><div class="admonitionHeading_TMsN"><span class="admonitionIcon_Ibzs"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>小结</div><div class="admonitionContent_vXIg"><p>了解不同存储引擎的实现方式对于正确使用和优化索引都非常有帮助,比如:</p><ol><li>知道 InnoDB 的索引本质以后,就会明白<strong>为什么不建议使用过长的字段作为主键</strong>,因为所有的二级索引中都包含主键，过长的主键会让二级索引变得过大</li><li>用非单调递增的字段作为主键在 InnoDB 中不是一个好主意。因为非单调的主键会在插入新记录时，为了维持 B+树的特性而频繁的进行页分裂操作，十分低效。而使用<code>自增字段作为主键是一个很好的选择</code>。</li></ol></div></div><h2 class="anchor anchorWithStickyNavbar_loeA" id="索引的代价">索引的代价<a class="hash-link" href="#索引的代价" title="标题的直接链接">​</a></h2><blockquote><p>索引是加快查询的速度,但是不能乱建索引,它在时间和空间上都有所消耗</p></blockquote><ol><li><strong><code>空间的代价</code></strong><ul><li><strong>每建立一个索引都要为其建立一棵 B+树, 每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 <code>16KB</code> 的存储空间</strong></li><li>一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间</li></ul></li><li><strong><code>时间上的代价</code></strong><ul><li>每次对表中数据进行增、删、改的时候,都需要去修改各个 B+树索引,而且 B+树中每层节点都是按照索引列的值<code>从小到大顺序排序</code>形成的<code>双向链表</code>。</li><li>不论是叶子节点的记录还是内节点中的记录,都是按照索引列的值从小到大的顺序形成的单向链表，而增、删、改的操作会对节点和记录造成破坏,<strong>所以存储引擎需要额外的时间进行一些<code>记录位移、页面分裂、页面回收</code>等操作来维护节点和记录的排序</strong></li><li>如果我们建立了许多的索引,每个索引对应的 B+树都要进行相关的维护操作,就会对性能拖后腿</li></ul></li></ol><h2 class="anchor anchorWithStickyNavbar_loeA" id="mysql数据结构选择的合理性">MySQL数据结构选择的合理性<a class="hash-link" href="#mysql数据结构选择的合理性" title="标题的直接链接">​</a></h2><p>从 MySQL 的角度上说,不得不考虑与一个现实的问题:<strong>磁盘 IO</strong>。如果我们可以上索引的数据结构尽量减少磁盘 IO 的次数,那么所消耗的时间就越小。可以说<strong>磁盘 IO 的次数对索引的使用效率至关重要</strong>。</p><p><code>查询都是索引操作</code>,一般来说索引非常大,特别是关系型数据库。当数据量比较大的时候,索引的大小可能达到几个 G 甚至更多。为了减少索引在内存中的占用,<code>数据库索引是存储在外部磁盘上的</code>。当利用索引查询的的时候,<strong>也不会把整个索引全部加载到内存中</strong>,只能<strong>逐一加载</strong>。那么MySQL 衡量查询效率的标准就是<strong>磁盘 IO 次数</strong></p><h3 class="anchor anchorWithStickyNavbar_loeA" id="全表遍历">全表遍历<a class="hash-link" href="#全表遍历" title="标题的直接链接">​</a></h3><p>索引从头到尾全都加载一遍,性能极差</p><h3 class="anchor anchorWithStickyNavbar_loeA" id="hash结构">Hash结构<a class="hash-link" href="#hash结构" title="标题的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_loeA" id="基本概述">基本概述<a class="hash-link" href="#基本概述" title="标题的直接链接">​</a></h4><blockquote><p>Hash 本身是一个函数,也被称为<strong>散列函数</strong>,可以帮我们大幅提高检索数据的效率</p><p>Hash 算法通过某种确定性算法(比如 MD5、SHA1…)将输入变为输出,<strong>相同的输入一定能得到相同的输出</strong>。假设内容有细微的偏差,通常就会输出不同的结果</p><p><strong><code>Hash结构查询、插入、修改、删除的平均时间复杂度都是O(1)</code></strong></p></blockquote><p>采用 Hash 进行检索效率非常高，基本上一次检索就可以找到数据,而 B+树需要从上往下依次查找,多次访问节点才能找到数据,中间需要多次 IO 操作,<strong><code>从效率上来说 Hash 比 B+树更快</code></strong>。在 Hash 的方式下,一个元素 k 位于 h(k) 中, <strong>即利用哈希函数 h计算出槽的位置</strong>, 哈希函数 h 将关键字域映射到哈希表的槽位上。</p><p><img loading="lazy" alt="image-20220619131924795" src="/assets/images/image-20220619131924795-aeae2b0b6bc379c408d7f690187a6762.png" width="870" height="313" class="img_CujE"></p><p>上图中,<strong>Hash 函数计算得到的输出不同,但是在计算槽位置时将两个结果进行映射的时候,有可能会映射到相同的位置，这个叫做<code>Hash碰撞</code></strong>,在数据库中一般采用<code>拉链法(也叫做链接法)</code>，在拉链法中,<strong>将散列到同一个槽位的元素放在一个链表中</strong></p><p><img loading="lazy" alt="image-20220619133052086" src="/assets/images/image-20220619133052086-dc26992f121418d517b71462dff36638.png" width="877" height="292" class="img_CujE"></p><div class="theme-admonition theme-admonition-tip alert alert--success admonition_WoCw"><div class="admonitionHeading_TMsN"><span class="admonitionIcon_Ibzs"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>体验数组与 Hash 表的遍历速度</div><div class="admonitionContent_vXIg"><p>查询数组或者 Hash 表中是否有相同的数据</p><div class="language-java codeBlockContainer_APcc theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_m3Ux"><pre tabindex="0" class="prism-code language-java codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187"><span class="token-line" style="color:#403f53"><span class="token keyword" style="color:rgb(12, 150, 155)">public</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">class</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(17, 17, 17)">TestArrayAndHash</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">public</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">static</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(153, 76, 195);font-style:normal">main</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token class-name" style="color:rgb(17, 17, 17)">String</span><span class="token punctuation" style="color:rgb(153, 76, 195)">[</span><span class="token punctuation" style="color:rgb(153, 76, 195)">]</span><span class="token plain"> args</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token function" style="color:rgb(153, 76, 195);font-style:normal">test01</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token function" style="color:rgb(153, 76, 195);font-style:normal">test02</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">public</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">static</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(153, 76, 195);font-style:normal">test01</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token keyword" style="color:rgb(12, 150, 155)">int</span><span class="token punctuation" style="color:rgb(153, 76, 195)">[</span><span class="token punctuation" style="color:rgb(153, 76, 195)">]</span><span class="token plain"> arr </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">new</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">int</span><span class="token punctuation" style="color:rgb(153, 76, 195)">[</span><span class="token number" style="color:rgb(170, 9, 130)">100000</span><span class="token punctuation" style="color:rgb(153, 76, 195)">]</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token keyword" style="color:rgb(12, 150, 155)">for</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token keyword" style="color:rgb(12, 150, 155)">int</span><span class="token plain"> i </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">0</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain">i </span><span class="token operator" style="color:rgb(12, 150, 155)">&lt;</span><span class="token plain"> arr</span><span class="token punctuation" style="color:rgb(153, 76, 195)">.</span><span class="token plain">length</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain">i</span><span class="token operator" style="color:rgb(12, 150, 155)">++</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">            arr</span><span class="token punctuation" style="color:rgb(153, 76, 195)">[</span><span class="token plain">i</span><span class="token punctuation" style="color:rgb(153, 76, 195)">]</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> i </span><span class="token operator" style="color:rgb(12, 150, 155)">+</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token keyword" style="color:rgb(12, 150, 155)">long</span><span class="token plain"> start </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(17, 17, 17)">System</span><span class="token punctuation" style="color:rgb(153, 76, 195)">.</span><span class="token function" style="color:rgb(153, 76, 195);font-style:normal">currentTimeMillis</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token keyword" style="color:rgb(12, 150, 155)">for</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token keyword" style="color:rgb(12, 150, 155)">int</span><span class="token plain"> j </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"> j</span><span class="token operator" style="color:rgb(12, 150, 155)">&lt;=</span><span class="token number" style="color:rgb(170, 9, 130)">100000</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain">j</span><span class="token operator" style="color:rgb(12, 150, 155)">++</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">            </span><span class="token keyword" style="color:rgb(12, 150, 155)">int</span><span class="token plain"> temp </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> j</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">            </span><span class="token keyword" style="color:rgb(12, 150, 155)">for</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token keyword" style="color:rgb(12, 150, 155)">int</span><span class="token plain"> i </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">0</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain">i </span><span class="token operator" style="color:rgb(12, 150, 155)">&lt;</span><span class="token plain"> arr</span><span class="token punctuation" style="color:rgb(153, 76, 195)">.</span><span class="token plain">length</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain">i</span><span class="token operator" style="color:rgb(12, 150, 155)">++</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">                </span><span class="token keyword" style="color:rgb(12, 150, 155)">if</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token plain">temp </span><span class="token operator" style="color:rgb(12, 150, 155)">==</span><span class="token plain"> arr</span><span class="token punctuation" style="color:rgb(153, 76, 195)">[</span><span class="token plain">i</span><span class="token punctuation" style="color:rgb(153, 76, 195)">]</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">                    </span><span class="token keyword" style="color:rgb(12, 150, 155)">break</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">                </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">            </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token keyword" style="color:rgb(12, 150, 155)">long</span><span class="token plain"> end </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(17, 17, 17)">System</span><span class="token punctuation" style="color:rgb(153, 76, 195)">.</span><span class="token function" style="color:rgb(153, 76, 195);font-style:normal">currentTimeMillis</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token class-name" style="color:rgb(17, 17, 17)">System</span><span class="token punctuation" style="color:rgb(153, 76, 195)">.</span><span class="token plain">out</span><span class="token punctuation" style="color:rgb(153, 76, 195)">.</span><span class="token function" style="color:rgb(153, 76, 195);font-style:normal">println</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token string" style="color:rgb(72, 118, 214)">&quot;time: &quot;</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">+</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token plain">end </span><span class="token operator" style="color:rgb(12, 150, 155)">-</span><span class="token plain"> start</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain">   </span><span class="token comment" style="color:rgb(152, 159, 177);font-style:normal">// 1184</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token keyword" style="color:rgb(12, 150, 155)">public</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">static</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(153, 76, 195);font-style:normal">test02</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token class-name" style="color:rgb(17, 17, 17)">HashSet</span><span class="token generics punctuation" style="color:rgb(153, 76, 195)">&lt;</span><span class="token generics class-name" style="color:rgb(17, 17, 17)">Integer</span><span class="token generics punctuation" style="color:rgb(153, 76, 195)">&gt;</span><span class="token plain"> set </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">new</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(17, 17, 17)">HashSet</span><span class="token generics punctuation" style="color:rgb(153, 76, 195)">&lt;</span><span class="token generics punctuation" style="color:rgb(153, 76, 195)">&gt;</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token number" style="color:rgb(170, 9, 130)">100000</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token keyword" style="color:rgb(12, 150, 155)">for</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token keyword" style="color:rgb(12, 150, 155)">int</span><span class="token plain"> i </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">0</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"> i </span><span class="token operator" style="color:rgb(12, 150, 155)">&lt;</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">100000</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"> i</span><span class="token operator" style="color:rgb(12, 150, 155)">++</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">            set</span><span class="token punctuation" style="color:rgb(153, 76, 195)">.</span><span class="token function" style="color:rgb(153, 76, 195);font-style:normal">add</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token plain">i </span><span class="token operator" style="color:rgb(12, 150, 155)">+</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token keyword" style="color:rgb(12, 150, 155)">long</span><span class="token plain"> start </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(17, 17, 17)">System</span><span class="token punctuation" style="color:rgb(153, 76, 195)">.</span><span class="token function" style="color:rgb(153, 76, 195);font-style:normal">currentTimeMillis</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token keyword" style="color:rgb(12, 150, 155)">for</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token keyword" style="color:rgb(12, 150, 155)">int</span><span class="token plain"> j </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(170, 9, 130)">1</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"> j</span><span class="token operator" style="color:rgb(12, 150, 155)">&lt;=</span><span class="token number" style="color:rgb(170, 9, 130)">100000</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain">j</span><span class="token operator" style="color:rgb(12, 150, 155)">++</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">            </span><span class="token keyword" style="color:rgb(12, 150, 155)">int</span><span class="token plain"> temp </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> j</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">            </span><span class="token keyword" style="color:rgb(12, 150, 155)">boolean</span><span class="token plain"> contains </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> set</span><span class="token punctuation" style="color:rgb(153, 76, 195)">.</span><span class="token function" style="color:rgb(153, 76, 195);font-style:normal">contains</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token plain">temp</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token keyword" style="color:rgb(12, 150, 155)">long</span><span class="token plain"> end </span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(17, 17, 17)">System</span><span class="token punctuation" style="color:rgb(153, 76, 195)">.</span><span class="token function" style="color:rgb(153, 76, 195);font-style:normal">currentTimeMillis</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">        </span><span class="token class-name" style="color:rgb(17, 17, 17)">System</span><span class="token punctuation" style="color:rgb(153, 76, 195)">.</span><span class="token plain">out</span><span class="token punctuation" style="color:rgb(153, 76, 195)">.</span><span class="token function" style="color:rgb(153, 76, 195);font-style:normal">println</span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token string" style="color:rgb(72, 118, 214)">&quot;time: &quot;</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">+</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(153, 76, 195)">(</span><span class="token plain">end </span><span class="token operator" style="color:rgb(12, 150, 155)">-</span><span class="token plain"> start</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">)</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"> </span><span class="token comment" style="color:rgb(152, 159, 177);font-style:normal">// 6</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token punctuation" style="color:rgb(153, 76, 195)">}</span><br></span></code></pre><div class="buttonGroup_6DOT"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_FhaS" aria-hidden="true"><svg class="copyButtonIcon_phi_" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_FfTR" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>可以看到利用了 Hash 之后效率得到了极大的提高</p></div></div><h4 class="anchor anchorWithStickyNavbar_loeA" id="问题">问题<a class="hash-link" href="#问题" title="标题的直接链接">​</a></h4><p><strong>Hash 结构的效率很高,为什么索引结构要设计成树型呢?</strong></p><ol><li>Hash 索引仅仅能满足<strong>等于、不等于和 IN 的高效查询</strong>, 如果需要进行<code>范围查询</code>,也是需要遍历每个槽位,时间复杂度为 O(n)。而B+树的<code>有序</code>特性,依然可以保证O(log2N)的高效率</li><li>Hash 存储的数据是没有顺序的,即在 ORDER BY 的时候还需要对数据重新排序</li><li>对于联合索引的情况, Hash 值是将联合索引键合并后一起计算的,无法单独对一个键或者几个索引键进行查询</li><li>对于等值查询来说,通常是 Hash 索引的效率更高。但如果<code>索引列重复的值很多，查询效率就会降低</code>。因为遇到 Hash 碰撞时，需要遍历桶中的数据，也是十分耗时的 </li></ol><p><strong>Hash 索引适用的存储引擎</strong></p><p>这里 InnoDB 支持 Hash 索引,但是<code>不支持手动指定使用 Hash 索引,而是自动创建的</code></p><table><thead><tr><th>索引/存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>Hash 索引</td><td>❌</td><td>✅</td><td>✅</td></tr></tbody></table><h4 class="anchor anchorWithStickyNavbar_loeA" id="适用性">适用性<a class="hash-link" href="#适用性" title="标题的直接链接">​</a></h4><ol><li><p>Hash 索引存在着很多的限制,相比之下在数据库中 B+树索引的使用面会更广。不过也有一些场景使用 Hash 的效率更高, 比如一些 K-V 型数据库，<code>Redis 存储的核心就是 Hash 表</code></p></li><li><p>MySQL 中的 Memory 存储引擎支持 Hash 存储,<strong>如果需要用到查询的临时表时,就可以选择 Memory 存储引擎,把某个字段设置为 Hash 索引</strong>，比如字符串类型的字段。<strong>当某个字段的重复度很低，且需要进行<code>等值查询</code>的时候,采用 Hash 索引是个不错的选择</strong></p></li></ol><h4 class="anchor anchorWithStickyNavbar_loeA" id="自适应哈希索引ahi">自适应哈希索引(AHI)<a class="hash-link" href="#自适应哈希索引ahi" title="标题的直接链接">​</a></h4><blockquote><p>InnoDB支持 Hash 索引,但是不能手动创建 Hash 索引,只能由存储引擎自动创建,即提供了<code>自适应 Hash 索引(Adaptive Hash Index,AHI)</code></p><p>说明:</p><ol><li><em>InnoDB是支持哈希索引的，但需要启动，也可以关闭</em></li><li><em>InnoDB创建哈希索引不能人为指定，是内部的，自主的行为</em></li></ol></blockquote><h5 class="anchor anchorWithStickyNavbar_loeA" id="概述-1"><strong>概述</strong><a class="hash-link" href="#概述-1" title="标题的直接链接">​</a></h5><ol><li><p>InnoDB 存储引擎会监控对表上各索引页的查询,会自动根据访问的频率和模式来自动的为某些热点页建立 Hash 索引,我们称之为<strong>自适应哈希索引</strong></p></li><li><p>AHI 是通过缓冲池的 B+Tree 页构造而来的,所以建立的速度很快。而且不需要对整张比较建立哈希索引</p></li><li><p>AHI 有一个要求,即访问模式需要是一样(<code>查询的条件是一样的</code>),<strong>如果每次查询都使用不同的访问模式,那么InnoDB也不会构造 AHI</strong></p><div class="language-sql codeBlockContainer_APcc theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_m3Ux"><pre tabindex="0" class="prism-code language-sql codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187"><span class="token-line" style="color:#403f53"><span class="token comment" style="color:rgb(152, 159, 177);font-style:normal">-- 假设某表有联合索引(a,b),那么其访问模式可以是下面两种:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token keyword" style="color:rgb(12, 150, 155)">WHERE</span><span class="token plain"> a</span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain">xxx</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token keyword" style="color:rgb(12, 150, 155)">WHERE</span><span class="token plain"> a</span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain">xxx </span><span class="token operator" style="color:rgb(12, 150, 155)">and</span><span class="token plain"> b</span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain">xxx</span><span class="token punctuation" style="color:rgb(153, 76, 195)">;</span><br></span></code></pre><div class="buttonGroup_6DOT"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_FhaS" aria-hidden="true"><svg class="copyButtonIcon_phi_" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_FfTR" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>除了上面<code>访问模式需要一致</code>,AHI 还有下面的要求</p><ul><li><code>以该模式访问了 100 次</code></li><li><code>页通过该模式访问了 N 次,其中 N=页中记录 * 1/16</code></li></ul></li><li><p>我们可以通过<code>show engine innodb status</code> 查看 AHI 的使用状况</p></li><li><p><strong>哈希索引只能用来搜索等值的查询,如果是范围查询,则不行。</strong></p><div class="language-sql codeBlockContainer_APcc theme-code-block" style="--prism-color:#403f53;--prism-background-color:#FBFBFB"><div class="codeBlockContent_m3Ux"><pre tabindex="0" class="prism-code language-sql codeBlock_qGQc thin-scrollbar"><code class="codeBlockLines_p187"><span class="token-line" style="color:#403f53"><span class="token comment" style="color:rgb(152, 159, 177);font-style:normal">--  ✅</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token keyword" style="color:rgb(12, 150, 155)">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">*</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">from</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">table</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">where</span><span class="token plain"> index_col</span><span class="token operator" style="color:rgb(12, 150, 155)">=</span><span class="token plain">‘xxx’ </span><br></span><span class="token-line" style="color:#403f53"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token comment" style="color:rgb(152, 159, 177);font-style:normal">--  ❌</span><span class="token plain"></span><br></span><span class="token-line" style="color:#403f53"><span class="token plain"></span><span class="token keyword" style="color:rgb(12, 150, 155)">select</span><span class="token plain"> </span><span class="token operator" style="color:rgb(12, 150, 155)">*</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">from</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">table</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(12, 150, 155)">where</span><span class="token plain"> index_col </span><span class="token operator" style="color:rgb(12, 150, 155)">&gt;</span><span class="token plain"> xxx</span><br></span></code></pre><div class="buttonGroup_6DOT"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_FhaS" aria-hidden="true"><svg class="copyButtonIcon_phi_" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_FfTR" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p><strong>采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点</strong>，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率</p></li><li><p><strong>通过<code>innodb_adaptive_hash_index</code>可以看到是否开启了自适应 Hash索引,默认是开启的</strong></p></li></ol><p><img loading="lazy" alt="自适应 Hash" src="/assets/images/image-20220619160818811-dfa6aed3a6c7123ee5ca1089b5db7ec3.png" width="609" height="205" class="img_CujE"></p><p><strong>自适应 Hash 索引的示意图</strong></p><p><img loading="lazy" alt="image-20220619160908586" src="/assets/images/image-20220619160908586-84c4ca1126c5cd8487a272888527e10b.png" width="874" height="701" class="img_CujE"></p><h3 class="anchor anchorWithStickyNavbar_loeA" id="二叉搜索树">二叉搜索树<a class="hash-link" href="#二叉搜索树" title="标题的直接链接">​</a></h3><blockquote><p>如果我们利用二叉树作为索引结构，那么<strong>磁盘的IO次数和索引树的高度是相关的</strong></p></blockquote><h4 class="anchor anchorWithStickyNavbar_loeA" id="特点">特点<a class="hash-link" href="#特点" title="标题的直接链接">​</a></h4><ol><li><strong>二叉树的特点</strong><ul><li>一个子节点只能有两个子节点</li><li>左子节点 &lt; 当前节点 ， 右子节点 &gt;= 当前节点</li></ul></li><li><strong>查找规则 - 最基础的二叉搜索树(binary search tree)</strong><ul><li>如果 key 大于当前节点,则在右子树中查找</li><li>如果 key 小于当前节点,则在左子树中查找</li><li>如果 key 等于当前节点,也就找到了结果，返回该节点即可</li></ul></li></ol><h4 class="anchor anchorWithStickyNavbar_loeA" id="示例">示例<a class="hash-link" href="#示例" title="标题的直接链接">​</a></h4><p>假设对数列 <!-- -->[34,22,89,5,23,77,91]<!-- -->创建的二分查找树如下所示，即使查询底层的数据,也只需要 3 次 IO 加载</p><p><img loading="lazy" alt="image-20220619222215521" src="/assets/images/image-20220619222215521-ebc3552ecbaf355abb3d638f07b3177f.png" width="457" height="393" class="img_CujE"></p><p>但是存在一种极端的情况,<strong>让二叉树变成了链表</strong>,假设给出顺序是递增的: <!-- -->[5,22,23,34,77,89,91]<!-- -->,按照二叉搜索树的定义,得到的二叉树结构图如下所示，这种书也属于二分查找树,但是在性能上已经退化成了一条链表，时间复杂度由 O(log2^N^) 变成了 O(n)</p><p><img loading="lazy" alt="image-20220619222523061" src="/assets/images/image-20220619222523061-e102932f3a177cca846fa0eb68605b22.png" width="446" height="526" class="img_CujE"></p><p>为了提高查询效率就需要减少<strong>磁盘 IO 次数</strong>,而为了减少磁盘 IO 次数,就需要尽可能的<strong>减少数的高度</strong>。</p><h3 class="anchor anchorWithStickyNavbar_loeA" id="avl-树">AVL 树<a class="hash-link" href="#avl-树" title="标题的直接链接">​</a></h3><blockquote><p>由于普通的二叉搜索树在某些情况下性能低下的问题,后来提出了<code>平衡二叉搜索树(Balanced Binary Tree)</code>，也叫所<strong><code>AVL树</code></strong>，在普通二叉搜索树的基础上增加了约束</p></blockquote><ol><li><strong>AVL 树: <code>它是一颗空树或者它的左右了两个子树的高度差的绝对值不超过 1 , 并且左右两个子树都是一颗平衡二叉树</code></strong></li><li>常见的平衡二叉树有很多种，包括了<code>平衡二叉搜索树(AVL)、红黑树、数堆、伸展树</code></li></ol><p><img loading="lazy" alt="image-20220625104555370" src="/assets/images/image-20220625104555370-040a42e7c18e222311ae6218101ec6e0.png" width="800" height="322" class="img_CujE"></p><p>上面的这个平衡二叉树,访问一次叶子节点需要进行<code>5次 I/O操作</code>。<strong>虽然二叉树的效率高，但如果树的深度也很高,那么也意味着 IO 次数多，会影响查询效率</strong>。对此,我们可以将二叉树转为<code>M叉树(M &gt; 2)</code>,这样树就变得矮胖,树的深度降低了，从而 IO 次数减少了</p><h3 class="anchor anchorWithStickyNavbar_loeA" id="b-tree">B-Tree<a class="hash-link" href="#b-tree" title="标题的直接链接">​</a></h3><blockquote><p>B 树 (Balance Tree),也就是<strong><code>多路平衡查找树</code></strong>，它的高度远低于平衡二叉树的高度</p></blockquote><p>B-Tree 树的结构图如下:</p><p><img loading="lazy" alt="image-20220625131132734" src="/assets/images/image-20220625131132734-5862fbc36d37e84f38eac6c077b4642e.png" width="845" height="357" class="img_CujE"></p><p>一个 M 阶的 B-Tree(M&gt;2) 有以下的特性:</p><ol><li><strong>根节点的子节点树的范围是<code>[2, M]</code></strong></li><li><strong>每个中间节点包含<code>k-1</code>个关键字和<code>k</code>个子节点, k的取值范围<code>[ceil(M/2), M]</code></strong></li><li><strong>叶子节点中有<code>k-1</code> 个关键字(叶子节点没有子节点了), k的取值范围<code>[ceil(M/2), M]</code></strong></li><li><strong>假设中间节点中的关键字为: N<!-- -->[1]<!-- -->~N<!-- -->[k-1]<!-- -->, 并且按照指定关键字升序排序,那么<code>k-1</code> 个关键字相当于划分了 <code>k</code>个范围, 也就是对应着 k 个指针,即为:P<!-- -->[1]<!-- -->~P<!-- -->[k]<!-- -->  </strong><ul><li><strong><code>P[1] 指向关键字小于 N[1] 的子树, P[i] 指向关键字在 N[i-1]~N[i] 之间的子树, P[k]指向关键字大于 N[k-1] 的子树</code></strong></li></ul></li><li><strong>所有的叶子节点都位于同一层, 即树的高度差h = 0</strong></li></ol><div class="theme-admonition theme-admonition-info alert alert--info admonition_WoCw"><div class="admonitionHeading_TMsN"><span class="admonitionIcon_Ibzs"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>浅析 B-Tree 查询</div><div class="admonitionContent_vXIg"><blockquote><p>上面那张图所表示的 B-Tree 就是一棵 3 阶的 B-Tree, 可以看下磁盘块 2，里面的关键字为 { 8, 12 }，它有 3 个子节点 { 3, 5 } 、{ 9, 10 } 和 { 13, 15 }，而且 { 3, 5 } &lt; 8,  { 9, 10 } 在 8 和 12 之间，而 { 13, 15 } &gt; 12</p></blockquote><p>假设我们想要查找的关键字是 9，那么步骤可以分为以下几步:</p><ol><li>我们与根节点的关键字 { 17, 35 }进行比较，9 &lt; 17 那么得到指针 P1</li><li>按照指针 P1 找到磁盘块 2, 关键字为 { 8, 12 }，因为 9 在 8 和 12 之间，所以我们得到指针 P2</li><li>按照指针 P2 找到磁盘块 6, 关键字为{ 9, 10 }，然后我们找到了关键字 9</li></ol><p>可以看出来在 B 树的搜索过程中, 我们比较的次数并不少, 但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。<strong>因为读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多。</strong></p><p><code>B-Tree 相比于平衡二叉树来说磁盘 I/O 操作要少</code>, 在数据查询中比平衡二叉树效率要高。所以<code>只要树的高度足够低,IO 的次数会越少, 就可以提高查询效率</code></p><p><strong>再举例:</strong></p><p><img loading="lazy" alt="image-20220625141402659" src="/assets/images/image-20220625141402659-5da397774ac5b84938d0b2a9f1c19c15.png" width="1107" height="496" class="img_CujE"></p></div></div><p><strong>注意</strong></p><ol><li>B-Tree 在插入和删除节点的时候如果导致树的不平衡, 就通过<strong>自动调整的位置保持树的自平衡</strong></li><li>关键字集合分布在整棵树中,即<strong><code>叶子节点和非叶子节点都会存放数据</code>(与 B+ Tree不一样),</strong>搜索可能在非叶子节点就结束了</li></ol><h3 class="anchor anchorWithStickyNavbar_loeA" id="btree">B+Tree<a class="hash-link" href="#btree" title="标题的直接链接">​</a></h3><blockquote><p>B+Tree也是一种<code>多路搜索树</code>,但是<code>基于 B-Tree 做了改进</code>,主流的 DBMS 都支持 B+Tree,比如 MySQL</p><p>相比于 B-Tree,B+Tree 更加<code>适合文件索引系统</code></p></blockquote><h4 class="anchor anchorWithStickyNavbar_loeA" id="btree-vs-b-tree">B+Tree Vs B-Tree<a class="hash-link" href="#btree-vs-b-tree" title="标题的直接链接">​</a></h4><ol><li><strong>有 k 个子节点就有 k 个元素。也就是<code>子节点数 = 节点内关键字数</code>，而 B-Tree中 <code>子节点数 = 节点内关键字数 + 1</code></strong></li><li><strong>非叶子节点的关键字也会同时存在于子节点中，并且关键字是在子节点中所有关键字的最大(或最小)</strong></li><li><strong>非叶子节点仅用于索引，不保存数据记录，数据都放在叶子节点中。而 <code>B-Tree中，所有的节点既保存索引,也保存数据记录</code> </strong></li><li><strong>所有关键字都在叶子节点出现，叶子节点之间构成一个有序链表，而且叶子节点本身按照关键字的大小<code>从小到大</code>顺序链接</strong></li></ol><h4 class="anchor anchorWithStickyNavbar_loeA" id="btree-优势">B+Tree 优势<a class="hash-link" href="#btree-优势" title="标题的直接链接">​</a></h4><ol><li><strong><code>B+Tree 查询效率更稳定</code></strong>, 因为 B+Tree 只有访问到叶子节点才能找到对应的数据。而在 B-Tree 中由于所有的节点都可以存储数据,那么就会导致查询不稳定的情况<ul><li>即 B-Tree 有时访问到非叶子节点就可以获取到数据, 但是有时候需要访问到叶子节点才能获取到数据</li></ul></li><li><strong><code>B+Tree查询效率更好</code></strong>, 因为通常 B+Tree比 B-Tree 更加的矮胖,查询所需要的 IO 次数越少。由于只有叶子节点存储数据,所以同样的磁盘页大小,B+Tree 可以存储更多的关键字</li><li>不仅在单个关键字的查询上,<code>在范围查询上,B+Tree的效率也比-Tree 高</code></li></ol><h4 class="anchor anchorWithStickyNavbar_loeA" id="思考">思考<a class="hash-link" href="#思考" title="标题的直接链接">​</a></h4><ol><li><strong>为了减少IO，索引树会一次性加载吗</strong><ul><li>数据库索引存储在磁盘上,如果数据量很大的就会导致索引也很大,<strong>所以我们在利用索引查询的时候, 是不可能将索引全都加载进内存的.<code>只能逐一的加载磁盘页,因为磁盘页对应索引的节点</code></strong></li></ul></li><li><strong>B+树的存储能力如何? 为何说一般查找行记录，最多只需1~3次磁盘IO</strong><ul><li>InnoDB 存储引擎中页的大小默认为<code>16KB</code>,一般表中主键类型为 INT(4 字节)、BIGINT(8 字节),指针类型一般为 4/8 字节,也就是说一个页(B+Tree 中的一个节点)大概存储<code>16KB/16B = 1K</code>个键值,那么深度为 3 的 B+Tree 可以维护 <code>1000*1000*1000=10 亿条记录</code>(这里假设一个数据页存储 1000 条数据) <ul><li>根节点存储 对应 1000 个中间节点,1 个中间节点对应 1000 个叶子节点,一共有 1 百万个叶子节点, 每个叶子节点中存储 1000 条数据,那么可以存储 100,0000 * 1000 = 10 亿条数据</li></ul></li><li>实际上,B+Tree 的高度一般在 2~4 层,且MySQL 的根节点常驻在内存中, 也就是查询某一个键值的数据是最多只要 1~3 次的磁盘 IO</li></ul></li><li><strong>Hash 索引与 B+Tree 索引的区别</strong><ul><li><code>Hash 索引不能进行范围查询</code>,因为 Hash 索引的指向是无序的,是通过算法给 索引一个位置,而 B+Tree 的叶子节点是有序的链表</li><li><code>Hash 索引不支持联合索引的最左侧元素(联合索引的部分索引无法使用)</code><ul><li>对于联合索引来说,Hash 索引计算Hash 值的时候是讲多个索引值合并后再一起计算 Hash 值,那么查询部分索引的时候就无法匹配到该 Hash 值</li></ul></li><li><code>Hash 索引不支持 Order By 排序</code>,同样是因为 Hash 索引的指向是无序的,是通过算法得到其位置的。而 B+Tree 索引本身就是通过关键字排序的,同样的,<code>Hash 索引也不支持模糊查询</code>,模糊查询本身也是范围查询,所以想要模糊查询需要遍历Hash 索引的每个节点</li></ul></li></ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/MagicalZhu/NoteLib/tree/main/docs/Mysql/高级特性/索引.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_N_05" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_VsjB"><span class="theme-last-updated">最后<!-- -->由 <b>YuLiang Zhu</b> <!-- -->于 <b><time datetime="2022-12-06T01:19:52.000Z">2022年12月6日</time></b> <!-- -->更新</span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/category/存储结构与索引"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">存储结构与索引</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/Mysql/高级特性/索引的应用"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">索引的应用</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_jeP5 thin-scrollbar theme-doc-toc-desktop"><p class="content_nRws">Contents</p><ul class="table-of-contents table-of-contents__left-border"><li><a href="#为什么使用索引" class="table-of-contents__link toc-highlight">为什么使用索引</a></li><li><a href="#索引优缺点" class="table-of-contents__link toc-highlight">索引优缺点</a></li><li><a href="#innodb-索引的推演" class="table-of-contents__link toc-highlight">InnoDb 索引的推演</a><ul><li><a href="#索引前的查找" class="table-of-contents__link toc-highlight">索引前的查找</a></li><li><a href="#设计索引" class="table-of-contents__link toc-highlight">设计索引</a><ul><li><a href="#简单的索引方案" class="table-of-contents__link toc-highlight">简单的索引方案</a></li><li><a href="#innodb索引方案1" class="table-of-contents__link toc-highlight">InnoDb索引方案(1)</a></li><li><a href="#innodb索引方案2" class="table-of-contents__link toc-highlight">InnoDb索引方案(2)</a></li><li><a href="#innodb索引方案3" class="table-of-contents__link toc-highlight">InnoDb索引方案(3)</a></li><li><a href="#b树" class="table-of-contents__link toc-highlight">B+树</a></li></ul></li><li><a href="#常见索引概念" class="table-of-contents__link toc-highlight">常见索引概念</a><ul><li><a href="#聚簇索引" class="table-of-contents__link toc-highlight">聚簇索引</a></li><li><a href="#非聚簇索引" class="table-of-contents__link toc-highlight">非聚簇索引</a><ul><li><a href="#概述" class="table-of-contents__link toc-highlight">概述</a></li><li><a href="#回表" class="table-of-contents__link toc-highlight">回表</a></li><li><a href="#回表的代价" class="table-of-contents__link toc-highlight">回表的代价</a></li></ul></li><li><a href="#联合索引" class="table-of-contents__link toc-highlight">联合索引</a></li></ul></li><li><a href="#b树注意点innodb" class="table-of-contents__link toc-highlight">B+树注意点(InnoDB)</a><ul><li><a href="#1-根页面位置不变" class="table-of-contents__link toc-highlight">1. 根页面位置不变</a></li><li><a href="#2目录项记录的唯一性" class="table-of-contents__link toc-highlight">2.目录项记录的唯一性</a></li><li><a href="#3一个页面最少存储2条记录" class="table-of-contents__link toc-highlight">3.一个页面最少存储2条记录</a></li></ul></li></ul></li><li><a href="#myisam-索引方案" class="table-of-contents__link toc-highlight">MyISAM 索引方案</a><ul><li><a href="#myisam-索引原理" class="table-of-contents__link toc-highlight">MyISAM 索引原理</a></li><li><a href="#myisam-与-innodb对比" class="table-of-contents__link toc-highlight">MyISAM 与 InnoDB对比</a></li></ul></li><li><a href="#索引的代价" class="table-of-contents__link toc-highlight">索引的代价</a></li><li><a href="#mysql数据结构选择的合理性" class="table-of-contents__link toc-highlight">MySQL数据结构选择的合理性</a><ul><li><a href="#全表遍历" class="table-of-contents__link toc-highlight">全表遍历</a></li><li><a href="#hash结构" class="table-of-contents__link toc-highlight">Hash结构</a><ul><li><a href="#基本概述" class="table-of-contents__link toc-highlight">基本概述</a></li><li><a href="#问题" class="table-of-contents__link toc-highlight">问题</a></li><li><a href="#适用性" class="table-of-contents__link toc-highlight">适用性</a></li><li><a href="#自适应哈希索引ahi" class="table-of-contents__link toc-highlight">自适应哈希索引(AHI)</a><ul><li><a href="#概述-1" class="table-of-contents__link toc-highlight"><strong>概述</strong></a></li></ul></li></ul></li><li><a href="#二叉搜索树" class="table-of-contents__link toc-highlight">二叉搜索树</a><ul><li><a href="#特点" class="table-of-contents__link toc-highlight">特点</a></li><li><a href="#示例" class="table-of-contents__link toc-highlight">示例</a></li></ul></li><li><a href="#avl-树" class="table-of-contents__link toc-highlight">AVL 树</a></li><li><a href="#b-tree" class="table-of-contents__link toc-highlight">B-Tree</a></li><li><a href="#btree" class="table-of-contents__link toc-highlight">B+Tree</a><ul><li><a href="#btree-vs-b-tree" class="table-of-contents__link toc-highlight">B+Tree Vs B-Tree</a></li><li><a href="#btree-优势" class="table-of-contents__link toc-highlight">B+Tree 优势</a></li><li><a href="#思考" class="table-of-contents__link toc-highlight">思考</a></li></ul></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">前端链接</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://v3.cn.vuejs.org/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Vue<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_2l9O"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://react.docschina.org/" target="_blank" rel="noopener noreferrer" class="footer__link-item">React<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_2l9O"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="http://ts.xcatliu.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item">TypeScript<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_2l9O"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener noreferrer" class="footer__link-item">MDN<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_2l9O"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">后端链接</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://spring.io/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Spring<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_2l9O"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Docker<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_2l9O"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://kubernetes.io/zh/docs/home/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Kubernetes<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_2l9O"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/index.html" target="_blank" rel="noopener noreferrer" class="footer__link-item">JVM<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_2l9O"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://juejin.cn" target="_blank" rel="noopener noreferrer" class="footer__link-item">掘金<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_2l9O"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.infoq.cn/" target="_blank" rel="noopener noreferrer" class="footer__link-item">InfoQ<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_2l9O"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_2l9O"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">文档构建</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://www.docusaurus.cn/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Docusaurus<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_2l9O"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://typoraio.cn" target="_blank" rel="noopener noreferrer" class="footer__link-item">Typora<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_2l9O"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 huakucha. Built With Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.bf86732a.js"></script>
<script src="/assets/js/main.98457ee6.js"></script>
</body>
</html>