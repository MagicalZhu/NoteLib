---
id: Java9 概述
title: Java9 概述
---

## 功能概述

Java9 提供了超过 150 项新功能, 比如:

1. **模块化系统**
2. **jSell 命令**
3. 多版本兼容 jar 包
4. **接口的私有方法**
5. 钻石操作符的使用升级
6. 语法改进: try 语句
7. 下划线使用限制
8. **String存储结构变更**
9. 遍历的集合特性: `of()`
10. **增强的 Stream API**
11. …

:::info api文档

java9 的[文档地址](https://docs.oracle.com/javase/9/)

:::

## 模块化系统(jMod)

> 模块化系统是 java9 的最大特性,官方 JEP:
>
> 1. [JEP 200: The Modular JDK](https://openjdk.org/jeps/200)
> 2. [JEP 201: Modular Source Code](https://openjdk.org/jeps/201)
> 3. [JEP 220: Modular Run-Time Images](https://openjdk.org/jeps/220)
> 4. [JEP 260: Encapsulate Most Internal APIs](https://openjdk.org/jeps/260)
> 5. [JEP 261: Module System](https://openjdk.org/jeps/261)
> 6. [JEP 282: jlink: The Java Linker](https://openjdk.org/jeps/282)

为什么需要模块化?**主要是因为 java 运行时环境的臃肿**,在 java 应用程序启动的时候就需要加载 `rt.jar`,不管其中类是否被类加载器 ClassLoader 加载,都会被 JVM 加载到内存中,**而模块化可以依据模块的需要按需加载需要的 Class**。

在 Java9 中将 `rt.jar`分成了多个不同的模块,  一个模块下可以包含多个包, 并且模块之间存在着依赖关系。其中` java.base` 模块是基础模块，不依赖其他模块。而图形化界面的库 `java.awt` 被放到了其他模块下, 这样在不使用这个模块的时候就无需让 jvm 加载, 减少内存浪费。

- 定义模块信息的文件: `module-info.java`
- 几个关键字
  - `module`
    - 用于定义一个模块,后面的是 **模块名**
  - `exports`
    - 用于导出模块,**模块是一个包名,而不是具体的文件名**
  - `requires`
    - 用于导入模块

比如有如下的目录结构:

```ini
├── Common
│   └── src
│     └── com
│       └── pacos
│          └── bean
│            └── User.java
```

那么就需要在 src 下新建一个 module-info 的文件, 用于导出模块:

```java
/**
 * 导出 module
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
module Common {
    exports com.pacos.bean;
}
```

如果需要在其他的 module 中使用该 User,就需要在`src` 下也新建一个`module-info.java` , 并导入模块`Common`:

```java
/**
 * 导入 module Common
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
module Test {
    requires Common;
}
```

该实例最后的目录结构:

```ini
├── Common
│   └── src
│     ├── com
│     │   └── pacos
│     │      └── bean
│     │         └── User.java
│     └── module-info.java
├── Test
│   └── src
│     ├── com
│     │   └── pacos
│     │      └── App.java
│     └── module-info.java
```

:::tip 提示

本质上说, java9 的模块话就是在原有的 package 基础上再"包"上一层

:::

## REPL工具 (jShell)

> 在一些编程语言中, 比如 python、ruby等都提供了 REPL (`Read Eval Print Loop`, 简单的交互式编程环境 ), 而 jshel l就是 java 语言平台中的 REPL
>
> JEP定义: [JEP 222: jshell: The Java Shell (Read-Eval-Print Loop) (openjdk.org)](https://openjdk.org/jeps/222)

- 基本命令

  - 进入:  **在终端中输入 `jshell` 即可**

  - 退出:  `/exit`
  - 获取帮助: `/help`
  - 查看默认已经导入的包: `/imports`
  - 打开简易的 jshell 编辑器: `/edit`

```bash
➜ jshell
|  欢迎使用 JShell -- 版本 21.0.2
|  要大致了解该版本, 请键入: /help intro

jshell> System.out.println("Hello,World");
Hello,World

jshell> /imports
|    import java.io.*
|    import java.math.*
|    import java.net.*
|    import java.nio.file.*
|    import java.util.*
|    import java.util.concurrent.*
|    import java.util.function.*
|    import java.util.prefs.*
|    import java.util.regex.*
|    import java.util.stream.*

jshell> /exit
|  再见
```

## 多版本jar (multi-release jar)

> 允许创建一个版本的 jar 文件, [JEP 238: Multi-Release JAR Files (openjdk.org)](https://openjdk.org/jeps/238)

多版本 JAR (mr-jar) 将包含针对特定 Java 平台版本的类和资源的附加目录, 比如一个典型库的 jar 可能如下所示：

```ini
jar root
  - A.class
  - B.class
  - C.class
  - D.class
```

假设 Java9 中功能的 A 和 B 存在替代版本,  那么我们可以将它们捆绑到一个 jar 中, 如下所示:

```ini
jar root
  - A.class
  - B.class
  - C.class
  - D.class
  - META-INF
     - versions
        - 9
           - A.class
           - B.class
```

在不支持 `mr-jar` 的 jdk 中，只有根目录中的类和资源可见, 而在支持 mr-jar 的 jdk 中，它只关注于当前版本以及之前版本的目录

- 首先在与当前运行的主要 Java 平台版本相对应的 Java 平台特定目录中搜索类和资源
- 然后搜索较低版本的目录
- 最后搜索 jar 根目录。在 Java 9 JDK 上，就好像有一个特定于 JAR 的类路径，其中首先包含版本 9 的文件，然后是 JAR 根目录；而在 Java 8 JDK 上，该类路径只包含 JAR 根目录。

对于上述的示例中,在 Java9 上,就会首先搜索 version 9 下的文件,然后是 jar 根目录。而在 Java8 上, 则该类路径只包含 jar 根目录

##  接口私有方法

>在 jdk9中新增了接口私有方法，即**可以在接口中声明 private修饰的方法了**, 这样接口越来越像抽象类
>
>[JEP 213: Milling Project Coin](https://openjdk.org/jeps/213)

- 在 jdk7 中,接口中只允许声明`全局常量(public static final)` 和 `抽象方法`
- 在 jdk8 中,接口中允许声明 `静态方法` 和 `默认方法`

```java
/**
 * 不同版本的 jdk 中接口
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public interface UserService {
    // java 7 中只允许出现静态常量、抽象方法
    public static final String SERVER_NAME = "service_name";
    void play();

    // java 8 中允许出现静态方法和默认方法
    static void say() {
        System.out.println("say...");
    }
    default void sing() {
        say();
        System.out.println("sing...");
        // 在默认方法中调用私有方法
        print();
    }

    // java 9 中允许出现私有方法
    private void print() {
        System.out.println("jdk9 print...");
    }
}
```

## 改进 try 语句

Java8 中可以通过 `try-with-resource` 的语法来**自动关闭资源文件**,使用方式: **将需要自动关闭的资源对象的创建放到 try 后面的小括号中**

```java
public class TryWithResource {
    public static void main(String[] args) throws FileNotFoundException {
        try (FileInputStream fileInputStream = new FileInputStream("");
             FileOutputStream fileOutputStream = new FileOutputStream("")) {
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

在 Java9 中, **可以将资源对象的创建代码放到小括号外面, 然后将需要自动关闭的对象名放到 try 后面的小括号中即可** :

```java
public class TryWithResource {
    public static void main(String[] args) throws FileNotFoundException {
        FileInputStream fis = new FileInputStream("");
        FileOutputStream fos = new FileOutputStream("");
        //多资源用分号隔开
        try (fis; fos) {
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## String 存储结构(Compact String)

> 目的: 为了提高 String 和相关类的空间效率，同时在大多数情况下保持性能，并与所有相关的 Java 和本地接口保持完全兼容。
>
> 官方 JEP: [JEP 254: Compact Strings ](https://openjdk.org/jeps/254)

在以前的版本中, 字符串类(`String、StringBuilder、StringBuffer`) 内部使用了`char[]` 进行存储, 每个字符占用 `2 个字节 (16 位)`, 而大部分拉丁字符**只需要 1 个字节的存储空间**,这样就导致 String 内部的字符数组中的一半空间都被闲置了

在 Java9 中, **将 字符串类内部的char[] 改成了 byte[]**, 这样节省了一半的内存占用:

```java
// java9 之前, String 底层使用 char[]
char c = 'a'; //2个字节

// java9 中, String 底层使用 byte[]
byte b = 97; //1个字节
```

并且字符串类中增加了下面2个成员变量

- `COMPACT_STRINGS`
  - 判断是否压缩, 默认是true
  - 如果为 false，则不压缩，使用UTF16编码
- `coder`
  - 用来区分使用的字符编码, 分别为 LATIN1（值为0）和UTF16（值为1）。

## 只读集合

- 在 Java9 之前, 需要通过工具类: `Collections#unmodifiableXxx` 方法**通过已有的集合创建一个新的只读集合**
- 在 Java9 中, 只需要通过 `List.of()`、`Map.of()`、`Set.of()` 方法就可以**直接创建一个只读的集合**

```java
public class ReadOnlyCollectionMap {
    public static void main(String[] args) {
        // java9之前
        List<String> list = new ArrayList<>();
        list.add("1");
        list.add("2");
        List readonly1 = Collections.unmodifiableList(list);

        List readonly2 = List.of("1","2");
    }
}
```

