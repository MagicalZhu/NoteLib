---
title: 基础知识
id: 基础知识
cssclasses:
  - wide-page
---

## 入门示例

> 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。`SqlSessionFactory` 的实例可以通过 `SqlSessionFactoryBuilder` 获得, 而 SqlSessionFactoryBuilder 则**可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例**

### 基于 XML

使用 MyBatis 的基本步骤如下:

1. 创建 MyBatis 配置文件 (全局配置文件)
   - `dataSource`: 配置数据源信息
   - `mappers`: 配置 sql 映射文件的位置
   - …

2. 创建 sql 映射文件,包含以下的信息
   - `namespace`: 映射文件的命名空间
   - `id`: sql 唯一标识
   - `returntype`: sql 返回值
   - sql语句
3. **使用 SqlSessionFactory**
   - 通过 MyBatis 的全局配置文件获取 `SqlSessionFactory`
   - 通过 SqlSessionFactory 得到 SqlSession
   - 通过 SqlSession 进行数据库的操作,通过 sql 标识符 确定执行哪一个SQL
     - 一个 SqlSession 就是一个数据库会话,所以用完需要关闭数据库

> 目录结构: 在 resource 目录下面创建 META-INF 以及子目录 mapper

首先创建 Mybatis 配置文件,配置数据库连接信息、sql 映射文件的位置:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/Study"/>
                <property name="username" value="root"/>
                <property name="password" value="123"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="META-INF/mapper/employeeMapper.xml"/>
    </mappers>
</configuration>
```

然后在 mapper 目录创建 sql 映射文件:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.pacos.Dao.employeeMapper">
    <select id="selectAll" resultType="com.pacos.Domain.Employee">
        select * from employee
    </select>
</mapper>
```

最后进行测试

- 首先通过 Mybatis 配置文件创建 SqlSessionFactory
- 然后通过 SqlSessionFactory 创建 SqlSession
- 最后利用 SqlSession 的 api 进行数据库的操作
  - 定位一个 sql statement 需要利用 sql 映射文件的 namespace 和 sql 标识符

```java
public class Demo {
    public static void main(String[] args) throws IOException {
        String resource = "META-INF/mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        try(SqlSession sqlSession = sqlSessionFactory.openSession()) {
            List<Employee> employeeList  = sqlSession.selectList("com.pacos.Dao.employeeMapper.selectAll");
            System.out.println(employeeList);
        }
    }
}
```

### 基于编码

> 基于编码的方式可以将 Mybatis 的 XML 配置文件替换为编码的方式, 即保持 sql 映射文件不变,但是不从配置文件中创建 SqlSessionFactory,而是直接编码

- 配置类: `Configuration`
- 环境: `Environment`
- 映射器注册器： `MapperRegistry`
- 类型处理器注册器: `TypeHandlerRegistry`
- 类型别名注册器: `TypeAliasRegistry`

首先是 sql 映射文件,将其放在了 resource/com/pacos/Dao 目录下,这是因为 ` configuration.addMapper` 的方式添加接口,Mybatis 会去接口目录下找同名的 sql 映射文件

```xml
<mapper namespace="com.pacos.Dao.employeeMapper">
    <select id="selectAll" resultType="com.pacos.Domain.Employee">
        select * from employee
    </select>
</mapper>
```

然后是通过编程的方式配置 Mybatis,并进行测试:

```java
/**
 * 采用编码的方式替换原有的 Mybatis XML 配置文件
 * 但是这种方式要求 sql 映射文件和接口在同一级目录
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class HardCodeDemo {
    public static void main(String[] args) throws IOException {
        // 1. 创建 Mybatis 配置
        Configuration configuration = new Configuration();
        // 2. 创建数据源 Datasource
        DataSource dataSource = new PooledDataSource("com.mysql.jdbc.Driver",
                "jdbc:mysql://localhost:3306/Study",
                "root",
                "123");

        // 3. 创建 Environment
        Environment environment = new Environment("dev", new JdbcTransactionFactory(), dataSource);
        configuration.setEnvironment(environment);
        configuration.addMapper(employeeMapper.class);

        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);
        try(SqlSession sqlSession = sqlSessionFactory.openSession()) {
            employeeMapper mapper = sqlSession.getMapper(employeeMapper.class);
            System.out.println(mapper.selectAll());
        }
    }
}
```

:::caution 注意

1. 这里的 employeeMapper 类是一个接口,它是对 sql 映射文件的一个 sql 语句的接口描述
2. 这实际就是 Mybatis 基于接口的方式

:::

### 接口式编程(常用)

> 1. 一般我们将 Mybatis 的配置信息放在 XML 文件中,而不是依赖于编程的方式
> 2. 日常开发中,我们一般都会建立一个 xxxMapper 接口,用于与 sql 映射文件中的 sql 绑定
> 3. **这种方式并不要求 sql 映射文件与接口放在同一目录结构下,因为 Mybaits 会读取并加载 mapper 标签中 resource 配置的 sql 映射文件**

接口式编程的基本步骤:

1. 创建 Mybatis 的配置文件 
2. 创建一个接口, 里面定义操作数据库的方法
3. 创建 Sql 映射文件
   - 将 namespace 定义为 接口的全类名
   - 将 id 改为 接口中定义的对应的方法名

首先,我们还是使用 Mybatis 的 XML 配置文件:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
		<!--设置开启驼峰命名自动映射-->
    <settings>
        <setting name="mapUnderscoreToCamelCase" value="true"/>
    </settings>
    <environments default="development">
        <environment id="development">
          	<!--设置事务管理器-->
            <transactionManager type="JDBC"/>
           <!--设置数据源信息-->
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/Study"/>
                <property name="username" value="root"/>
                <property name="password" value="123"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="META-INF/mapper/employeeMapper.xml"/>
    </mappers>
</configuration>
```

然后创建 Mapper 接口:

```java
package com.pacos.Dao;

import com.pacos.Domain.Employee;
import java.util.List;

public interface employeeMapper {
    // 获取所有的 Employee 数据
  	public List<Employee> selectAll();
}
```

然后创建 sql 映射文件,namespace 和 id 需要和 Mapper 接口保持一致

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--这里 sql 映射文件放在 resource/META-INF/mapper 下-->
<!--namespace 就是 Mapper 的全类名-->
<mapper namespace="com.pacos.Dao.employeeMapper">
  	<!--id 与 Mapper 接口中定义的方法名保持一致-->
    <select id="selectAll" resultType="com.pacos.Domain.Employee">
        select * from employee
    </select>
</mapper>
```

最后进行测试:

```java
/**
 * 基于接口的方式
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class BaseInterfaceDemo {
    public static void main(String[] args) throws IOException {
        String resource = "META-INF/mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        try(SqlSession sqlSession = sqlSessionFactory.openSession()) {
            // 这种方式也是可以的
            // List<Employee> employeeList  = sqlSession.selectList("com.pacos.Dao.employeeMapper.selectAll");

            // 但是更加推荐 接口的方式
            employeeMapper mapper = sqlSession.getMapper(employeeMapper.class);
            // Mybatis 会创建接口的代理对象
            // out: class com.sun.proxy.$Proxy8
            System.out.println(mapper.getClass());
            System.out.println(mapper.selectAll());
        }
    }
}
```

:::tip 关于代理对象

我们只定义了接口,并没有对接口进行实现,那么为什么可以通过接口进行操作呢?

因为 Mybatis 的  接口式编程依赖于动态代理,会创建一个代理对象, 并通过代理对象执行数据库操作的方法

:::

## Mybatis 配置

> 对于 Mybatis 的配置详情可以参看[官方文档](https://mybatis.org/mybatis-3/zh/configuration.html)

Mybatis 的 XML Configuration 配置可以分为一下的几部分(按顺序):

1. `properties`: 属性
2. `settings`: 设置
3. `typeAliases`: 类型别名
4. `typeHandlers`: 类型处理器
5. `objectFactory`
6. `plugins`: 插件
7. `environments`: 环境配置
   - environment
   - transactionManager: 事务管理器
   - dataSource: 数据源
8. `databaseIdProvider`: 数据库厂商标识
9. `mappers`: 映射器

### properties

这些属性**除了可以在 XML 文件中定义, 还可以使用外部化配置,并可以进行动态替换。**也就是说既可以在 properties 文件中配置这些属性，也可以在 properties 元素的子元素中设置。而设置的属性可以在整个 Mybatis 配置文件中用来**替换需要动态配置的属性值**:

```xml
<properties resource="org/mybatis/example/config.properties">
  <property name="username" value="dev_user"/>
  <property name="password" value="F2Fa3!33TYyg"/>
</properties>

<!--数据源配置-->
<dataSource type="POOLED">
  <property name="driver" value="${driver}"/>
  <property name="url" value="${url}"/>
  <property name="username" value="${username}"/>
  <property name="password" value="${password}"/>
</dataSource>
```

#### 基本示例

首先创建一个外部化配置 properties 文件

```ini
# 将数据源信息中的用户名和密码配置在这里
username=root
password=123
```

然后在 Mybatis 配置文件中引入上述的 外部化配置文件,并添加其他属性:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
  	<!--highlight-start-->
  	<!--引入上述的外部化配置文件,并且添加其他的属性-->
    <properties resource="META-INF/db.properties">
        <property name="driver" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/Study"/>
    </properties>
    <!--highlight-end-->
    <settings>
        <setting name="mapUnderscoreToCamelCase" value="true"/>
    </settings>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
          	<!--可以直接使用所有的属性,包括外部化配置属性-->
            <dataSource type="POOLED">
                <property name="driver" value="${driver}"/>
                <property name="url" value="${url}"/>
                <property name="username" value="${username}"/>
                <property name="password" value="${password}"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="META-INF/mapper/employeeMapper.xml"/>
    </mappers>
</configuration>
```

#### 动态替换

在通过 `SqlSessionFactoryBuilder#build` 方法创建 SqlSessionFactory 的时候,可以额外的传入 `Properties` 参数,对 Mybatis 配置中的属性进行替换

假设没有使用外部化配置(没有设置 username 和 password), 那么 Mybatis 配置文件如下:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <properties>
        <property name="driver" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/Study"/>
    </properties>
    <!--...[省略部分配置]-->
</configuration>
```

在创建 SqlSessionFactory 的时候,可以动态的传入属性

```java
public static void main(String[] args) throws IOException {
      String resource = "META-INF/mybatis-config.xml";
      InputStream inputStream = Resources.getResourceAsStream(resource);
      // highlight-start
     // 动态的传入属性
      Properties properties = new Properties();
      properties.put("username", "root");
      properties.put("password", "123");
      SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream,properties);
      // highlight-end
      try(SqlSession sqlSession = sqlSessionFactory.openSession()) {
          List<Employee> employeeList  = sqlSession.selectList("com.pacos.Dao.employeeMapper.selectAll");
          System.out.println(employeeList);
      }
  }
```

#### 读取顺序问题

我们知道,Mybatis 配置中的属性值有 3 种来源:

1. 外部化配置文件
2. Mybatis 配置中的定义的 properties
3. 创建 SqlSessionFactory 的时候,动态传入

那么这 3 种方式的加载顺序**从低到高**为:

- 首先读取 Mybatis 配置中的定义的 properties
  - 即在 properties 元素体内指定的属性。
- 然后读取 外部化配置文件中的数据, 并覆盖之前读取过的同名属性。
  - 即根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路径读取属性文件，
- 最后读取创建 SqlSessionFactory 时动态传入的属性, 并覆盖之前读取过的同名属性。
  - 即作为方法参数传递的属性

```java
public static void main(String[] args) throws IOException {
      String resource = "META-INF/mybatis-config.xml";
      InputStream inputStream = Resources.getResourceAsStream(resource);
      Properties properties = new Properties();
      properties.put("username", "root");
      // highlight-start
  		// 这里的 password 会覆盖前面设定的属性值
		  // 比如这里设置错误的密码,查询时会抛出异常
      properties.put("password", "xxxxx");
      // highlight-end  
      SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream,properties);
      try(SqlSession sqlSession = sqlSessionFactory.openSession()) {
          List<Employee> employeeList  = sqlSession.selectList("com.pacos.Dao.employeeMapper.selectAll");
          System.out.println(employeeList);
      }
  }
```

:::caution 关于属性值覆盖的问题

如果同时存在多种属性数据来源,那么后者读取的时候,会覆盖之前读取过的同名属性

:::

### settings

> 这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。下面给出比较常见的修改设置

比如最常见的 *mapUnderscoreToCamelCase*, 就是用于将数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn

|           设置名           |                             说明                             |          可选值          | 默认值  |
| :------------------------: | :----------------------------------------------------------: | :----------------------: | :-----: |
| `mapUnderscoreToCamelCase` |                   是否开启驼峰命名自动映射                   |      true \| false       |  false  |
|   `defaultExecutorType`    | 配置默认的执行器。<br/>`SIMPLE` 就是普通的执行器；<br/>`REUSE` : 执行器会重用预处理语句（PreparedStatement）； <br/>`BATCH` : 执行器不仅重用语句还会执行批量更新。 | SIMPLE \| REUSE \| BATCH | SIMPLE  |
|     `useGeneratedKeys`     | **允许 JDBC 支持自动生成主键**，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。 |      true \| false       |  false  |
|     `localCacheScope`      | MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 <br/>`SESSION` : 会缓存一个会话中执行的所有查询。<br/> `STATEMENT`: 本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。 |   SESSION \| STATEMENT   | SESSION |
|       `cacheEnabled`       |   全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。   |      true \| false       |  true   |

比如配置驼峰转换功能:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <properties resource="META-INF/db.properties">
        <property name="driver" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/Study"/>
    </properties>
    <settings>
      	<!-- 开启驼峰转换 -->
        <setting name="mapUnderscoreToCamelCase" value="true"/>
    </settings>
    <!--....[省略部分配置]-->
</configuration>
```

### typeAliases

> typeAliases 就是类型别名

类型别名可以为 java 类型设置一个缩写名字, **但是它仅用于 Mybatis 配置中, 并且主要用于降低冗余的全限定类名书写**:

#### 基本使用

通过 `typeAlias` 标签的 *alias + type* 属性可以注册一个类型别名,比如:

```xml
<typeAliases>
  <typeAlias alias="Employee" type="com.pacos.Domain.Employee"/>
</typeAliases>
```

经过上述的配置后，就可以在 Mybatis 的 相关 XML 文件(配置文件 和 sql 映射文件) 中使用了:

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.pacos.Dao.employeeMapper">
    <!-- resultType="Employee" 就是使用了类型别名  -->
    <select id="selectAll" resultType="Employee">
        select * from employee
    </select>
</mapper>
```

#### 批量注册

除了通过 `typeAlias` 子标签单独注册别名之外，Mybatis 还支持通过  `package` 子标签设置一个"基础包名"来实现"批量注册别名"

假设在 *com.pacos.Domain* 中存储的都是 java bean,并且目录结构如下:

```java
com
├─ pacos
│  ├─ Domain
│  │  ├─ Employee.java
│  │  ├─ Department.java

```

那么在 Mybatis 配置文件中可以添加一个如下的 package 子标签,然后 MyBatis 会在指定的包名下面搜索需要的 java bean:

```xml
<typeAliases>
  <package name="com.pacos.Domain"/>
</typeAliases>
```

**默认情况下, Mybatis 会使用 java bean 的首字母小写的非限定类名来作为它的别名**,比如 com.pacos.Domain.Employee 的别名为 employee。

或者也可以通过 `@Alias` 注解的方式手动指定别名:

```java
// 别名不再是 employee ,而是 Employee
@Alias("Employee")
public class Employee {
  // ....[省略部分代码]
}
```

### typeHandlers

MyBatis 在 **设置预处理语句(PreparedStatement)中的参数或从结果集中取出一个值时**, 都会用类型处理器将获取到的值以合适的方式转换成 java 类型。一般来说 Mybatis 内置的类型处理器已经足够使用

- 默认的类型处理器位于: `org.apache.ibatis.type`
  - **BooleanTypeHandler**: 处理 java 的 Boolean/bool 类型 与 数据库兼容的 BOOLEAN
  - **IntegerTypeHandler**: 处理 java 的 Integer/int 类型 与 数据库兼容的 NUMERIC / INTEGER
  - ….
- 类型处理器注册器: `TypeHandlerRegistry`

```java
// Mybatis 提供的 StringTypeHandler
public class StringTypeHandler extends BaseTypeHandler<String> {

  @Override
  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType)
      throws SQLException {
    ps.setString(i, parameter);
  }

  @Override
  public String getNullableResult(ResultSet rs, String columnName)
      throws SQLException {
    return rs.getString(columnName);
  }

  @Override
  public String getNullableResult(ResultSet rs, int columnIndex)
      throws SQLException {
    return rs.getString(columnIndex);
  }

  @Override
  public String getNullableResult(CallableStatement cs, int columnIndex)
      throws SQLException {
    return cs.getString(columnIndex);
  }
}

```

#### 拓展类型处理器

### plugins

> 插件 plugins 是拓展 Mybatis 的一种方式,比如 PageHelper 等增强库就是使用插件的方式对 Mybatis 的运行时进行调整

MyBatis 允许开发者在**sql 映射语句执行过程中的某一点进行拦截调用**(**动态代理**)。

默认情况下, MyBatis 允许使用插件来拦截的方法调用包括:

1. `Executor`
    - update()
    - query()
    - flushStatements()
    - commit()
    - rollback()
    - getTransaction()
    - close()
    - isClosed()
2. `ParameterHandler`
    - getParameterObject()
    - setParameters()
3. `ResultSetHandler`
    - handleResultSets()
    - handleOutputParameters()
4. `StatementHandler`
    - prepare()
    - parameterize()
    - batch()
    - update()
    - query()

### mappers

mappers 的作用 将 sql 映射文件 注册到全局配置文件中,Mybatis 会据此去指定路径中查找 sql 映射文件

Mybatis 支持多种方法:

1. 使用相对于类路径的资源引用

   ```xml
   <!-- 使用相对于类路径的资源引用 -->
   <mappers>
     <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>
     <mapper resource="org/mybatis/builder/BlogMapper.xml"/>
     <mapper resource="org/mybatis/builder/PostMapper.xml"/>
   </mappers>
   ```



2. 使用映射器接口实现类的完全限定类名

   ```xml
   <!-- 使用映射器接口实现类的完全限定类名 -->
   <mappers>
     <mapper class="org.mybatis.builder.AuthorMapper"/>
     <mapper class="org.mybatis.builder.BlogMapper"/>
     <mapper class="org.mybatis.builder.PostMapper"/>
   </mappers>
   ```



3. 包内的映射器接口全部注册为映射器

   ```xml
   <!-- 将包内的映射器接口全部注册为映射器 -->
   <mappers>
     <package name="org.mybatis.builder"/>
   </mappers>
   ```



#### 基本原理

- 在解析 package 标签的时候, 实际是扫描并添加 package 下所有的 Mapper 接口
- 如果是 mapper 标签,那么会获取 resource、url、class 属性
  - 如果 resource、url 不为空, 就加载 resource 对应的资源( sql 映射文件 )
  - 如果 class 不为空,就添加 class 对应的 Mapper 接口

所以: **如果注册的是 sql 映射文件,那么不会要求 sql 映射文件的目录结构与 接口的目录结构一致!否则,就需要在同一目录下**

```java title="XMLConfigBuilder#mapperElement"
private void mapperElement(XNode parent) throws Exception {
  if (parent != null) {
    for (XNode child : parent.getChildren()) {
      // 如果是 package 标签
      if ("package".equals(child.getName())) {
        String mapperPackage = child.getStringAttribute("name");
        configuration.addMappers(mapperPackage);
      } else {
        // 如果是 mapper 标签
        // 获取 resource、url、class 属性
        String resource = child.getStringAttribute("resource");
        String url = child.getStringAttribute("url");
        String mapperClass = child.getStringAttribute("class");
        // 首先判断 resource 属性值
        if (resource != null && url == null && mapperClass == null) {
          ErrorContext.instance().resource(resource);
          InputStream inputStream = Resources.getResourceAsStream(resource);
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, 
                                                               configuration,
                                                               resource,
                                                               configuration.getSqlFragments());
          mapperParser.parse();
        } else if (resource == null && url != null && mapperClass == null) {
          // 再判断 url 属性
          ErrorContext.instance().resource(url);
          InputStream inputStream = Resources.getUrlAsStream(url);
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, 
                                                               configuration,
                                                               url,
                                                               configuration.getSqlFragments());
          mapperParser.parse();
        } else if (resource == null && url == null && mapperClass != null) {
          // 最后判断 class 属性
          Class<?> mapperInterface = Resources.classForName(mapperClass);
          configuration.addMapper(mapperInterface);
        } else {
          // ...[异常处理]
        }
      }
    }
  }
}
```

