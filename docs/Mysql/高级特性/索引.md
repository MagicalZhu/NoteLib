---
id: 索引
title: 索引
---



## 为什么使用索引

> 索引是存储引擎用于快速找到数据记录的一种数据结构 , MySQL 在进行数据查询的时候,首先查看查询条件是否命中某条索引。如果命中则`通过索引查找数据`,如果不符合就`全表扫描`,直到找到为止!

![image-20220529153631832](./image/索引/image-20220529153631832.png)

1. 最左边数据库没有索引的情况下,`数据分散在磁盘的不同位置`,读取数据的时候，摆臂需要前后摆动查询数据，非常耗时
2. 按中间的方式对上面的一种方式优化,如果`数据顺序存储`,那么也需要从第一行开始逐行读取,将数据从磁盘加载到内存中。那么查询 第六行数据也需要进行 N 次的磁盘 IO 操作，仍然十分耗时
3. 最后一种方式对 Col2 添加了索引,`相当于在磁盘上为 Col2 维护了一个索引的数据结构 -> 二叉搜索树`。二叉搜索树是的每个节点存储的是`K-V 结构`, key 是 Col2，value 是该 key 对应的`文件指针(地址)`

<mark>所以建立索引的目的就是: 减少<strong>磁盘 IO</strong> 的次数，加快查询效率</mark>

## 索引优缺点

> MySQL 官方对索引的定义为: `索引(index)是帮助 MySQL高效获取数据的数据结构`

- 索引的本质是`数据结构`, 可以简单的理解为**`排好序`**的快速查找数据结构,满足特定查找算法。这些数据结构以某种方式执行数据,这样就可以在这些数据结构的基础上实现`高级查找算法`

- `索引是在存储引擎中实现的`, 所以每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有的索引类型。同时存储引擎可以定义每个表的`最大索引数、最大索引长度`。

- **所有存储引擎支持每个表至少 `16` 个索引,总索引长度至少为 `256` 个字节**

- **索引的优点**
  1. **通过建立索引,可以提高检索效率,从而降低数据库IO 的成本**
  2. **通过创建索引来保证每一行数据的唯一性**
  3. 可以加速表与表之间的连接,即**对于有依赖关系的父子表联合查询时,可以提高查询速度**
  4. 在使用分组和排序子句进行数据查询时,可以显著**减少查询中分组和排序的时间**,降低了 CPU 的消耗
- **索引的缺点**
  1. **创建和维护索引需要耗费时间,耗费的时间会随着数据量的增加而增加**
  2. **索引需要占用磁盘空间, 如果有大量的索引,索引文件就可能比数据文件更快达到最大文件尺寸**
  3. **索引虽然可以提高查询速度,但是会降低表更新速度。因为对表数据进行增删改时,索引也需要动态的维护**

:::tip 提示

索引可以提高查询的速度,但是会影响插入速度，因为每次插入数据都需要动态的维护索引。这种情况下,最好的办法就是先删除表中的索引后再插入数据,插入完成后再创建索引

:::

## InnoDb 索引的推演

### 索引前的查找

> 一个精确匹配的 Sql 语句: 
>
> ```sql
> SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
> ```



**一个页中查询**

假设表的数据较少,所有的记录都可以放到一个页中,在查询记录的时候可以按照搜索条件的不同分为下面两种情况

1. **以主键为搜索条件**
   - 可以在页目录使用`二分法` 快速定位到对应的槽,然后再遍历该槽对应分组中的记录就可以快速找到指定的记录
2. **以其他列作为搜索条件**
   - 因为数据页中没有对非主键列建立页目录,所以无法通过二分法快速定位槽，这样只能从`最小记录`开始`依次遍历`单链表中的每条记录，然后对比每条记录是否符合搜索条件
   - 这里单链表指的是某条数据记录下一条数据的内存地址

**很多页中查询**

大部分情况下,表中存放的数据是很多的,需要很多的数据页来存储数据。在很多页中查询的话分为两个步骤

1. 定位到记录的页
2. 从所在的页中查找相应的记录

在没有索引的情况下，无论是否按照主键列还是其他列进行查询。由于无法快速定位到记录所在的数据页,所以`只能从第一页开始沿着双向链表一致往下找`,每一页都会按照上面单页的方式查询指定的记录。由于要遍历所有的数据页,那么所以效率极其低下。

### 设计索引

>建一个表
>
>```sql
>CREATE TABLE index_demo( 
>  	c1 INT,
>	c2 INT,
>	c3 CHAR(1), 
>  	PRIMARY KEY(c1)
>) ROW_FORMAT =Compact;
>```

新建的 index_demo 表有 2 个 INT 类型的列，1个 Char(1) 类型的列,并且c1为主键。这个表使用`Compact`行格式来实际存储数据

![image-20220529172547929](./image/索引/image-20220529172547929.png)

**Compact行格式展示记录的这几个部分(部分信息)**

1. `record_type`
   - 记录头信息的一项属性，**表示记录的类型**
     - `0` : 表示普通记录
     - `2` : 表示最小记录
     - `3` : 表示最大记录
     - `1` : B+树节点指针
2. `next_record`
   - 记录头信息的一项属性，**表示下一条地址相对于本条记录的地址偏移量**
3. `各个列的值`
   - 记录在表中列

**基本数据页的模型：**

> 如下图所示：
>
> 1. head 头部的 record_type=2，说明 next_record 指向当前页的最小记录
>
> 2. 中间的 record_type=2,说明都是普通的记录,并且 next_record指向下一条记录。并且最后一条普通记录指向 record_type=3 的最大记录
> 3. tail 尾部的 record_type=3，说明 next_record 指向**下一页**的最小记录(对于当前页面来说是最大值)

![image-20220529163641319](./image/索引/image-20220529163641319.png)



#### 简单的索引方案

由于各页中的数据没有规律,所以在查询的时候不得不遍历所有的数据。如果我们想要快速的定位到记录所在的数据页,需要建立一个**目录**,建立目录需要完成一下的事情:

1. **下一个数据页中记录的主键值必须大于上一页中所有记录的主键值**
   - 在对记录进行增删改的时候,我们需要通过一些比如`记录移动` 的操作来保证当前数据页的最小记录的主键值大于上一页的最大记录的主键值,这个过程称为**`页分裂`**
2. **给所有的页建立一个目录项**
   - 数据页在物理存储上是不连续的,但是为了保证连续性,需要建立`目录(索引)`,每一个数据页对应一个`目录项`
     - `目录项` 记录了: **页码** 和 **数据页中用户记录的最小值**
   - 通过维护目录可以得到一个 **在逻辑上连续存储的数据页**

:::info 简单索引方案示例

**1. 下一个数据页中记录的主键值必须大于上一页中所有记录的主键值**

向 index_demo的表中添加数据

```sql
# 插入的数据中主键不是递增的
insert into index_demo values 
(1,4,'u'),(5,3,'y', 3,9,'d')
```

在插入的数据中主键不是递增的,但是数据页中数据递增的，便得到下面的图:

![image-20220605125955396](./image/索引/image-20220605125955396.png)

此时我们再插入一条数据:

```sql
insert into index_demo values  (4,4,'a')
```

我们假设数据页最多只能存储 3 条数据,那么需要在分配一个数据页。当然数据页在物理上不一定是连续的,只需要在逻辑上保持连续即可。

![image-20220605130339882](./image/索引/image-20220605130339882.png)

上图中 页28 的主键最大值是 4，而 页10 的主键最大值为 5，这个不符合要求，所以在插入这条 主键值=4 的记录时,需要伴随着一次`记录移动`,将 主键值=5 的数据移动到 页28 里面,插入的这条主键值=4的记录移动到 页10 里面,得到的模型图如下:

![image-20220605130906729](./image/索引/image-20220605130906729.png)



**2.给所有目录建立一个目录项**

由于数据页的`编号不一定是连续的`,所以在向index_demo 表中插入多条数据的时候,可能得到的结果是这样的:

![image-20220605131755873](./image/索引/image-20220605131755873.png)

因为这些`16kb`的页在物理存储上是不连续的,如果想从多个数据页中根据主键值`快速定位某些记录所在的页`,我们需要给这些数据页做一个**`目录`**，每个页对应一个`目录项`，每个目录项包含一下的内容

- **页的用户记录中最小的主键值，我们用`key` 来表示**
- **页号,我们用`page_no`来表示**

那么上述的几个数据页得到的命令就如图所示:

![image-20220605132249255](./image/索引/image-20220605132249255.png)

以页28 为例,它对应目录项2,包含了该页的 `页号28` 以及`该页中用户记录的最小主键值 5`。

**我们只需要把几个目录项在物理存储器上连续存储(比如:数组)，就可以实现根据主键值快速查找某条记录的功能了**

比如:查找主键值为 20 的记录，具体查找过程分两步:

- 先从目录项中根据 `二分法` 快速确定出主键值为 20 的记录在 目录项3 中(因为 12 < 20 < 209 )，它对应的页是`页9`

- 再根据前边说的在页中查找记录的方式去 `页9` 中定位具体的记录

至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 **`索引`** 。

:::

#### InnoDb索引方案(1)

> 到这里我们认识到,通过建立逻辑连续的索引，以及目录项可以帮助我们快速的定位到查询的数据。但是我们有需要如何存储索引呢?

**目录项纪录的页**

我们把前边使用到的目录项放到数据页中的样子就是这样:

![image-20220605135545068](./image/索引/image-20220605135545068.png)



从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录,这里`目录项记录` 和 `普通的用户记录`的不同点在于:

- `目录项的 record_type = 1`,而 普通的用户记录 record_type = 0

- 目录项记录只有`主键值` 和 `页编号`两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列 ，另外还有InnoDB自己添加的隐藏列

两个记录的**相同点**:

- 两者用的是一样的数据页，都会为主键值生成 `Page Directory(页目录)`, 通过**页目录**可以按照主键值进行查找时可以使用 `二分法` 来加快查询速度

:::info 查询示例

现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步:

1. 先到存储 **目录项记录** 的页，也就是页30中通过 **二分法** 快速定位到对应目录项，因为 *12 < 20 < 209* ，所以定位到对应的记录所在的页就是页9
2. 再到存储用户记录的页9中根据 **二分法** 快速定位到主键值为 20 的用户记录。

:::

#### InnoDb索引方案(2)

> 上述的方案中,将目录项存储到了数据页中,但是当目录项很多以至于一个数据页中存储不了的时候，会分配一个新的数据页来存储目录项

**多个目录项纪录的页**

![image-20220605140247250](./image/索引/image-20220605140247250.png)

从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页:

- 为存储该用户记录而新生成了 **页31** 
- 因为原先存储目录项记录的 页30 的容量已满 (我们前边假设只能存储4条目录项记录)，所以需要一个新的 页32 来存放 页31 对应的目录项

:::info 查询示例

现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例：

1. 确定 **目录项记录页**, 我们现在的存储目录项记录的页有两个: 页30 和 页32 

2. 通过 目录项记录页 确定用户记录真实所在的页

3. 在真实存储用户记录的页中定位到具体的记录

:::



#### InnoDb索引方案(3)

经历上述的推演后,我们对目录页在创建一个数据页，维护目录信息，最后大致推演出一个索引的数据的数据结构，这个数据结构就是 **`B+树`**

- **B+ 树底层节点(叶子节点)存储的是用户记录,其他节点(非叶子节点、内节点)存储的是目录项记录，最顶上的称为根节点**
- **单个数据页中的记录之间采用单链表的形式连接**
- **多个数据页之间使用双链表连接**

![image-20220605162335284](./image/索引/image-20220605162335284.png)



#### B+树

1. 一个 B+ 树可以分为好几层，`规定最下边的那层，也就是存放我们用户记录的那层为 第 0 层`, 之后依次往上加
2. 实际上`B+树一般都不会超过4层`，因为 4 层已经存储到很大的数据量了，并且树层次越低，磁盘 IO 的次数越少
3. 通过主键值去查找某条记录最多只需要做4个页面内的查找(查找3个目录项页和一个用户记录页)，又因为在每个页面内有`Page Directory(页目录)`,所以在页面内也可以通过 `二分法` 实现快速定位记录。



### 常见索引概念

> 索引按照物理实现方式，索引可以分为 2 种:
>
> 1. **聚簇(聚集)索引**
> 2. **非聚簇(非聚集)索引**、也叫做二级索引或者辅助索引



#### 聚簇索引

- **特点**
  1. <mark>使用记录主键值的大小进行记录和页的排序</mark>，这包括三个方面的含义

     - **`数据页`内的记录是按照 `主键的大小顺序` 排成一个 `单向链表`**
     - **各个存储 `用户记录的数据页` 也是根据页中`用户记录的主键大小顺序`排成一个`双向链表`**
     - **存放 `目录项记录的页`, 分为不同的层次，在同一层次中的页也是根据页中`目录项记录的主键大小顺序`排成一个 `双向链表`**
  2. <mark>B+树的<strong>叶子节点</strong>存储的是完整的用户记录</mark> 

     - 所谓完整的用户记录，就是指这个记录中存储了所有列的值(包括隐藏列)
- **优点**
  - `数据访问更快`,因为聚簇索引将 **索引和数据保存在同一个 B+ 树中**，所以从聚簇索引中获取数据比非 聚簇索引更快
  - 聚簇索引对于主键的 `排序查找` 和 `范围查找` 速度非常快
    - 按照聚簇索引排列顺序，查询一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据,所以节省了大量的磁盘 IO
  
- **缺点**
  - `插入速度严重依赖于插入顺序`, 按照主键的顺序插入是最快的方式，否则将会出现`页分裂`，严重影响性能
    - 对于InnoDB表，我们一般都会定义一个 **自增主键 ID**
  
  - `更新主键的代价很高`, 因为将会导致被更新的行移动到其他数据页
    - 对于InnoDB表，我们一般定义 **主键不可更新**
  
  - `二级索引需要两次索引查找`, 第一次找到主键值，第二次根据主键值找到行数据
  

