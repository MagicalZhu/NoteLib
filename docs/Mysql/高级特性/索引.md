---
id: 索引
title: 索引
---



## 为什么使用索引

> 索引是存储引擎用于快速找到数据记录的一种数据结构 , MySQL 在进行数据查询的时候,首先查看查询条件是否命中某条索引。如果命中则`通过索引查找数据`,如果不符合就`全表扫描`,直到找到为止!

![image-20220529153631832](./image/索引/image-20220529153631832.png)

1. 最左边数据库没有索引的情况下,`数据分散在磁盘的不同位置`,读取数据的时候，摆臂需要前后摆动查询数据，非常耗时
2. 按中间的方式对上面的一种方式优化,如果`数据顺序存储`,那么也需要从第一行开始逐行读取,将数据从磁盘加载到内存中。那么查询 第六行数据也需要进行 N 次的磁盘 IO 操作，仍然十分耗时
3. 最后一种方式对 Col2 添加了索引,`相当于在磁盘上为 Col2 维护了一个索引的数据结构 -> 二叉搜索树`。二叉搜索树是的每个节点存储的是`K-V 结构`, key 是 Col2，value 是该 key 对应的`文件指针(地址)`

<mark>所以建立索引的目的就是: 减少<strong>磁盘 IO</strong> 的次数，加快查询效率</mark>

## 索引优缺点

> MySQL 官方对索引的定义为: `索引(index)是帮助 MySQL高效获取数据的数据结构`

- 索引的本质是`数据结构`, 可以简单的理解为**`排好序`**的快速查找数据结构,满足特定查找算法。这些数据结构以某种方式执行数据,这样就可以在这些数据结构的基础上实现`高级查找算法`

- `索引是在存储引擎中实现的`, 所以每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有的索引类型。同时存储引擎可以定义每个表的`最大索引数、最大索引长度`。

- **所有存储引擎支持每个表至少 `16` 个索引,总索引长度至少为 `256` 个字节**

- **索引的优点**
  1. **通过建立索引,可以提高检索效率,从而降低数据库IO 的成本**
  2. **通过创建索引来保证每一行数据的唯一性**
  3. 可以加速表与表之间的连接,即**对于有依赖关系的父子表联合查询时,可以提高查询速度**
  4. 在使用分组和排序子句进行数据查询时,可以显著**减少查询中分组和排序的时间**,降低了 CPU 的消耗
- **索引的缺点**
  1. **创建和维护索引需要耗费时间,耗费的时间会随着数据量的增加而增加**
  2. **索引需要占用磁盘空间, 如果有大量的索引,索引文件就可能比数据文件更快达到最大文件尺寸**
  3. **索引虽然可以提高查询速度,但是会降低表更新速度。因为对表数据进行增删改时,索引也需要动态的维护**

:::tip 提示

索引可以提高查询的速度,但是会影响插入速度，因为每次插入数据都需要动态的维护索引。这种情况下,最好的办法就是先删除表中的索引后再插入数据,插入完成后再创建索引

:::

## InnoDb 索引的推演

### 索引前的查找

> 一个精确匹配的 Sql 语句: 
>
> ```sql
> SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
> ```



**一个页中查询**

假设表的数据较少,所有的记录都可以放到一个页中,在查询记录的时候可以按照搜索条件的不同分为下面两种情况

1. **以主键为搜索条件**
   - 可以在页目录使用`二分法` 快速定位到对应的槽,然后再遍历该槽对应分组中的记录就可以快速找到指定的记录
2. **以其他列作为搜索条件**
   - 因为数据页中没有对非主键列建立页目录,所以无法通过二分法快速定位槽，这样只能从`最小记录`开始`依次遍历`单链表中的每条记录，然后对比每条记录是否符合搜索条件
   - 这里单链表指的是某条数据记录下一条数据的内存地址

**很多页中查询**

大部分情况下,表中存放的数据是很多的,需要很多的数据页来存储数据。在很多页中查询的话分为两个步骤

1. 定位到记录的页
2. 从所在的页中查找相应的记录

在没有索引的情况下，无论是否按照主键列还是其他列进行查询。由于无法快速定位到记录所在的数据页,所以`只能从第一页开始沿着双向链表一致往下找`,每一页都会按照上面单页的方式查询指定的记录。由于要遍历所有的数据页,那么所以效率极其低下。

### 设计索引

>建一个表
>
>```sql
>CREATE TABLE index_demo( 
>  	c1 INT,
>	c2 INT,
>	c3 CHAR(1), 
>  	PRIMARY KEY(c1)
>) ROW_FORMAT =Compact;
>```

新建的 index_demo 表有 2 个 INT 类型的列，1个 Char(1) 类型的列,并且c1为主键。这个表使用`Compact`行格式来实际存储数据

![image-20220529172547929](./image/索引/image-20220529172547929.png)

**Compact行格式展示记录的这几个部分(部分信息)**

1. `record_type`
   - 记录头信息的一项属性，**表示记录的类型**
     - `0` : 表示普通记录
     - `2` : 表示最小记录
     - `3` : 表示最大记录
     - `1` : B+树节点指针
2. `next_record`
   - 记录头信息的一项属性，**表示下一条地址相对于本条记录的地址偏移量**
3. `各个列的值`
   - 记录在表中列

**基本数据页的模型：**

> 如下图所示：
>
> 1. head 头部的 record_type=2，说明 next_record 指向当前页的最小记录
>
> 2. 中间的 record_type=2,说明都是普通的记录,并且 next_record指向下一条记录。并且最后一条普通记录指向 record_type=3 的最大记录
> 3. tail 尾部的 record_type=3，说明 next_record 指向**下一页**的最小记录(对于当前页面来说是最大值)

![image-20220529163641319](./image/索引/image-20220529163641319.png)



#### 简单的索引方案

由于各页中的数据没有规律,所以在查询的时候不得不遍历所有的数据。如果我们想要快速的定位到记录所在的数据页,需要建立一个**目录**,建立目录需要完成一下的事情:

1. **下一个数据页中记录的主键值必须大于上一页中所有记录的主键值**
   - 在对记录进行增删改的时候,我们需要通过一些比如`记录移动` 的操作来保证当前数据页的最小记录的主键值大于上一页的最大记录的主键值,这个过程称为**`页分裂`**
2. **给所有的页建立一个目录项**
   - 数据页在物理存储上是不连续的,但是为了保证连续性,需要建立`目录(索引)`,每一个数据页对应一个`目录项`
     - `目录项` 记录了: **页号** 和 **数据页中用户记录的最小值**
   - 通过维护目录可以得到一个 **在逻辑上连续存储的数据页**

:::info 简单索引方案示例

**1. 下一个数据页中记录的主键值必须大于上一页中所有记录的主键值**

向 index_demo的表中添加数据

```sql
# 插入的数据中主键不是递增的
insert into index_demo values 
(1,4,'u'),(5,3,'y', 3,9,'d')
```

在插入的数据中主键不是递增的,但是数据页中数据递增的，便得到下面的图:

![image-20220605125955396](./image/索引/image-20220605125955396.png)

此时我们再插入一条数据:

```sql
insert into index_demo values  (4,4,'a')
```

我们假设数据页最多只能存储 3 条数据,那么需要在分配一个数据页。当然数据页在物理上不一定是连续的,只需要在逻辑上保持连续即可。

![image-20220605130339882](./image/索引/image-20220605130339882.png)

上图中 页28 的主键最大值是 4，而 页10 的主键最大值为 5，这个不符合要求，所以在插入这条 主键值=4 的记录时,需要伴随着一次`记录移动`,将 主键值=5 的数据移动到 页28 里面,插入的这条主键值=4的记录移动到 页10 里面,得到的模型图如下:

![image-20220605130906729](./image/索引/image-20220605130906729.png)



**2.给所有目录建立一个目录项**

由于数据页的`编号不一定是连续的`,所以在向index_demo 表中插入多条数据的时候,可能得到的结果是这样的:

![image-20220605131755873](./image/索引/image-20220605131755873.png)

因为这些`16kb`的页在物理存储上是不连续的,如果想从多个数据页中根据主键值`快速定位某些记录所在的页`,我们需要给这些数据页做一个**`目录`**，每个页对应一个`目录项`，每个目录项包含一下的内容

- **页的用户记录中最小的主键值，我们用`key` 来表示**
- **页号,我们用`page_no`来表示**

那么上述的几个数据页得到的命令就如图所示:

![image-20220605132249255](./image/索引/image-20220605132249255.png)

以页28 为例,它对应目录项2,包含了该页的 `页号28` 以及`该页中用户记录的最小主键值 5`。

**我们只需要把几个目录项在物理存储器上连续存储(比如:数组)，就可以实现根据主键值快速查找某条记录的功能了**

比如:查找主键值为 20 的记录，具体查找过程分两步:

- 先从目录项中根据 `二分法` 快速确定出主键值为 20 的记录在 目录项3 中(因为 12 < 20 < 209 )，它对应的页是`页9`

- 再根据前边说的在页中查找记录的方式去 `页9` 中定位具体的记录

至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 **`索引`** 。

:::

#### InnoDb索引方案(1)

> 到这里我们认识到,通过建立逻辑连续的索引，以及目录项可以帮助我们快速的定位到查询的数据。但是我们有需要如何存储索引呢?

**目录项纪录的页**

我们把前边使用到的目录项放到数据页中的样子就是这样:

![image-20220605135545068](./image/索引/image-20220605135545068.png)



从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录,这里`目录项记录` 和 `普通的用户记录`的不同点在于:

- `目录项的 record_type = 1`,而 普通的用户记录 record_type = 0

- 目录项记录只有`主键值` 和 `页编号`两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列 ，另外还有InnoDB自己添加的隐藏列

两个记录的**相同点**:

- 两者用的是一样的数据页，都会为主键值生成 `Page Directory(页目录)`, 通过**页目录**可以按照主键值进行查找时可以使用 `二分法` 来加快查询速度

:::info 查询示例

现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步:

1. 先到存储 **目录项记录** 的页，也就是页30中通过 **二分法** 快速定位到对应目录项，因为 *12 < 20 < 209* ，所以定位到对应的记录所在的页就是页9
2. 再到存储用户记录的页9中根据 **二分法** 快速定位到主键值为 20 的用户记录。

:::

#### InnoDb索引方案(2)

> 上述的方案中,将目录项存储到了数据页中,但是当目录项很多以至于一个数据页中存储不了的时候，会分配一个新的数据页来存储目录项

**多个目录项纪录的页**

![image-20220605140247250](./image/索引/image-20220605140247250.png)

从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页:

- 为存储该用户记录而新生成了 **页31** 
- 因为原先存储目录项记录的 页30 的容量已满 (我们前边假设只能存储4条目录项记录)，所以需要一个新的 页32 来存放 页31 对应的目录项

:::info 查询示例

现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例：

1. 确定 **目录项记录页**, 我们现在的存储目录项记录的页有两个: 页30 和 页32 

2. 通过 目录项记录页 确定用户记录真实所在的页

3. 在真实存储用户记录的页中定位到具体的记录

:::

#### InnoDb索引方案(3)

经历上述的推演后,我们对目录页在创建一个数据页，维护目录信息，最后大致推演出一个索引的数据的数据结构，这个数据结构就是 **`B+树`**

- **B+ 树底层节点(叶子节点)存储的是用户记录,其他节点(非叶子节点、内节点)存储的是目录项记录，最顶上的称为根节点**
- **单个数据页中的记录之间采用单链表的形式连接**
- **多个数据页之间使用双链表连接**

![image-20220605162335284](./image/索引/image-20220605162335284.png)



#### B+树

1. 一个 B+ 树可以分为好几层，`规定最下边的那层，也就是存放我们用户记录的那层为 第 0 层`, 之后依次往上加
2. 实际上`B+树一般都不会超过4层`，因为 4 层已经存储到很大的数据量了，并且树层次越低，磁盘 IO 的次数越少
3. 通过主键值去查找某条记录最多只需要做4个页面内的查找(查找3个目录项页和一个用户记录页)，又因为在每个页面内有`Page Directory(页目录)`,所以在页面内也可以通过 `二分法` 实现快速定位记录。

### 常见索引概念

> 索引按照**物理实现方式**，索引可以分为 2 种:
>
> 1. **聚簇(聚集)索引**
> 2. **非聚簇(非聚集)索引**，也加做二级索引或者是辅助索引

#### 聚簇索引

> **聚簇** 表示数据行和相邻的兼职聚簇的存储在一起

- **聚簇索引不是单独的索引类型，而是一种`数据存储方式`**(所有的用户记录都存储在叶子节点)，也就是所谓的 **数据即索引，索引即数据**
  - 比如 InnoDb 的索引中，底层叶子节点存储的是数据，上层存储的是目录项组成的目录(索引)。所以说索引也是数据
  
- **特点**
  
  1. <mark>使用记录主键值的大小进行记录和页的排序</mark>，这包括三个方面的含义
     - **`数据页`内的记录是按照 `主键的大小顺序` 排成一个 `单向链表`**
     - **各个存储 `用户记录的数据页` 也是根据页中`用户记录的主键大小顺序`排成一个`双向链表`**
     - **存放 `目录项记录的页`, 分为不同的层次，在同一层次中的页也是根据页中`目录项记录的主键大小顺序`排成一个 `双向链表`**
  2. <mark>B+树的<strong>叶子节点</strong>存储的是完整的用户记录</mark> 
  - 所谓完整的用户记录，就是指这个记录中存储了所有列的值(包括隐藏列)
  
  :::tip 说明
  
  把具有上面两种特性的的 B+树称之为`聚簇索引`,所有完整的用户记录都会放在这个`聚簇索引`的叶子节点处。
  
  这种聚簇索引不需要再 MySQL 语句中显式的使用`INDEX`语句去创建,`InnoDB`存储引擎会`自动`的为我们创建聚簇索引 =》 添加数据的时候 InnoDb 引擎会适时的维护索引数据，而不是等所有数据插入完成后最后区分数据与索引
  
  :::
  
- **优点**
  - `数据访问更快`,因为聚簇索引将 **索引和数据保存在同一个 B+ 树中**，所以从聚簇索引中获取数据比非 聚簇索引更快
  - 聚簇索引对于主键的 `排序查找` 和 `范围查找` 速度非常快
    - 按照聚簇索引排列顺序，查询一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据,所以节省了大量的磁盘 IO

- **缺点**
  - `插入速度严重依赖于插入顺序`, 按照主键的顺序插入是最快的方式，否则将会出现`页分裂`，严重影响性能
    - 对于InnoDB表，我们一般都会定义一个 **自增主键 ID**

  - `更新主键的代价很高`, 因为将会导致被更新的用户记录移动到其他数据页
    - 对于InnoDB表，我们一般定义 **主键不可更新**

  - `二级索引需要两次索引查找`, 第一次找到主键值，第二次根据主键值找到行数据
- **限制**
  - 对于 MySQL 来说,目前只有**InnoDB**支持聚簇索引,而**MyISAM**不支持聚簇索引
  - 由于数据在物理存储上只能有一种,所以`每个 MySQL 表只能有一个聚簇索引`。一般情况来说就是主键
  - **如果表中没有定义主键,那么 InnoDb 会选择`非空的唯一索引`代替。如果也没有这样的索引，那么 InnoDb 会`隐式的定义一个主键来作为聚簇索引`**
  - **为了充分的利用聚簇索引的特性，所以 InnoDB 表的主键应该尽量的使用`有顺序的ID`,而不建议使用无需的ID(UUID、MD5、HASH、字符串…)作为主键**

#### 非聚簇索引

##### 概述

> `聚簇索引`只能在搜索条件是**`主键值`**的时候才能发挥作用，因为 B+树中的数据是按照主键进行排序的。
>
> 如果需要以其他列作为搜索条件呢？肯定不能按照 B+树从头到尾依次遍历。
>
> 这个时候就需要`二级索引`,我们可以`多建几个 B+树`,不同树中的数据采用不同的`排序规则`，**此时叶子节点`不再存储表中的所有数据`，而是存储 `索引列及主键列的数据`**

:::info 非聚簇索引 B+树示例

比如我们需要对 C2 列进行查询，那我们可以对 C2 建立索引，再建一个 B+树。下图中的 B+树中，叶子节点就是存储了索引列C2，以及主键列 C1

![image-20220611173240139](./image/索引/image-20220611173240139.png)

:::

**非聚簇索引的 B+树与聚簇索引有下面的几个区别**

1. 使用指定的记录列的大小进行记录和页的排序
   - 数据页内的数据按照 `指定列`的大小排序形成`单向链表`
   - 各个`数据页` 也是按照页中记录的`指定列`大小顺序形成的双向链表
2. B+树的叶子节点存储的并不是完整的用户记录,而只是`指定列 + 主键列` 的值
3. 目录项记录的不再是`主键+页号`了,也变成了`指定列 + 页号`

##### 回表

**我们可以考虑执行下面的 sql 语句**

```sql
-- 假设需要执行下面的 SQL 语句
Select * from index_demo where c2=4
```

上面的这个 sql 的在 B+树的执行就是，先根据 c2 的二级索引找到对应的数据,但是 c2索引列查询出来仅包含 c2 的值 和 主键列 c1 的值,而这里是查询所有的字段，包含 c3， 所以再拿主键列 c1 的值去聚簇索引中查询，这时候就可以查询到完整的用户记录，并将所有的数据查询并返回。这个过程就被称为**`回表`**

因为这种按照`非主键列`建立的 B+树需要一次回表操作才可以定位到完整的用户记录,所以这种 B+树也叫做`二级索引、辅助索引`

<mark>注意：<strong>非聚簇索引的存在不会影响聚簇索引中的结构,所以一张表可以有多个 非聚簇索引</strong></mark>

:::caution 为什么需要回表?

**为什么还需要一次回表呢?不能干脆将完整的用户记录放在非聚簇索引的叶子节点中吗?**

如果将完整的用户记录放在叶子节点中的话,那么就太`占用地方`了。相当于每次建立一颗 B+树,都需要将所有的用户记录都拷贝一遍,有点太浪费存储空间了。

:::

#### 联合索引

我们也可以同时将多个列的大小作为排序规则,也就是**`同时为多个列建立索引`** ,比如想让 B+树按照 C2、C3 的大小进行排序，有两层含义

1. **先把各个记录和页按照 C2 列进行排序**
2. **在记录的 C2 列相同的时候,采用 C3 列进行排序**

为 C2 和 C3 列建立的索引示意图如下:

![image-20220612152037402](./image/索引/image-20220612152037402.png)

注意:**以 C2 和 C3 列的大小为排序规则建立的 B+树被称为 `联合索引`**, <mark><strong>它的本质上也是二级索引</strong></mark>。查询的时候也会将查询条件与 C2 和 C3 同时比较,并找到对应的叶子节点

###  B+树注意点(InnoDB)

#### 1. 根页面位置不变

前面在推演 B+树的时候,**先将存储用户记录的叶子节点画出来,再接着画目录项记录的内节点**,实际上 B+树不是这样形成的，而是下面的过程

1. 每为一个表创建 B+树索引(**聚簇索引是不是人为创建的,默认就有**)的时候,都会为这个索引创建一个**`根节点`**页面。一开始表中没有数据的时候,每个 B+树中的`根节点`中没有用户记录,也没有目录项
2. 之后向表中插入数据的时候,先把用户记录存储在`根节点`中 (开始的时候只有*叶子节点*，然后数据都存放在根节点中)
3. 当`根节点中的可用空间用完时`继续插入数据,此时会将**`根节点中的所有记录复制得到一个新分配的页中，而不是直接新分配一个新的数据页`**，比如页 A ，然后对这个新页(页 A)进行`页分裂`的操作，得到一个新页,比如页 B。这时新插入的记录根据索引列值的大小排序，并被分配到页 A 或者 页 B 中,而`根节点` 便**升级**为存储目录项记录的页，**同时更新根节点中的记录值，从用户记录变为目录项记录**
   - **即 B+树的节点是`自上而下`逐渐生成的**

:::tip 说明

1. 开始的时候只有一个**根节点**存储用户记录,当**根节点**中存储的数据满了之后,会复制一份根节点作为**叶子节点存储数据**。

2. 然后根节点去维护叶子节点的**目录项信息**，之后叶子节点数据满了之后,进行**页分裂**的操作

3. 当根节点维护的**目录项**记录满了之后,再次复制根节点得到第二层维护**目录项**的内节点,根节点转而维护内节点信息

所以一个 B+树索引的根节点从生成开始,就不会再移动。这样在对某个表建立索引之后，那么根节点的页号就回被记录存储。然后 InnoDb 需要用到这个索引时，就可以通过这个页号找到并使用对应的索引

:::

#### 2.目录项记录的唯一性

我们知道了 B+树索引的内节点中目录项记录的内容是`索引列 + 页号` 的形式，但其实对二级索引来说并不严谨(二级索引可以有指定非唯一的字段列)

| C1   | C2   | C3   |
| ---- | ---- | ---- |
| 1    | 1    | ‘u’  |
| 3    | 1    | ‘d’  |
| 5    | 1    | ‘y’  |
| 7    | 1    | ‘a’  |



![image-20220615201501848](./image/索引/image-20220615201501848.png)

问题: **我们需要新插入一行数据(9,1,c)的数据,那么问题来了:在添加数据的时候,由于索引列的数据都相同，而 页3 中只存储了索引列数据与页号,所以不知道数据应该添加到 页4 还是 页5**

为了保证新的数据可以找到并插入到所在的数据页,需要保证**`B+树的同一层内节点的目录项记录除去页号以外是唯一的`**,所以二级索引的内节点的目录项记录的内容有三部分组成

1. `索引列的值`
2. `主键的值`
3. `页号`

通过将**主键值**页添加到二级索引的内节点的目录项记录中,可以保证 B+树内节点中**各个目录项记录的唯一性**, 实际上二级索引的 B+树结构图大致如下:

![image-20220615203233735](./image/索引/image-20220615203233735.png)

####  3.一个页面最少存储2条记录

一个 B+树只需要很少的层级就可以轻松存储数亿条记录,并且查询速度相当不错。本质上因为 B+树这种**`多层级目录`**的设计。每经过一个目录就可以过滤掉很多无效的目录,直到找到最终的数据。**一般来说一个数据页最少也会有两层**



## MyISAM 索引方案

B树索引适用存储引擎如表所示(都支持 B 树索引,但是它们的实现原理是不同的):

| 索引/存储引擎 | MYISAM             | InooDB             | Memory             |
| ------------- | ------------------ | ------------------ | ------------------ |
| B+树索引      | :white_check_mark: | :white_check_mark: | :white_check_mark: |

- **`InnoDb、MyISAM 默认使用 B+树索引,Memroy默认使用 Hash 索引`**

- **MyISAM使用 B+树索引,叶子节点的 data 域存放的是`数据记录的地址`**

### MyISAM 索引原理

在 InnoDB 中**索引即数据**,也就是聚簇索引的 B+树的叶子节点存储了完整的用户记录,而 MyISAM 索引方案是将*`数据和索引分开存储`*：

1. 将表中的记录`按照记录的插入顺序`单独存储在**`数据文件(MYD)`**中。在数据文件中不会去划分若干个数据页,而是一股脑的将数据存储在文件中。由于在插入数据的时候`没有按照主键进行排序`,所以也无法通过二分法查询数据
2. 使用 MyISAM 存储引擎会将索引信息存储在**`索引文件(MYI)`**中。MyISAM默认会为表的主键创建一个索引,**不过索引的叶子节点存储的不是完整的用户记录**,而是**`主键值 + 数据记录的地址`**

