---
id: 锁
title: 锁机制
---
> 事务的隔离性由`锁`来实现

## 概述

在数据库中,除传统的计算资源(如CPU、RAM、I/O等)的争用以外,`数据也是一种供许多用户共享的资源`。**为保证数据的一致性，需要对并发操作进行控制**, 因此产生了`锁`了, 同时`锁机制` 也为实现 MySQL 的各个隔离级别提供了保证。 

`锁冲突` 也是影响数据库`并发访问性能`的一个重要因素。所以锁对数据库而言显得尤其重要、复杂

## 并发事务访问相同记录

**MySQL 中,并发事务访问相同记录的情况大致可以划分为3种:**

1. `读-读`

2. `写-写`

3. `读-写、写-读`

### 读-读
- `并发事务相继读取相同的记录`
- 读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。

### 写-写

`并发事务相继对相同的记录做出改动`, 在这种情况下会发生`脏写` 的问题,任何一种隔离级别都不允许这种问题的发生。所以在**多个未提交事务相继对一条记录做改动时,需要让它们 `排队执行`** ，这个**排队**的过程其实是通过 `锁` 来实现的


锁其实是一个`内存中的结构`, 在事务执行前本来是没有锁的, 也就是说**一开始是没有锁结构 和记录进行关联的**, 如图所示:

![image-20220821151142864](./image/锁/image-20220821151142864.png)

<br/>

**当一个事务想对这条记录做改动时,首先会看看内存中有没有与这条记录关联的 `锁结构` **, 当没有的时候就会在内存中**生成一个锁结构 与之关联**。比如，事务 T1 要对这条记录做改动, 就需要生成一个锁结构与之关联

1. `trx信息` : 表示锁结构和哪个事务关联
2. `is_waiting` ： 表示当前事务是否在等待

当事务 T1 改动这条记录的时候,就会生成一个锁结构与该记录进行关联。由于之前没有别的事务为这个记录加锁,所以 `is_waiting = false` ,我们把这个称之为`获取锁成功 (加锁成功)`,然后就可以继续操作了

![image-20220821151333266](./image/锁/image-20220821151333266.png)

<br/>

在事务 T1 提交之前,另外一个事务 T2 也想对该记录进行改动, 那么 T2 先去看有没有锁结构与这条记录关联。发现 T1 已经加锁了,那么 T2 此时`也会生成一个锁结构与该记录关联`, 和 T1 不同的是,这个锁结构的 `is_waiting = true`, **表示需要等待**。我们称之为`获取锁失败(加锁失败)`

![image-20220821154603839](./image/锁/image-20220821154603839.png)

<br/>

事务 T1 提交之后,会`释放它生成的锁结构`, 然后查看这个记录是否还有其他锁结构与之关联。结果发现 T2 还在等待获取锁,所以就把事务 T2 锁结构的 is_waiting 修改为 true, 然后将事务 T2 对应的线程唤醒,那么 T2 此时就可以获取到锁了

![image-20220821154956926](./image/锁/image-20220821154956926.png)

:::tip 小结一下

1. `获取锁成功(加锁成功)`
   - 在内存中生成了对应的锁结构,而且锁结构的 `is_wating = false`, 也就是**事务可以继续执行**
   - 当然不是所有的加锁都会生成对应的锁结构, 有时候会有`加隐式锁`的情况,它不会生成对应的锁结构, 但是仍可以起到保护记录的作用
2. `获取锁失败(加锁失败)`
   - 在内存中生成了锁结构, 但是锁结构的 `is_waiting = true`,也就是**事务需要等待,不可以继续执行**
3. `不加锁`
   - 不需要在内存中生成对应的锁结构,可以直接执行操作,**不包括隐式锁的情况**

:::

### 读-写

**一个事务进行读操作, 另外的事务进行写操作**, 这个时候会出现脏读、不可重复读、幻读的现象。不同数据库厂商对 SQL 标准的支持并不同, 比如 MySQL 的默认隔离级别是`Repeatable Read`

### 并发问题解决

怎么解决 脏读 、 不可重复读 、 幻读 这些问题呢?其实有两种可选的解决方案:

1. 读操作利用 `多版本并发控制 (MVCC)`, 写操作进行 `加锁` 

   - MVCC 就是生成一个 `ReadView`(可以简单的理解为是一个**历史快照**),  通过 ReadView 找到符合条件的记录版本(历史版本由 undo 日志构建)
   - 查询语句只能`读`到在生成 ReadView 之前`已提交事务所做的更改`, 在生成 ReadView 之前**未提交的事务或者之后开启的事务所做的更改是看不到的**
   - `写操作` 肯定针对的是`最新版本的记录`, 读记录的历史版本和最新版本不冲突,所以 采用 MVCC 时, **读写操作不冲突**

   :::info 说明

   普通的查询语句在 `READ COMMITTED` 和 `REPEATABLE READ` 隔离级别下会**使用 MVCC 读取记录**

   - 在 *read committed* 隔离级别下, 一个**事务在执行过程中**每次执行 *select* 操作时都会生成*Read View*, Read View 本身就保证了`事务不可以读取到未提交的事务所做的更改`, 也就是避免得了脏读的问题
   
   - 在 *repeatable read* 隔离级别下,一个**事务在执行过程中**只有`第一次执行 select` 才会生成一个 ReadView, 之后的 select 操作都`复用` 这个 ReadView, 也就是避免得了不可重复读、幻读的问题

   :::

2. **读、写操作**都采用`加锁` 的方式

   - 如果业务中不允许读取记录的旧版本,而是每次都会读取记录的最新版本。
   - 比如银行存款中,我们需要先把账户的余额查询出来,然后将其加上本次存储的金额,最后再写入到数据库中。从查询余额开始就开启事务了,此时不想让其他事务进行写操作,只有当金额存入完毕,即事务提交完成后,其他事务才允许访问账户余额,那么**在进行读操作的时候也需要加锁**

   :::info 说明
    - 脏读是因为当前事务读取了另一个事务没有提交的记录,如果另一个事务在写记录的时候对这个记录加锁,那么当前事务就无法在读取记录的时候获取到锁了

    - 不可重复读是因为当前事务先读取一条记录,另一个事务对这条记录进行了修改并且提交了。如果当前事务读取记录的时候先对该记录加锁,那么另外一个事务就无法修改该记录了
   
    - 幻读是因为某个事务读取了符合某些搜索条件的记录,之后其他事务又插入了符合相同搜索条件的记录,导致事务按相同的查询条件再次查询的时候,多了几条记录。采用加锁的方式避免幻读有点麻烦,因为当前事务第一次读取记录的时候,你并不知道是否有其他事务会插入新的记录,即使有也不知道什么时候插入,**也就是说不知道什么时候加锁,也不知道给谁加锁**
   :::

<br/>

**我们发现:**
- 使用 `MVCC` 方式的话, `读写`操作并不冲突,性能更好
- 使用 `加锁` 方式的话,`读写`操作就需要依次排队,影响性能

一般的情况下,我们更愿意使用 `MVCC` 的方式来解决并发读写的问题,但是有时候基于特殊的业务场景,就需要采用`加锁`的方式处理并发读写的问题

## 锁的不同角度分类

![image-20220821230720208](./image/锁/image-20220821230720208.png)

### 数据操作类型划分

