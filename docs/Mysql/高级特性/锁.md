---
id: 锁
title: 锁机制
---
> 事务的隔离性由`锁`来实现

## 概述

在数据库中,除传统的计算资源(如CPU、RAM、I/O等)的争用以外,`数据也是一种供许多用户共享的资源`。**为保证数据的一致性，需要对并发操作进行控制**, 因此产生了`锁`了, 同时`锁机制` 也为实现 MySQL 的各个隔离级别提供了保证。 

`锁冲突` 也是影响数据库`并发访问性能`的一个重要因素。所以锁对数据库而言显得尤其重要、复杂

## 并发事务访问相同记录

**MySQL 中,并发事务访问相同记录的情况大致可以划分为3种:**

1. `读-读`

2. `写-写`

3. `读-写、写-读`

### 读-读
- `并发事务相继读取相同的记录`
- 读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。

### 写-写

> `并发事务相继对相同的记录做出改动`, 在这种情况下会发生`脏写` 的问题,任何一种隔离级别都不允许这种问题的发生。所以在**多个未提交事务相继对一条记录做改动时,需要让它们 `排队执行`** ，这个排队的过程其实是通过 `锁` 来实现的


锁其实是一个`内存中的结构`, 在事务执行前本来是没有锁的, 也就是说**一开始是没有锁结构 和记录进行关联的**, 如图所示:

![image-20220821151142864](./image/锁/image-20220821151142864.png)

<br/>

**当一个事务想对这条记录做改动时,首先会看看内存中有没有与这条记录关联的 `锁结构` **, 当没有的时候就会在内存中**生成一个锁结构 与之关联**。比如，事务 T1 要对这条记录做改动, 就需要生成一个锁结构与之关联

1. `trx信息` : 表示锁结构和哪个事务关联
2. `is_waiting` ： 表示当前事务是否在等待

当事务 T1 改动这条记录的时候,就会生成一个锁结构与该记录进行关联。由于之前没有别的事务为这个记录加锁,所以 `is_waiting = false` ,我们把这个称之为`获取锁成功 (加锁成功)`,然后就可以继续操作了

![image-20220821151333266](./image/锁/image-20220821151333266.png)

<br/>

在事务 T1 提交之前,另外一个事务 T2 也想对该记录进行改动, 那么 T2 先去看有没有锁结构与这条记录关联。发现 T1 已经加锁了,那么 T2 此时`也会生成一个锁结构与该记录关联`, 和 T1 不同的是,这个锁结构的 `is_waiting = true`, **表示需要等待**。我们称之为`获取锁失败(加锁失败)`

![image-20220821154603839](./image/锁/image-20220821154603839.png)

<br/>

事务 T1 提交之后,会`释放它生成的锁结构`, 然后查看这个记录是否还有其他锁结构与之关联。结果发现 T2 还在等待获取锁,所以就把事务 T2 锁结构的 is_waiting 修改为 true, 然后将事务 T2 对应的线程唤醒,那么 T2 此时就可以获取到锁了

![image-20220821154956926](./image/锁/image-20220821154956926.png)

:::tip 小结一下

1. `获取锁成功(加锁成功)`
   - 在内存中生成了对应的锁结构,而且锁结构的 `is_wating = false`, 也就是**事务可以继续执行**
   - 当然不是所有的加锁都会生成对应的锁结构, 有时候会有`加隐式锁`的情况,它不会生成对应的锁结构, 但是仍可以起到保护记录的作用
2. `获取锁失败(加锁失败)`
   - 在内存中生成了锁结构, 但是锁结构的 `is_waiting = true`,也就是**事务需要等待,不可以继续执行**
3. `不加锁`
   - 不需要在内存中生成对应的锁结构,可以直接执行操作,**不包括隐式锁的情况**

:::

### 读-写

>  在事务基础中, 在读-写或者写-读 的情况下, 会出现脏读、不可重复读、幻读的现象