---
id: Undo日志
title: Undo日志
---

> redo 日志记录的事务的行为,可以很好的**对页进行“重做”**, 但是事务除了能提交,还可以回滚,这个时候就需要`undo`
>
> 在对数据库进行修改的时候,除了会产生 redo 日志,InnoDB还会生成undo 日志。
>
> redo 日志是事务持久性的保证,undo 日志则是事务原子性的保证,**在事务中 `更新数据` 的 `前置操作 `其实是要先写入一个 undo log **

## 理解 undo 日志

事务需要保证 `原子性` ，也就是事务中的操作要么全部完成,要么什么也不做。但有时候事务执行到一半 会出现一些情况，比如:

1. 事务执行过程中可能遇到各种错误，比如 服务器本身的错误、操作系统错误, 甚至是突然断电导致的错误
2. 程序员可以在事务执行过程中手动输入 **ROLLBACK** 语句结束当前事务的执行

以上情况出现,我们需要**把数据改回原先的样子**, 这个过程称之为`回滚` , 这样就可以造成一个假象:这个事务看起来什么都没做，所以符合**原子性要求**

每当我们要对一条记录做改动时(指`INSERT`、`DELETE`、`UPDATE`)，都需要留一手, 把回滚时所需的东西都给记下来:

1. **插入一条记录时,至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了**
2. **删除了一条记录,至少要把这条记录中的内容都记下来,这样之后回滚时再把由这些内容组成的记录插入到表中就好了**
3. **修改了一条记录,至少要把修改这条记录前的旧值都记录下来,这样之后回滚时再把这条记录更新为旧值就好了**

这些**为了回滚而记录的内容称为撤销日志(undo日志)**,<mark>需要注意的一点是, 由于查询操作 <strong>SELECT</strong> 并不会修改任何用户记录, 所以在查询操作执行时, 并不需要记录相应的<strong>Undo 日志</strong></mark>

## undo日志的作用

Undo 日志有下面两个作用

1. `回滚数据`
2. `MVCC`

**1. 回滚数据**

开发者对 undo 可能有`误解`: **undo 无法将数据库物理地址恢复到执行语句或者事务之前的样子**, 但事实上`undo 日志是逻辑日志`,因此只是**将数据库逻辑的恢复到原来的样子, 所有的修改都被逻辑的取消了,`但是数据结构和页本身在回滚之后可能并不相同`**

因为在多用户并发系统中,会有成百上千的并发事务,事务 A 修改了页中的某几条记录,同时事务 B 也对这个数据页进行修改,那么回滚的时候**就不能直接将页恢复到事务开始的样子,这样会影响到其他的事务**

**2. MVCC**

除了回滚之外,undo 日志另外一个作用就是`MVCC`。**当用户读取一行记录的时候,如果该记录已经被其他事务占用,当前事务可以通过读取 undo 日志获取之前的信息,以实现** `非锁定读取`

## undo 存储管理

### 回滚段与 undo 页

InnoDB存储引擎对 undo页 的管理同样采用`段(segment)`的方式, 也就是`回滚段(Rollback Segment)`, 每个回滚段中有`1024 个 undo log segment`, 然后**在 undo log segment 中进行 undo 页的申请**

1. 在 InnoDB `1.1版本 ` 之前 (不包括1.1版本)，`只有一个回滚段`, 因此支持同时在线的事 限制为 `1024` 。虽然对绝大多数的应用来说都已经够用,但是也还是个瓶颈
2. 从`1.1版本`开始InnoDB支持`最大 128个回滚段` ，故其支持同时在线的事务限制提高到 了 `128*1024` 

虽然 InnoDB1.1版本支持了 128 个回滚段,但是**这些回滚段都存储在`共享表空间`**, 从InnoDB`1.2 版本`开始,可以通过下面的参数做出进一步的设置(当然很少修改):

1. `innodb_undo_directory`
   - **用于设置回滚段文件所在的路径**
     - 这个意味着回滚段可以放在共享表空间以外的位置,即**可以设置为独立表空间**
   - **默认值是`./` ,表示当前 InnoDB 存储引擎的目录**
2. `innodb_undo_logs`
   - **设置回滚段的个数,默认值是 128**
   - <mark>用于代替之前版本的 <strong>innodb_rollback_segments</strong></mark> 
3. `innodb_undo_tablespaces`
   - **设置构成回滚段文件的数量**
   - **设置该参数后会在 innodb_undo_directory 下看到以 undo 开头的文件,这些就是回滚段文件**

<mark>需要注意的是: <strong>事务在 undo log segment 分配页并且写入 undo log 的过程中同样需要写入 redo 日志</strong></mark> 

### undo页的重用

> 当我们开启一个事务需要写入 undo 日志的时候,就需要先去 **undo log segment** 中申请一个空闲的 undo 页,然后将 undo 日志写入其中, MySQL 一个页默认大小为 16kb

当事务提交时,InnoDB 存储引擎会做下面两件事:

1. 将 undo 日志放入列表中,以便之后的`purge`操作
2. 判断 undo 日志所在的页是否可以重用,如果可以就分配给下个事务使用

**事务提交之后`不会立即删除` undo 日志以及 undo 日志所在的页**,因为可能还有其他事务需要通过该 undo 页获取之前的版本数据。所以事务提交后将 undo 日志放在一个`链表`中, 是否可以删除undo 日志需要由`Purge 线程`来判断

但如果为每一个事务分配一个单独的 undo 页又十分浪费存储空间(除非是长事务), **因为事务提交的时候, 可能不会立即释放页**。假设某个应用的 TPS 是 1000,那么如果为每个事务,1 分钟就需要60000 个页,大约需要 1G 的存储空间

所以 undo 页就被设计成了`可重用的`,当事务提交之后: **首先将 undo 日志放入链表中,然后判断 undo 页的使用空间是否小于 `3/4`, 如果小于 3/4,那么就表示该 undo 页可以被重用,之后新的 undo 日志就记录在当前 undo 日志后面**

**由于存放 undo 日志的列表示意记录的形式组织的,而 undo 页中可能存放着不同事务的 undo 日志, 因此Purge 线程进行`清理的时候无法顺序执行`, 而是要离散的操作, 是一个缓慢的过程 **

:::tip 查看链表中 undo 日志的数量

**通过 ` show engine innodb status\G;`查看存储引擎的状态**,其中`History list length` 就是 undo 日志的数量, purge 操作会减少该值

![image-20220814225618130](./image/Undo日志/image-20220814225618130.png)

:::

### 回滚段与事务

