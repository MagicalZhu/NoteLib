---
id: MySQL逻辑架构
title: MySQL逻辑架构
---

## 逻辑架构

MySQL 服务器进程对客户端进程做了什么处理,才能得到最终的结果呢?对于查询请求有如下的过程:

![image-20220504094022999](./image/MySQL逻辑架构/image-20220504094022999.png)



### MySQL 逻辑架构

MySQL 大致分为 4 层架构:

1. `连接层`
2. `服务层`
3. `引擎层`
4. `存储层`

![image-20220503224440487](./image/MySQL逻辑架构/image-20220503224440487.png)



#### 连接层(Connectors)

> MySQL 服务器提供给外界客户端连接的接口,不同客户端可以使用自己的 API 连接 MySQL,包括但不限于:
>
> 1. 建立连接
> 2. 认证授权
> 3. 维持和管理连接
> 4. …

- 客户端连接层 Connectors，位于MySQL体系架构的最上层，提供与MySQL服务器建立连接的能力,主要包括一些客户端和连接服务。其中包含`本地服务的 Socket 通信` 和 大多数`基于 C/S 实现的 TCP/IP 通信`。通过 Connectors 主要完成一些`连接处理`、`授权认证`等操作

- 客户端在访问 MySQL 服务器之前,首先就是需要 *建立 TCP 连接*，然后进过 TCP 的 3 次握手建立成功之后，MySQL 服务器会对 TCP 传输过来的账号密码做身份认证、权限获取。
  - 用户名或密码不对，会收到一个 *Access denied for user* 错误，客户端程序结束执行
  - 用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断都将依赖于此时读到的权限

##### MySQL 驱动

MySQL 是一个网络程序,和 <font color='blue'><em>smtp、http、dns</em></font> 等协议一样，MySQL 在 TCP 上定义了自己的 **MySQL协议**。我们需要与数据库建立`TCP`连接,然后在这个 TCP 连接上按照自定义的 **MySQL协议**进行交互。

最为简单的方式就是通过调用 **MySQL 驱动**，即 MySQL 驱动就是将上述的操作封装为 SDK 给开发者调用,所以 MySQL 驱动的本质上也还是通过 `TCP` 与 MySQL 服务器连接，并且基于 **MySQL协议**与 MySQL服务器进行交互

##### 连接池

> 内部包括了: `TCP连接池、线程池`
>
> 一次 SQL 请求就会建立一个TCP连接，而事实上一个客户端会想 MySQL 服务器发起多次 SQL 请求, 每次连接都需要经历`新建连接->销毁连接`,这个开销非常大,会造成不必要的浪费。所以**需要提供一些固定数量的用来连接的线程**
>
> 通过**TCP连接池**可以`维护一定数量的连接数`，在需要进行TCP连接的时候就去TCP连接池中获取。并且也不必关心TCP连接是如何创建和销毁的，这些由TCP连接池内部去处理。
>
> 通过限制 TCP 连接池最大连接数、使用`长连接模式` 复用 TCP 连接，从而减少频繁创建 TCP 连接导致的资源消耗、性能下降

TCP连接池主要负责`存储和管理客户端与数据库的连接信息，连接池里的一个线程负责管理一个客户端到数据库的连接信息`

TCP连接池会监听对 MySQL 服务器的各种请求，接收TCP 连接请求，转发所有连接请求到线程管理模块。每一个连接上 MySQL 服务器的客户端请求都会被分配（或创建）一个**连接线程**为其单独服务。而**连接线程**的主要工作就是负责 MySQL 服务器与客户端的通信,接受客户端的命令请求，传递 服务端的结果信息等。

<font color='red'>所以除了 TCP 连接池之外，MySQL 内部还有一个线程池则负责管理维护这些连接线程</font>。包括线程的创建、线程的 cache 等。每一个连接都从线程池中获取线程，省去了创建和销毁线程的开销。

#### SQL 服务层

<mark>第二层架构主要完成大多数的核心服务功能,比如SQL 接口、缓存的查询、SQL 分析和优化、部分内置函数的执行。</mark>

在这一层 MySQL 服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化。比如确定查询表的顺序、是否利用索引等，最后生成相应的执行操作。如果是执行查询语句,MySQL 服务器还会查询内部的缓存。

##### SQL 接口(SQL Interface)

<mark>用于接收用户的SQL命令，并且返回用户需要查询的结果</mark>，比如SELECT ... FROM就是调用 SQL 接口

MySQL 支持 DML(数据操作语言)、DDL(数据定义语言)、存储过程、视图、触发器、自定义函数等多种SQL语言接口。

##### 查询缓存(Cache&Buffer)

> 查询缓存主要是将客户端 query请求的 SELECT 查询语句返回的结果缓存到内存中, 并且与该query请求的 hash值做一个对应。当然,query 请求获取的数据发生变更后，MySQL 会让这个 query 对应的缓存生效。
>
> 在频繁读写的系统中，查询缓存可以显著的提高查询性能,但是由于查询很依赖于内存，所以对内存的消耗很高

- MySQL 内部维持着一些 Cache 和 Buffer,比如 Query Cache用来缓存一个 SELECT 语句的执行结果。如果可以在 Query Cache 中找到对应的查询结果,那么就不必要进行下面的 查询解析、优化、执行的整个过程了，而是直接将结果返回给客户端

- 这个缓存机制是由一系列小缓存组成的。比如`表缓存`、`记录缓存`、`key缓存`、`权限缓存`等 
- 这个查询缓存基于MySQL 服务器内存, 所以可以在不同客户端之间共享 
- <mark>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除</mark>

##### 解析器(Parser)

> SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由 Lex 和 YACC 实现的一个很长的脚本

- <mark>用于对 SQL 语句进行<strong>词法分析、语法分析、解析树、预处理器、新解析树</strong></mark>

  - `词法分析` : 将整个语句拆分成一个个字段
  - `语法分析` : 将词法分析拆分出的字段，按照 MySQL 定义的语法规则，生成对应的数据结构解析树
  - `解析树` 
  - `预处理器` : 进一步的检查解析树是否合法，比如就是去查看表是否存在/列是否存在
  - `新解析树` : 通过预处理器核对之后生成的新的解析树，新解析树可能和旧解析树结构一致

- 解析器会将SQL 语句分解成数据结构,并且将这个结构传递到后续步骤中,以后SQL语句的传递和处理就是基于这个结构的。但如果在解析的过程中发生错误, 那么说明**这个 SQL 语句是不合理的**, SQL 语句将不会再执行下去

- 当 SQL 命令传递到 Parser 的时候会被解析器验证并解析,并为其创建一个`语法树`, 会`验证该客户端是否具有执行该查询的权限`。创建完语法树之后，MySQL 服务器会对 SQL 查询进行语法上的优化,进行`查询重写`

##### 查询优化器(Optimizer)

- SQL 语句在语法解析后、查询之前会通过查询优化器确定一个`SQL 语句执行路径`, 生成一个`执行计划`。 

- `执行计划`表明了应该`使用哪些索引`进行查询(**全表检索还是索引检索**)、表之间的连接顺序如何。 最后会按照执行计划中的步骤调用存储引擎提供的方法执行真正的查询, 并最终返回查询结果
- MySQL 根据自己的优化规则，将查询的`IO成本`和`CPU成本`消耗降到最低
  - **IO 成本** :  从磁盘把数据加载到内存的成本
  - **CPU成本** : 数据在内存中查找和排序等 CPU 操作的成本



:::info 查询策略

查询优化器使用 `选取 - 投影 - 连接` 策略进行查询

```sql
SELECT id,name FROM student WHERE gender = '女';
```

1. Select 查询语句首先根据 WHERE 进行`选取`,而不是将表全部查询出来再根据 gender过滤

2. 然后 SELECT 查询根据 id 与 name 进行属性的`投影`,而不是将属性全部取出以后再进行过滤
3. 最后将上述的两个查询条件 `连接` 起来得到最终的查询结果

:::

:::tip 总结

1. 客户端发生请求给 MySQL TCP连接池后，MySQLTCP连接池处理请求、完成身份权限验证

2. 创建线程获取请求中的 SQL 语句，将语句交给 SQL 接口

3. 如果是查询语句先从查询缓存中查找是否有命中，有就直接返回结果集，没有就走解析器

4. 解析器将 SQL 语句按规则解析成各个字段，并生成对应的数据结构解析树，然后交给查询优化器，找到最优查找路径，例如选择哪个索引成本最低
5. 最后交给执行器去调用存储引擎对应的结构

:::

#### 引擎层

<mark>用于负责 <strong>MySQL 中数据的存储与提取、对物理服务器级别维护的底层数据执行操作</strong>，服务器通过API与存储引擎进行通信</mark>。不同的存储具有不同的功能，需要按照实际需求选择

MySQL 引擎层的架构模式是: `插件式存储引擎层(Storage Engines)`, 支持 `InnoDB、MyISAM、Memory等多个存储引擎`

MySQL 8.0.25默认支持的存储引擎如下:

![image-20220504141125680](./image/MySQL逻辑架构/image-20220504141125680.png)

#### 存储层

所有的数据，数据库、表的定义、表的每一行的内容、索引等, 都是存在 `文件系统` 上，以 文件 的方式存 在的，并完成与存储引擎的交互

有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用 DAS、NAS、SAN等各种存储系统



#### 小结

MySQL逻辑架构可以简化为三层结构:

1. **连接层** : 客户端和服务器端建立连接，客户端发送 SQL 至服务器端;
2. **SQL 层(服务层)** : 对 SQL 语句进行查询处理;与数据库文件的存储方式无关;

3. **存储引擎层** :与数据库文件打交道，负责数据的存储和读取。

![image-20220504142403093](./image/MySQL逻辑架构/image-20220504142403093.png)

## SQL 执行流程

### MySQL 执行流程

SQL 语句在 MySQL 中的流程是: `SQL语句[->查询缓存]->解析器->优化器->执行器`

![image-20220504153219266](./image/MySQL逻辑架构/image-20220504153219266.png)

**SQL 执行流程**

![image-20220504143246313](./image/MySQL逻辑架构/image-20220504143246313.png)

#### 查询缓存

> MySQL 服务器如果在查询缓存中发现了某个 SQL 查询语句，就会直接将结果返回给客户端;如果没有,就进入到解析器阶段。 
>
> 需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。

在 MySQL5.7中，可以通过设置 `query_cache_type=0` 关闭查询缓存。

:::caution 为什么查询缓存是一个鸡肋功能？

1. 查询缓存是提前把查询结果缓存起来，与 query 请求的 SQL 语句对应起来, 这样下次不需要执行就可以直接拿到结果。但是这个只有在相同查询操作才能命中缓存。
2. 首先,如果SQL 查询语句中包含一些系统函数，可能会导致查询结果出错。比如函数`Now()`,虽然 query查询语句是一样的，意味着可以在查询缓存命中，但是实际上每次执行 Now() 返回的结果是不一样的, 导致返回的结果是错误的。
3. 其次，查询缓存的 是 k-v 键值对形式的,k 就是查询的 sql 语句，但是同一个SQL 语句的大小写不一致，也会导致无法命中查询缓存
3. 最后,缓存一定有`失效`的时候, 查询缓存的失效需要 MySQL 对库中每张表的每个数据进行监控。如果每个数据被缓存在查询缓存中，就要让该缓存失效。对于写操作频繁的系统来说,会对 MySQL 服务器造成更大的压力,但是在效果上却意义不大。

:::

#### 解析器

> 在解析器中对 SQL 语句进行语法分析、语义分析

1. 解析器首先会做**词法分析**，将整个语句拆分为一个个字段
2. 语法分析器(比如 BiSon)会根据语法规则，客户端请求的 SQL 语句是否满足 MySQL 语法，如果符合会得到一个语法树

:::info 语法树示例

```sql
Select username,ismale from userinfo where 1=1 and age > 20 and level > 5
```

![image-20220504152122690](./image/MySQL逻辑架构/image-20220504152122690.png)

:::

####  优化器

> 在优化器中会确定 SQL 语句的执行路径，比如是根据 全表检索 ，还是根据 索引检索 等

在查询优化器中，可以分为 `逻辑查询` 优化阶段和 `物理查询` 优化阶段

####  执行器

> 从查询缓存-> 优化器的过程中,还没有去读写真实的表，仅仅只是得到了一个执行计划。在执行器阶段就会去读写表

- 在执行之前会判断该用户`是否具备权限`。如果没有的话，就会返回权限错误; 如果有，就执行 SQL 查询并返回结果
  - 注意: 在 MySQL 8.0 以下的版本中，如果开启了查询缓存,此时会缓存查询结果

### MySQL8 SQL 执行计划

#### 开启 profiling

- 确认`profiling` 是否开启, **profiling = 0 | OFF**  表示关闭

  ```sql
  select @@profiling;
  show variables like 'profiling';
  ```

- 开启 `profiling` 

  ```sql
  # 开启 Session 级别的 profiling
  set  profiling = 1
  ```

  ![image-20220504160426286](./image/MySQL逻辑架构/image-20220504160426286.png)

#### 查看 profiles

- <mark>查看当前会话产生的所有 profiles</mark>

- 基本语法

  ```sql
  show profiles;
  ```

  ![image-20220504161308619](./image/MySQL逻辑架构/image-20220504161308619.png)

####  **查看**profile

- 基本语法

  ```sql
  show profile [type [, type] ... ]
  [FOR QUERY query_id]      
  [LIMIT row_count [OFFSET offset]]
  ```

- 命令参数说明

  - `type`
    - `ALL`  : 显示所有的开销信息
    - `BLOCK IO ` : 显示块IO相关开销
    - `CONTEXT SWITCHES` : 上下文切换相关开销
    - `CPU` : 显示CPU相关开销信息
    - `IPC` : 显示发送和接收相关开销信息
    - `MEMORY` ： 显示内存相关开销信息
    - `PAGE FAULTS ` : 显示页面错误相关开销信息
    - `SOURCE` : 显示和Source_function，Source_file，Source_line相关的开销信息
    - `SWAPS` : 显示交换次数相关开销的信息
  - `query_id`
    - 如果不指定，只是显示最近执行的语句，如果指定会显示语句的 profile
    - 可以通过 `show profiles;` 得到 query_id

  :::info 使用 show profile

  ![image-20220504162210233](./image/MySQL逻辑架构/image-20220504162210233.png)

  :::

### MySQL5.7 执行原理

- 测试步骤
  - **开启查询缓存**
    - 在配置文件中设置 `query_cache_type=1` 开启查询缓存
  - **重启 MySQL 服务**
  - **开启profiling**
  - 执行两次 SQL
  - 查看 profiles
  - 查看两次 SQL 对应的 profile

**1.开启查询缓存**

![image-20220504163057893](./image/MySQL逻辑架构/image-20220504163057893.png)

**2.执行两次 SQL，并查看profiles**

![image-20220504163223667](./image/MySQL逻辑架构/image-20220504163223667.png)

**3.分别查看两次 query_Id 的profile**

![image-20220504163719119](./image/MySQL逻辑架构/image-20220504163719119.png)



## 数据缓冲池(buffer pool)

- `InnoDB` 存储引擎是以**`页`**为单位来管理存储空间的,默认一页大小为`16KB`。我们进行的增删改查操作其实本质上都是在`访问页`(包括读页面、写页面、创建新页面等操作)。
- 磁盘 I/O 需要较多的时间,而在内存中进行操作，效率则会高很多。DBMS(比如 MySQL) 会`申请内存作为数据缓冲池`
  - 在真正访问页面之前，需要把在磁盘上的页缓存到内存中的`buffer pool`之后才可以访问
- 这样做,可以尽可能的`减少与磁盘直接 I/O 的时间`, 可以提升 SQL 的查询性能

### 缓冲池的预读特性

缓冲池的作用就是提高 I/O 效率,在读取数据的时候,存在一个`局部性原理`,即使用的一些数据很可能依赖于它周围的数据。所以采用`预读`的方式将某个数据页周围的数据提前加载,从而减少磁盘的 IO操作

### 缓冲池与查询缓存

> 首先两个并不是一个东西🙅🏻‍♀️

在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存(`数据页、索引页、插入缓存、锁信息、自适应索引 Hash、数据字典信息`等)，如下图所示：

![image-20220504165240819](./image/MySQL逻辑架构/image-20220504165240819.png)



### 缓冲池如何读取数据

> 缓冲池管理器会尽量将经常使用的数据保存起来。
>
> 在数据库进行页面读操作的时候，首先会判断该页面 是否在缓冲池中，如果存在就直接读取; 如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取

缓存在数据库中的结构和作用如下图所示:

![image-20220508143110685](./image/MySQL逻辑架构/image-20220508143110685.png)



:::danger 如果执行 SQL 语句时更新了缓冲池的数据？

问题: <font color='red'>在执行 SQL 语句的时候更新了缓冲池中的数据,那么这些数据会同步到磁盘么?</font>

事实上,我们对数据库中的数据进行修改的时候,**首先修改的是缓冲池中页里面的数据**, 然后数据库会`以一定的频率刷新到磁盘上`，而不是每次发生更新操作就立即进行磁盘回写。

缓冲池会采用一个 `checkpoint 的机制` 将数据回写到磁盘。比如当`缓冲池`不够用的时候,需要释放一些不常用的脏页，那么就会使用 checkpoint 的方式,将不常用的页回写到磁盘,然后再从缓冲池中释放掉页。这里的 **脏页**指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。

:::

### 查看/设置缓冲池[InnoDB]

- 查看缓冲池大小
  - `show variables like 'innodb_buffer_pool_size';`
  - 缓冲池默认大小为: `128M`
  - 通过修改配置文件可以修改默认缓冲器大小
- 设置多个缓冲池实例
  - `show variables like 'innodb_buffer_pool_instance; `
  - 默认情况下,缓冲池只有 1 个实例
  - <mark>缓冲池的总大小 size 是所有缓冲池实例加起来的！</mark>

![image-20220508143408311](./image/MySQL逻辑架构/image-20220508143408311.png)

## 存储引擎

### 存储引擎操作

#### 查看存储引擎

通过 ` show engines;` 可以查看所有的存储引擎

![image-20220508144101171](./image/MySQL逻辑架构/image-20220508144101171.png)

#### 查看默认存储引擎

> 默认 MySQL8.0 使用 InnoDb 作为存储引擎, 所以如果数据表没有指定存储引擎的话,默认也会使用 InnoDB 作为存储引擎

通过下面两种方式可以查看默认的存储引擎

```sql
show variables like 'default_storage_engine'
# 或者
SELECT @@default_storage_engine;
```

![image-20220508144428527](./image/MySQL逻辑架构/image-20220508144428527.png)

#### 修改默认存储引擎

- 基于命令
  - `SET DEFAULT_STORAGE_ENGINE=MyISAM;`
- 基于配置文件
  - `default-storage-engine=MyISAM`

#### 设置表的存储引擎

> 存储引擎就是用户将表的数据进行存储与提取的,`不同的表可以设置不同的存储引擎`,也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。
>
> 如果不指定的话,使用默认的存储引擎

- 创建表时

  ```sql
  CREATE TABLE 表名
  ( 
    	建表语句;
  ) ENGINE = 存储引擎名称;
  ```

- 修改表的存储引擎

  ```sql
  ALTER TABLE 表名 ENGINE = 存储引擎名称;
  ```

### 引擎介绍

#### InnoDB

> 具备外键支持功能的事务存储引擎

1. MySQL从3.23.34a开始就包含InnoDB存储引擎。 `在 MySQL5.5及后续版本中,默认使用 InnoDB`
2. InnoDB是MySQL的`默认事务型引擎`，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)
   - 除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎
   - 出非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎
3. 数据文件结构
   - `表名.frm`:  存储表结构 (MySQL8.0时，合并在表名.ibd中)
   - `表名.ibd`:  存储数据和索引
4. InnoDB是为了处理巨大数据量的最大性能设计
5. 对比MyISAM的存储引擎, `InnoDb 写的处理效率差一点`,并且会占用更多的磁盘空间以保存数据和 索引
6. MyISAM只缓存索引，不缓存真实数据。InnoDB不仅缓存索引还要缓存真实数据,所以`对内存的要求较高`,而且内存大小对性能有决定性的影响

#### MyISAM

> 主要的非事务处理存储引擎

1. MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等,但MyISAM`不支持事务、行锁、外键`,所以出现异常之后无法安全回复回滚
2. `MySQL 5.5之前默认的存储引擎`
3. 优势是`访问快`
4. 针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高
5. 数据文件结构
   - `表名.frm` 存储表结构
   - `表名.MYD` 存储数据 (MYData) 
   - `表名.MYI` 存储索引 (MYIndex)
6. 应用场景:只读应用或者以读为主的业务

#### Memory

> 基于内存的表
>
> Memory采用的逻辑介质是 `内存` ， 响应速度很快 ，但是`当mysqld守护进程崩溃的时候 数据会丢失 `
>
> 另外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)。

1. Memory同时支持`哈希索引` 和 `B+树索引`
2. Memory至少比MyISAM要`快一个数量级`
3. MEMORY `表大小是受限制的` 的。表的大小主要取决于两个参数:
   - `max_rows`: 在创建表时指定
   - `max_heap_table_size` : 大小默 认为16MB，可以按需要进行扩大
4. 数据文件与索引文件分开存储
5. 缺点:其数据易丢失，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心
6. **使用场景**
   - 目标数据比较小，而且非常频繁的访问。因为内存中的数据如果太大的话,会导致 OOM。当然可以通过 `max_heap_table_size` 进行控制
   - 如果数据是临时的，允许数据丢失的,可以放在内存中

#### Federated

> Federated引擎是访问其他MySQL服务器的一个 `代理` 
>
> 尽管该引擎看起来提供了一种很好的 跨服务 器的灵活性 ，但也经常带来问题，因此 `默认是禁用的` 

#### NDB

> MySQL集群专用存储引擎

也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群 环境

#### InnoDB 与 MyISAM

![image-20220508150959020](./image/MySQL逻辑架构/image-20220508150959020.png)

### InnoDB**和**ACID模型

1. `原子方面`
   - ACID的原子方面主要涉及InnoDB事务
     - 自动提交设置
     - COMMIT语句
     - ROLLBACK语句
     - 操作INFORMATION_SCHEMA库中的表数据
2. `一致性方面`
   - ACID模型的一致性主要涉及保护数据不崩溃的内部InnoDB处理过程
     - InnoDB双写缓存
     - InnoDB崩溃恢复
3. `隔离方面`
   - 隔离是应用于事务的级别
     - 自动提交设置
     - SET ISOLATION LEVEL语句
     - InnoDB锁的低级别信息
4. `耐久性方面`
   - ACID模型的耐久性主要涉及与硬件配置相互影响的MySQL软件特性
     - InnoDB双写缓存，通过`innodb_doublewrite`配置项配置
     -  配置项`innodb_flush_log_at_trx_commit`
     - 配置项`sync_binlog`
     - 配置项`innodb_file_per_table`
     - 存储设备的写入缓存
     - 存储设备的备用电池缓存
     - 运行MySQL的操作系统。
     - 持续的电力供应
     - 备份策略
     - 对分布式或托管的应用，最主要的在于硬件设备的地点以及网络情况

### InnoDB架构

1. `缓冲池`
  -  缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。
  - 缓冲池使得经常被使用的数据能够直接在内存中获得，从而提高速度
2. `更改缓存`
   - 更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索 引页的更改。
   - 索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁 盘。更新缓存合并期间，可能会大大降低查询的性能。
     - 在内存中，更新缓存占用一部分InnoDB缓冲池。
     - 在磁盘中，更新缓存是系统表空间的一部分。
   - 更新缓存的数据类型由`innodb_change_buffering `配置项管理。
3. `自适应哈希索引` 
   - 自适应哈希索引将负载和足够的内存结合起来，使得InnoDB像内存数据库一样运行， 不需要降低事务上的性能或可靠性。
   - 这个特性通过 `innodb_adaptive_hash_index` 选项配置，或者通过-- skip-innodb_adaptive_hash_index命令行在服务启动时关闭。
4. `重做日志缓存` 
   - 重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过 `innodb_log_buffer_size`配置项配置。
   - 重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存 使得大型事务能够正常运行而不需要写入磁盘。
5. `系统表空间`
   - 系统表空间包括InnoDB数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引数据。
   - 多表共享，系统表空间被视为共享表空间。
6. `双写缓存`
   -  双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存 后，InnoDB才会将数据页写入合适的位置。
7. `撤销日志` 
   - 撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他 事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。
   - 撤销日志存在于撤销日志片段中，这 些片段包含于回滚片段中。
8. `独立表空间` 
   - 每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中， 而不是系统表空间中。
   - 这个功能通过`innodb_file_per_table`配置项开启。每个表空间由一个单独的.ibd数 据文件代表，该文件默认被创建在数据库目录中。
9. `通用表空间`
   -  使用CREATE TABLESPACE语法创建共享的InnoDB表空间。
   - 通用表空间可以创建在MySQL数 据目录之外能够管理多个表并支持所有行格式的表。
10. `撤销表空间` 
    - 撤销表空间由一个或多个包含撤销日志的文件组成。
    - 撤销表空间的数量由 `innodb_undo_tablespaces`配置项配置。
11. `临时表空间`
    -  用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。 
    - `innodb_temp_data_file_path `配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在 `innodb_data_home_dir`变量指定的目录下创建一个自动扩展的数据文件。
12. `重做日志`
    - <mark>重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据</mark> 
    - 正常操作期间， 重做日志会将请求数据进行编码，这些请求会改变InnoDB表数据。遇到意外崩溃后，未完成的更改会自 动在初始化期间重新进行。

