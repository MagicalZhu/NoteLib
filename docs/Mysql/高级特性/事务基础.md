---
id: 事务基础
title: 事务基础
---

## 数据库事务

**事务是数据库区别的文件系统的重要特性之一**

1. 事务就可以让数据库始终保持`一致性`
2. 可以通过事务的机制`恢复到某个时间点`,这样可以保证提交到数据库的修改不会因为系统崩溃而丢失

### 存储引擎的支持情况

> MySQL 只有**InnoDB** 支持事务

`SHOW ENGINES` 命令来查看当前MySQL支持的存储引擎都有哪些，以及这些存储引擎是否支持事务

![image-20220804163343357](./image/事务/image-20220804163343357.png)

### 基本概念

1. `事务`
   - **一组逻辑操作单元，使数据从一种状态变换到另一种状态**
2. `事务处理的原则`
   - 保证所有事务都作为`一个工作单元` 来执行, 即使出现了故障,都不能改变这种执行方式。
   - 当在一个事务中执行多个操作时 :
     - 要么所有的事务都被提交`Commit`,那么这些修改就 `永久` 地保存下来
     - 要么数据库管理系统将 `放弃` 所作的所有`修改`, 整个事务回滚`rollback`

### ACID

事务的 ACID 指的是:

1. **原子性 (atomicity)**
2. **一致性 (consistency)**
3. **隔离型 (isolation)**
4. **持久性 (durability)**

:::tip 说明

ACID 是事务的 4 大特性,这四个特性中:**原子性是基础,一致性是约束条件,隔离性是手段,持久性是最终目标**

:::

#### atomicity

> 多个操作不可分割

- **原子性是指事务是一个不可分割的工作单位。要么全部提交,要么全部失败回滚**
- 即要么转账成功,要么失败,不存在一种中间状态。如果没有事务,就会出现 A 账户增加 100,但是 B 账户没有扣除 100

#### consistency

> 用设定的目标规则是否一致

- **一致性是指事务执行前后，数据从一个`合法性状态` 变换到另外一个 `合法性状态`。这种状态是` 语义`上的而不是语法上的,跟具体的业务有关**

- 那么什么事合法的数据状态呢?
  - 满足`预定的约束` 的状态就叫做合法的状态。这状态是自定义的。**满足这个状态,数据就是一致的，不满足这个状态，数据就是不一致的**
  - **如果事务中某个操作失败了,系统就会自动撤销当前正在执行的事务,返回到执行事务之前的状态**

**示例:**

比如 A 账户只有 200 元,但是却转出去 300 元,账户余额变成了 -100元。这个就是不一致的体现,因为定义了一个状态**余额>=0**

#### isolation

> 多个事务互不影响

- **事务的隔离性是指一个事务的执行不能被其他事务干扰**
  - 即一个事务内部的操作及使用的数据对`并发的其他事务`是隔离的，并发执行的各个事务之间不能互相干扰

:::info 示例

如果无法保证隔离性会怎么样?假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50 元，分别在两个事务中执行

```sql
UPDATE accounts SET money = money - 50 WHERE NAME = 'AA'; 
UPDATE accounts SET money = money + 50 WHERE NAME = 'BB';
```

如果无法保证隔离性，会出现下面的情形:

![image-20220804225848837](./image/事务/image-20220804225848837.png)

:::

#### durability

- **持久性是指一个事务一旦被提交(刷新到磁盘了)，它对数据库中数据的改变就是**`永久性的`**,接下来的其他操作和数据库故障不应该对其有任何影响**

- 持久性是通过`事务日志` 来保证的,日志包括了 `重做日志` 和 `回滚日志`
- **当我们通过事务对数据进行修改 的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改**
  - 这样做即使数据库系统崩溃，**数据库重启后也能找到没有更新到数据库系统中的重做日志,重新执行,从而使事务具有持久性**

### 事务的状态

我们现在知道`事务`是一个抽象的概念，它**其实对应着一个或多个数据库操作**,MySQL根据这些操作所执行的不同阶段把事务大致划分成几个状态:

1. `活动的 (active)`
   - **事务对应的数据库操作正在执行过程中时**，我们就说该事务处在`活动的`状态
2. `部分提交的 (partially committed)`
   - 当事务中的最后一个操作执行完成,但由于操作都在内存中执行，所造成的影响并`没有刷新到磁盘`时，我们就说该事务处在`部分提交的`状态
3. `失败 (failed)`
   - 当事务处在`活动的`或者`部分提交的`状态时,**可能遇到了某些错误(数据库自身的错误、操作系统 错误或者直接断电等)而无法继续执行，或者人为的停止当前事务的执行**，我们就说该事务处在`失败的`状态
4. `终止的 (aborted)`
   - 如果事务执行了一部分而变为`失败的` 状态，那么就需要**把已经修改的事务中的操作还原到事务执行前的状态**
     - 即要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为 `回滚` 
   - **当`回滚`操作执行完毕时，也就是数据库恢复到了执行事务之前的状态,我们就说该事务处在了 `中止的` 的状态**
5. `提交的 (committed)`
   - **当一个处在`部分提交的`状态的事务将修改过的数据都 `同步到磁盘` 上之后，我们就可以说该事务处在了**`提交`**状态**



**基本的事务状态转换图如下所示:**

![image-20220804232155697](./image/事务/image-20220804232155697.png)



## 使用事务

**使用事务有两种方式:**

1. `显式事务`
2. `隐式事务`

### 显式事务

指定一个显式的事务有以下的操作步骤:

1. 使用`START TRANSACTION `或 `BEGIN` 显式开启一个事务

2. 指定事务中的一系列的操作(主要是 DML,不含 DDL)

3. **提交事务**或者**终止事务(回滚)**

#### 开启事务

- **基本语法格式**

  ```sql
  BEGIN;
  #或者
  START TRANSACTION;
  ```

- **START TRANSACTION 语句相较于 BEGIN 特别之处在于,后边能跟随几个修饰符:**

  - `READ ONLY`
    - 标识当前事务是一个`只读事务`,也就是属于该事务的数据库操作只能读取数据,而不能修改数据
  - `READ WRITE`
    - 标识当前事务是一个`读写事务`,也就是属于该事务的数据库操作既可以读取数据,也可以修改数据
  - `WITH CONSISTENT SNAPSHOT`
    - 启动一致性读

#### 提交/回滚事务

- `COMMIT`   : 提交
- `ROLLBACK` : 回滚 

```sql
 # 提交事务。当提交事务后，对数据库的修改是永久性的。 
 COMMIT;
 
 
 # 回滚事务,即撤销正在进行的所有没有提交的修改
 ROLLBACK
 
 # 将事务回滚到某个保存点
 ROLLBACK TO [SAVEPOINT]
```



### 隐式事务

MySQL 中有一个系统变量 `autocommit`用于控制自动提交

![image-20220804234124287](./image/事务基础/image-20220804234124287.png)

当然，如果我们想关闭这种`自动提交` 的功能，可以使用下边两种方法之一:

1. **显式的的使用 START TRANSACTION 或者 BEGIN 语句开启一个事务**。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能

2. **把系统变量 `autocommit` 的值设置为 `OFF`**

   ```sql
   # 关闭自动提交
   SET autocommit = OFF;
   
   #  开启自动提交
   SET autocommit = ON;
   ```

   
