---
id: 索引的应用
title: 索引的应用
---
> 对于 InnoDB 存储引擎的 B+Tree 索引,我们已经知道:
>
> 1. 每个索引都对应一棵 B+Tree,B+Tree 分为很多层,**最下面一层是叶子节点,其余的都是内节点**。所有的用户记录都存放在叶子节点中,所有的目录项记录都放在内节点中
> 2. **InnoDB 会自动的为主键建立聚簇索引,且叶子节点存储这个表所有列的数据** 
>    - 如果没有主键,就选择一个非空的唯一键,如果也没有,会自动添加一个隐藏列(主键)
> 3. 我们可以将指定的列设置为索引列(二级索引),二级索引的叶子节点中只包含**主键 + 索引列**的数据,而不是**完整的数据**。所以如果想通过二级索引获取表的完整数据,那么就需要**回表操作**, 即利用二级索引得到叶子节点中的主键值,在利用主键值去聚簇索引中获取完整的用户记录。
> 4. 索引还支持联合索引,本质上也还是二级索引,不过索引列的数量至少有两个
> 5. B+Tree 中的每层节点都是按照索引列的值从小到大排序的(排除索引手动设置为降序索引),且节点内的用户记录会形成一个单向链表,保证逻辑的连续。对于联合索引来说,排序规则稍微复杂一点,假设索引为 idx_a_b_c,那么排序规则如下
>    - 首先按字段 a 的值进行排序
>    - 如果字段 a 的值相同,则按照字段 b 的值排序
>    - 如果字段 b 的值相同,则按照字段 c 的值排序
> 6. 我们也将一个节点称之为一个页面,页面有个自己的类型。
> 7. 查询记录的时候,是从根节点向下一层一层查询的,每个页面中的记录都被划分为了若干个组,每个组中记录的最大值在页面的偏移量都会作为**槽** 放在**页目录**中,这样可以使用二分法,从而进一步的提高查询的效率



## 应用 B+Tree索引

### 扫描区间&边界条件

> 对于某个查询来说,最为简单粗暴的方式就是全表扫描,判断每一条记录与查询条件是否匹配。**对于 InnoDB 来说,全表扫描意味着从聚簇索引的第一个叶子节点的第一条记录沿着“链表”不断向后遍历查询,直到最后一条记录**。这种方式最为简单,但是性能最差

**我们可以利用索引快速的定位到索引列值等于某个记录值的数据**, 由于索引是排好序的数据结构,那么我们也可以`只扫描某个区间或者某些区间的记录`,这样**也可以减少需要扫描的数量**。比如下面的查询语句:

```sql
# id 是主键
  SELECT * FROM T1 WHERE id >= 2 AND id <= 100
```


这个语句其实就是查询id 值在[2,100]区间的所有聚簇索引的记录,我们可以通过聚簇索引快速的定位到 id = 2 的记录,然后不断地向后遍历,直到 id > 100, 相当于全表扫描来说,遍历的数据量小了很多。我们把`待扫描记录的所在的区间称为扫描区间`(比如这里的[2,100]),同时我们称`构成这个区间的查询条件为边界条件`(比如这列的 *id >= 2 AND id <= 100*)

<br/>

当然, 不是有的查询条件都可以形成边界条件的,我们看下下面的示例

1. **如果以 idx_key1作为索引**
   - 扫描区间就是**key1:  [-∞, 'a']**, 那么*key3 > 'z' and common_field = 'abc'* 就是简单的查询条件了
2. **如果以 idx_key2作为索引**
   - 扫描区间就是**key2:  ['z', -∞]**, 那么*key1 < 'a' and common_field = 'abc'* 就是简单的查询条件了

```sql
-- key1、key3 都是有索引的,common_field 没有索引
SELECT * FROM T1 WHERE key1 < 'a' ahd key3 > 'z' and common_field = 'abc'
```

<br/>

从上面的描述可以看出来,利用索引执行查询的时候,关键的问题是**通过查询条件找出`合适`的扫描区间,然后再到对应的 B+Tree 中扫描这些区间中的记录**, 扫描的时候也只需要定位到区间的第一条记录,然后向后遍历,直到不满足边界条件即可。

<br/>

**我们有下面常见的限定词可以定义一个扫描区间:**

1. `IN、NOT IN、BETWEEN`
2. `=、!=、>、<、>=、<=`
   - 这个容易被忽略,即排除某个值之外的范围区间
3. `LIKE`
   - **扫描到索引列满足like 查询条件的第一个记录,然后向后遍历即可**
   - 我们需要清楚的明白: **字段列开头相同的数据在索引的叶子节点中是紧挨着的!**
   - 比如 **like 'a%'**,扫描区间就是['a','b')

:::tip 小提示

对于全表扫描来说,它也有扫描区间的,就是`[-∞,+∞]`

:::

### 单点、范围扫描区间

有一个 SQL 语句:

```sql
# 这里key2是Unique Key
SELECT * FROM T1 WHERE key2 in (1438,6328) OR (key2 >= 38 and key2 <=79)
```

分析以下,我们可以为这个 SQL 语句划分 3 个扫描区间:

1. **[1438, 1438]** : 对应的边界条件就是 *key2 in (1438)*
2. **[6328, 6328]** : 对应的边界条件就是 *key2 in (6328)*
3. **[38, 79]** : 对应的边界条件就是*(key2 >= 38 and key2 <=79)*

我们将**[1438, 1438]、[6328, 6328]** 这样区间范围的值有且仅有一个的,称之为`单点扫描区间`,而**[38,79]**这样区间范围内包含多个值的称之为`范围扫描区间`

### 全都是扫描区间











