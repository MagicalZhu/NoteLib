---
id: Ribbon
title: 服务调用-Ribbon
---

# 1.Ribbon

## 1.1 Ribbon 概述

- <font color='red'>什么是Ribbon ?</font>
  - <font color='blue'>SpringCloud Ribbon是基于Netflix Ribbon实现的一套`客户端 负载均衡`的工具。</font>
    - Ribbon是Netflix发布的开源项目，主要功能是提供`客户端软件负载均衡算法`，将Netflix的中间层服务连接在一起
  - <font color='blue'>Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等</font>
    - <font color='red'>即在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则去连接这些机器</font>
      - 比如 :  `简单轮询`，`随机连接`等
    - 我们也很容易使用Ribbon实现自定义的负载均衡算法

## 1.2 Ribbon负载均衡

- <font color='red'>负载均衡(Load Balance) ?</font>
  - 将用户的请求平摊的分配到多个服务上，从而达到系统的高可用性(HA)
    - 常见的负载均衡有软件  ==Nginx，LVS，硬件 F5==等
	-  <font color='blue'>集中式 LoadBalance</font>
    - 在服务的消费方和提供方之间使用独立的 LoadBalance 设施 ,由该设施负责把访问请求通过某种策略转发至服务的提供方
      - 可以是硬件，如F5
      - 也可以是软件，如nginx
  - <font color='blue'>进程内 LoadBalance</font> 
    - 将 LoadBalance  逻辑集成到消费方, ==消费方从服务注册中心获知有哪些地址可用，然后再从这些地址中选择合适的服务器==
      - <font color='red'>**Ribbon属于进程内LB**</font>
      - Ribbon 只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址

# 2.Ribbon 使用

## 2.1 Ribbon 基本使用

- <font color='red'>操作步骤</font> 
  1. 引入SpringCloud Ribbon的依赖
     - ==注: 在Eureka、Consul 中依赖了Ribbon组件，可以不引入Ribbon==
  2. 通过配置类注入 RestTemplate 时，使用 <font color='red'>`@LoadBalanced`</font> 注解标注
     - 该注解会将 RestTemplate 配置为一个具有负载均衡功能的 Http客户端
  3. 使用RestTemplate 发送Http 请求时,使用 服务的 <font color='green'>`ServiceName`</font> 替换端口和ip 

**①、 通过@Loadbalanced 注解注入一个具有负载均衡的RestTemplate**

- 默认的负载均衡算法实现是 `RoundRobinRule` 轮询算法

```java
@Configuration
public class OrderConfig {
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(){
        RestTemplate restTemplate = new RestTemplate();
        List<HttpMessageConverter<?>> list = restTemplate.getMessageConverters();
        // 替换 StringHttpMessageConverter 的默认字符集
        for (HttpMessageConverter<?> httpMessageConverter : list) {
            if(httpMessageConverter instanceof StringHttpMessageConverter) {
                ((StringHttpMessageConverter) httpMessageConverter).setDefaultCharset(StandardCharsets.UTF_8);
                break;
            }
        }
        return restTemplate;
    }
}
```



**②、 使用RestTemplate**

- RestTemplate 此时具有负载均衡功能

```java
@Slf4j
@RestController
@RequestMapping("/consumer")
public class OrderController {
    @Resource
    private RestTemplate restTemplate;
		
  	// 使用服务的serviceName 替换掉原来的 ip：端口 
    private static final String CLOUD_PAYMENT_SERVICE_CONSUL="http://cloud-payment-service-consul";

    @GetMapping("/getPayments/consul")
    public String getPayments(){
        String result = restTemplate.getForObject(CLOUD_PAYMENT_SERVICE_CONSUL+"/payment/get", String.class);
        return result;
    }
}
```



## 2.2 Ribbon 核心组件IRule

- ==负载均衡策略==, 根据特定算法中从服务列表中选取一个要访问的服务
- <font color='red'>Ribbon 内置的一些负载均衡策略</font>
  - <font color='blue'>`RoundRobinRule`</font> 
    - 轮询策略 (默认使用的)
    - <font color='red'>请求接口的次数 % 服务器集群总数量 = 实际调用服务器位置下标</font>
  - <font color='blue'>`RandomRule`</font>
    - 随机策略
  - <font color='blue'>`AvailabilityFilteringRule`</font>
    - 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阈值的服务
      - 然后对剩余的服务列表按照轮询策略进行访问
  - <font color='blue'>`WeightedResponseTimeRule`</font>
    - 根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越高。
    - <font color='green'>刚启动时如果统计信息不足，则使用RoundRobinRule策略，等统计信息足够，会切换到  WeightedResponseTimeRule</font>
  - <font color='blue'>`RetryRule`</font>
    - 先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务
  - <font color='blue'>`BestAvailableRule`</font>
    - 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务
  - <font color='blue'>`ZoneAvoidanceRule`</font>
    - 复合判断Server所在区域的性能 和 Server的可用性选择服务器

### 2.2.1 全局注入Ribbon的负载均衡策略 (所有客户端共享)

- <font color='red'>操作步骤</font> 
  - 通过配置类向容器中注入其他的 `IRule`  接口实现类
    - <font color='red'>注意配置类位于 SpringBoot 应用能扫描到的路径</font> 

 **配置类注入 其他的IRule 实现类**

```java
@Configuration
public class OrderConfig {
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(){
        RestTemplate restTemplate = new RestTemplate();
        List<HttpMessageConverter<?>> list = restTemplate.getMessageConverters();
        // 替换 StringHttpMessageConverter 的默认字符集
        for (HttpMessageConverter<?> httpMessageConverter : list) {
            if(httpMessageConverter instanceof StringHttpMessageConverter) {
                ((StringHttpMessageConverter) httpMessageConverter).setDefaultCharset(StandardCharsets.UTF_8);
                break;
            }
        }
        return restTemplate;
    }
	
   // 注入随机策略 RandomRule
    @Bean
    public IRule rule(){
        return new RandomRule();
    }
}
```



### 2.2.2 局部注入Ribbon的负载均衡策略（单独客户端使用）

- <font color='red'>`@RibbionClient`</font>
  - 作用: 在客户端访问指定微服务的时候优先加载 <font color='blue'>`自定义的Ribbon配置类`，</font>从而使配置生效
    - 会体会默认的全局配置
    - ==<font color='red'>注意 : 自定义配置类 不能放在@ComponentScan 所扫描的包以及子包下 !!!( 比如 @SpringBootApplication 中的扫描路径 ) </font>==
  - **@RibbonClient 的属性**
    - <font color='purple'>>`name|value`</font>  : 访问的微服务的服务名(serviceName)
    - <font color='purple'>>`configuration`</font> : 自定义的配置类

- <font color='red'>操作步骤</font>
  1. 创建配置类,配置类中注入IRule接口的实现类，并且将配置类放在 @ComponentScan 扫描不到的路径
  2. 在启动类上标注 <font color='red'>`@RibbonClient | @RibbonClients`</font> 

**①、包结构**

<img src="image/2.Ribbon/image-20201205100306796.png"  style="zoom:80%;" />

**②、自定义的配置类注入IRule实现类**

```java
@Configuration
public class MyRibbonRule {

    @Bean
    public IRule rule(){
        return new RandomRule();
    }
}
```

**③、SpringBoot启动类上使用 @RibbonClients注解**

```java
@SpringBootApplication
@EnableDiscoveryClient
// @RibbonClients 可以同时为多个客户端服务注入规则策略
@RibbonClients(
       {
               @RibbonClient(name="cloud-payment-service-consul",configuration = MyRibbonRule.class)
       }
)
public class Order80 {
    public static void main(String[] args) {
        SpringApplication.run(Order80.class,args);
    }
}

```



































