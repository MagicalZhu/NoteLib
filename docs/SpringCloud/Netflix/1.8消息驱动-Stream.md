---
id: Stream
title: 消息驱动-Stream
---

# 1.消息驱动

## 1.1 消息驱动概述

- <font color='red'>Stream  是什么？</font>
  - 构建消息驱动微服务的框架
    - <font color='red'>可以屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型</font> 
  - 通过 `Spring Integration` 来连接消息代理中间件以实现消息事件驱动
    - <font color='blue'>Stream 为一些消息中间件提供了个性化的自动化配置，引用了`发布-订阅、消息组、分区三个核心概念`</font>
- <font color='red'>三个核心构建块</font>
  - <font color='blue'>`Binder`</font> 
    - 应用与消息中间件之间的封装，目前仅支持 <font color='purple'>>`RabbitMq 、Kafka`</font>
    - 通过Binder可以很方便的连接中间件，可以动态的改变消息类型(Kakfa对应topic、RabbitMQ对应exchange)
      - Input 是消费者
      - Output 是生产者
  - <font color='blue'>`Binding`</font> 
  - <font color='blue'>`Message`</font> 

## 1.2 Stream的使用

- <font color='red'>三要素</font>
  - <font color='blue'>Binder</font>
  - <font color='blue'>Channel</font>
    - 是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过对Channel对队列进行配置
  - <font color='blue'>Source和Sink</font>
    - Source 是输出Output
    - Sink 是输入input
- <font color='red'>常见的类和注解</font> 
  - <font color='blue'>`@Input`</font> 
    - 标识一个输入通道(消费者)，通过该输入通道接收到的消息进入应用程序
  - <font color='blue'>`@Output`</font> 
    - 标识一个输出通道(生产者)，发布的消息通过该通道离开应用程序
  - <font color='blue'>`@StreamListener`</font> 
    - 监听队列，用于消费者队列的消息接收
  - <font color='blue'>`@EnableBinding`</font> 
    - 指定Channel 和Exchange绑定在一起

### 1.2.1 Stream-Rabbitmq （生产者）

- <font color='red'>操作步骤</font>
  1. 引入 Stream-Rabbit 的依赖 `spring-cloud-starter-stream-rabbit`
  
  2. 在配置文件中配置 `Map<String, BinderProperties> binders`以及 `Map<String, BindingProperties> bindings

     - `Map<String, BinderProperties> binders`
       - 绑定器的名称
       - <font color='red'>`BinderProperties`</font>

         - <font color='blue'>`type`</font> : 中间件类型，目前有两种 <font color='purple'>>`rabbit | kafka`</font> 
         
         - `environment`  [ Map<String,Object> ]
       
           - 环境配置信息，比如配置 消息中间件的连接信息
     - Map<String, BindingProperties> bindings

       - 键是通道的名称，比如output、input
       - <font color='red'>`BindingProperties`</font> 
         - <font color='blue'>`binder`</font> : 设置要绑定的消息服务的的名称
         - <font color='blue'>`destination`</font>: 发送到哪个exchange
         - <font color='blue'>`content-type:`</font>:  设置消息类型，默认是json
         - <font color='blue'>`group`</font> : 组名
  3. 在发送消息的方法中注入 <font color='red'>`MessageChannel`</font> ,并通过它发送消息
  4. 在发送类上标注<font color='red'>`@EnableBinding `</font> 来添加一个 <font color='red'>`Source | Sink`</font> 的绑定

#### 1.2.1.1 代码实现

**①、 添加依赖**

```xml
<!-- 使用 Consul -->
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-consul-discovery</artifactId>
</dependency>
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
</dependency>
```



**②、 配置文件中配置Stream**

```yml
server:
  port: 8801
spring:
  application:
    name: cloud-stream-rabbitmq-provider-8801
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        service-name: cloud-stream-rabbitmq-provider
        instance-id: ${spring.application.name}
    stream:
      binders:                    # 配置要绑定的rabbitmq的服务信息
        inRabbit:             		# binder的名称，用于于binding整合
          type: rabbit
      bindings:
        output: 									# 消息服务是输入(input)还是输出(output)
          destination: testExchange
          content-type: application/json  # 设置消息类型
          binder: inRabbit        # 绑定哪一个binder
  rabbitmq:
    virtual-host: /
    username: guest
    password: guest
    host: 172.24.95.56
    port: 5672
```

**③、编写消息发送类**

```java
// 自定义接口
public interface IMessageProvider<T> {

    void sendMsg(T message);
}


// 接口实现类
@EnableBinding( Source.class)
public class StringMessageProvider implements IMessageProvider<String> {

    @Resource
    @Qualifier(value = "output")
    private MessageChannel channel;

    @Override
    public void sendMsg(String message) {
        channel.send(MessageBuilder.withPayload(message).build());
    }
}
```



### 1.2.2 Stream-Rabbitmq （消费者）

- <font color='red'>操作步骤</font>
  - 引入 Stream-Rabbit 的依赖 `spring-cloud-starter-stream-rabbit`
  - 在配置文件中配置 <font color='red'>`Map<String, BinderProperties> binders`</font> 以及 <font color='red'>Map<String, BindingProperties> bindings</font> 
    - <font color='red'>`Map<String, BinderProperties> binders`</font> 
      - 绑定器的名称
      - <font color='red'>`BinderProperties`</font>
        - <font color='blue'>`type`</font> : 中间件类型，目前有两种 <font color='purple'>>`rabbit | kafka`</font> 
        
        - `environment`  [Map<String,Object>]
        
          - 环境配置信息，比如配置 消息中间件的连接信息
    - Map<String, BindingProperties> bindings

      - 键是通道的名称，比如output、input
      - <font color='red'>`BindingProperties`</font> 
        - <font color='blue'>`binder`</font> : 设置要绑定的消息服务的的名称
        - <font color='blue'>`destination`</font>: 发送到哪个exchange
        - <font color='blue'>`content-type:`</font>:  设置消息类型，默认是json
  - 在发送类上标注<font color='red'>`@EnableBinding `</font> 来添加一个 <font color='red'>`Source | Sink`</font> 的绑定
  - 在发送方法通过 <font color='red'>`@StreamListener`</font> 标识一个监听方法



#### 1.2.2.1 代码实现

**①、配置文件修改**

```yml
server:
  port: 8802
spring:
  application:
    name:  cloud-stream-rabbitmq-consumer-8802
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        service-name: cloud-stream-rabbitmq-provider
        instance-id: ${spring.application.name}
    stream:
      binders:
        outRabbit:
          type: rabbit
      bindings:
        input:
          destination: testExchange
          content-type: application/json
          binder: outRabbit
  rabbitmq:
    virtual-host: /
    username: guest
    password: guest
    host: 172.24.95.56
    port: 5672
```



**②、配置监听方法**

```java
@RestController
@EnableBinding(Sink.class)
@Slf4j
public class ReceiveMessageController {
    @Value("${server.port}")
    private String serverPort;

    @StreamListener(Sink.INPUT)
    public void getMsg(Message<String> msg){
        log.error("serverPort:{}-->msg:{}-->headers:{}",serverPort,msg.getPayload(),msg.getHeaders().keySet());
    }
}
```



## 1.3 重复消费问题

- 消息生产者发送消息后，会被所有消费者共同消费 -> 重复消费问题 -> 通过group 处理
- ==Stream 中同一个group中的多个消费者是竞争关系，一个消息只会被group中的一个消费者消费==
  - <font color='red'>不同group 是可以重复消费的，同一个group中存在竞争关系，只有其中一个可以消费</font>

### 1.3.1 通过Group处理重复消费问题

- <font color='red'>操作步骤</font>
  1. 修改配置文件中 <font color='green'>`binding`</font> 中的group 属性

**①、设置消费者在同一个组**

![image-20201213141336471](../image/8.%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8-%20Stream/image-20201213141336471.png)

