---
id: jmm
title: JMM
---

## 性能问题

主要有以下两个性能问题:

1. 调度: **上下文切换**
2. 协作: **内存同步**

### 上下文切换(Context Switch)

1. CPU 通过给每个线程分配CPU时间片实现多线程。时间片就是CPU给每个线程的时间,时间片非常短,一般是几十毫秒。由于时间片非常的短,所以CPU会不停的切换线程执行
2. CPU通过时间分配算法循环执行任务,当前任务执行一个时间片后会切换到下一个任务。**切换任务前会保存上一个任务的状态,以便下次切换回这个任务时可以再加载这个任务的状态**
   - `上下文切换: 从保存一个任务 到 加载下一个任务的过程`

3. 上下文切换还需要有一定的缓存开销

## JMM(Java内存模型)

 1. jmm是一种抽象的概念,并不真实存在,它描述的是一组规则或规范,通过这组规范定义了程序中各个变量（包括实例字段,静态字段 和构成数组对象的元素）的访问方式。
 2. jvm运行程序的实体是线程,而每个线程创建时jvm都会为其创建一个本地内存(有些地方称为栈空间),用于存储线程私有的数据,而java 内存模型中规定所有变量都存储在主内存,主内存是共享内存区域(所有线程都可以访问),但线程对变量的操作(读取赋值等)必须在本地内存中进行。
    - 首先要将变量从主内存拷贝的自 己的本地内存空间,然后对变量进行操作,操作完成后再将变量写回主内存,不能直接操作 主内存中的变量,本地内存中存储着主内存中的变量副本拷贝,
    - 本地内存是每个线程的私有数据区域,因此不同的线程间无法访问对方的本地内存,线程间的通信(传值)必须通过主内存来完成

### JMM的抽象(主内存和本地内存)

- java中,所有的实例域、静态域和数组元素都存储在堆内存中。堆内存在线程之间共享
- java线程之间的通信由JMM控制,`JMM决定一个线程对共享变量的写入何时对另一个线程可见`
- 抽象角度来说,JMM定义了线程与主内存之间的抽象关系
  - **线程之间的共享变量存储在主内存中**
  - **每个线程都有一个私有的本地内存,本地内存中存储了该线程以读、写共享变量的副本**

## CPU的术语定义

| 术语       | 英文                   | 术语描述                                                     |
|:---------:|:----------------------:|:------------------------------------------------------------:|
| `内存屏障`  | memory barriers        | **是一组CPU指令,用于实现对内存操作的顺序限制** |
| `缓存行`    | cache line             | **CPU高速缓存中可以分配的最小操作单位。** <br />CPU填写缓存行的时候,会加载整个缓存行,现在CPU需要执行几百次CPU指令 |
| `原子操作`  | atomic operations      | 不可中断的一个或者一系列操作                                 |
| `缓存行填充` | cache line fit         | 当CPU识别到从内存中读取操作时可缓存的,CPU读取整个高速缓存行到到适当的缓存(L1、L2、L3或所有) |
| `缓存命中`   | cache  hit             | 如果进行高速缓存行填充操作的内存位置仍然是上次CPU访问的地址时,CPU存缓存中读取数据,而不是从内存中读 |
| `写命中`     | write hit              | 当CPU将操作数写回到内存缓存的区域时,首先会检查这个缓存的内存地址是否在缓存行中<br />如果存在一个有效的缓存行,那么CPU就将这个操作数写回到缓存,而不是写回到内存 |
| `写缺失`    | Write misses the cache | 一个有效的缓存行被写入到不存在的内存区域                     |
| `CPU流水线`  | CPU pipeline           | CPU中多个不同功能的电路单元组成一条指令处理流水线,然后将一条指令分成多步,然后再由这些电路单元分别执行<br />这样就可以在一个CPU时钟周期内完成一条指令,提高CPU运算速度 |

## 内存屏障类型表

- 内存屏障的作用: `重排序时不能将后面的指令重排序到内存屏障的前面`
- 内存屏障分为两种：
  - `Load Barrier`
    - 读屏障
    - 在指令前插入Load Barrier,可以让高速缓存中的数据失效,强制从新从主内存加载数据
  - `Store Barrier`
    - 写屏障
    - 在指令后插入Store Barrier,能让写入缓存中的最新数据更新写入主内存,让其他线程可见

- **为了保证内存的可见性,java编译器会在生成指令序列的适当位置插入内存屏障指令来禁止特定类型的处理器重排序**
- `StoreLoad Barriers` 是一个“全能型”的屏障,同时具备其他三个屏障的效果。执行这个屏障的开销很大,因为CPU通常需要把写缓冲区的数据全部刷新到内存中
- [Doua Lea列出的常见内存屏障](../html/TheJSR-133Cookbook.html)

| 内存屏障类型                               | 指令示例                 | 说明                                                         |
| ------------------------------------------ | ------------------------ | ------------------------------------------------------------ |
| `LoadLoad Barriers`   | Load1; LoadLoad; Load2   | 在Load2及后续读取操作要读取的数据被访问前,保证Load1要读取的数据被读取完毕 |
| `StoreStore Barriers`| Store1;StoreStore;Store2 | 在Store2及后续写入操作执行前,保证Store1的写入操作对其它处理器可见(刷新到内存) |
| `LoadStore Barriers`  | Load1;LoadStore;Store2   | 在Store2及后续写入操作被刷新到内存前,保证Load1要读取的数据被读取完毕 |
| `StoreLoad Barriers` | Store1;StoreLoad;Load2   | 在Load2及后续所有读取操作执行前,保证Store1的写入对所有处理器可见(刷新到内存)<br />`该内存屏障会让屏障前的所有内存访问指令(存储和装载指令)完成之后,才执行屏障后的内存访问指令` |

## 三大模型结构

- 三大模型是啥?
  - `jvm内存结构`
    - 和JVM的**运行时区域**有关
  - `java内存模型`
    - 和java的**并发编程**有关
  - `java对象模型`
    - 和java对象在虚拟机中的表现形式有关

### java对象模型

- **java对象自身的存储模型**
- jvm会给这个类创建一个 `instanceKlass`,保存在`方法区`,用于表示该java类
- 当通过new 创建一个对象时, jvm会创建一个 `instanceOopDesc` 对象,这个对象中包含了`对象头、实例数据`

![java对象模型](./../image/2.并发编程基础/image-20210828215008140.png)

#### OOP-Klass 模型

- OOP（Ordinary Object Pointer）: **普通对象指针**
- Klass: 用来描述对象实例的具体类型

##### OOP体系

- oops 模块包含多个子模块, 每个子模块对应一个类型, 每一个类型的oop都代表一个在JVM内部使用的特定对象的类型
  - oopDesc是oops模块的共同基类型
  - oopDesc类型又包含`instanceOopDesc` (类实例)、`arrayOopDesc` (数组)等子类类型

- instanceOopDesc主要包含以下的几部分数据
  - `_mark`
  - `_metadata`
  - `不同类型的field`

- 每创建一个新的java对象, 在jvm内部就会相应的创建一个对应类型的oop对象来表示该java对象。而在HotSpot虚拟机中, 对象在内存中包含三块区域:
  - `对象头`
    - **_mark**: 存储对象自身的运行时数据, 如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
    - **metadata**: 类型指针,即对象指向它的类元数据的指针, 虚拟机通过这个指针来确定这个对象是哪个类的实例
  - `实例数据`
    - 保存在oopDesc中定义的各种field中
  - `对齐填充`
  - 其中对象头包含两部分内容：,而实例数据则保存在oopDesc中定义的各种field中

```cpp
// 定义了oops共同基类
typedef class   oopDesc*                            oop;
// 表示一个Java类型实例
typedef class   instanceOopDesc*            instanceOop;
// 表示一个Java方法
typedef class   methodOopDesc*                    methodOop;
// 表示一个Java方法中的不变信息
typedef class   constMethodOopDesc*            constMethodOop;
// 记录性能信息的数据结构
typedef class   methodDataOopDesc*            methodDataOop;
// 定义了数组OOPS的抽象基类
typedef class   arrayOopDesc*                    arrayOop;
// 表示持有一个OOPS数组
typedef class   objArrayOopDesc*            objArrayOop;
// 表示容纳基本类型的数组
typedef class   typeArrayOopDesc*            typeArrayOop;
// 表示在Class文件中描述的常量池
typedef class   constantPoolOopDesc*            constantPoolOop;
// 常量池缓存
typedef class   constantPoolCacheOopDesc*   constantPoolCacheOop;
// 描述一个与Java类对等的C++类
typedef class   klassOopDesc*                    klassOop;
// 表示对象头
typedef class   markOopDesc*                    markOop;
```

##### Klass体系

- Klass类是其他klass类型的父类,并且向jvm提供两个功能:
  - 实现语言层面的java类（在Klass基类中已经实现）
  - 实现java对象的分发功能（由Klass的子类提供虚函数实现）

```cpp
// klassOop的一部分,用来描述语言层的类型
class  Klass;
//在虚拟机层面描述一个Java类
class   instanceKlass;
//专有instantKlass,表示java.lang.Class的Klass
class     instanceMirrorKlass;
//专有instantKlass,表示java.lang.ref.Reference的子类的Klass
class     instanceRefKlass;
//表示methodOop的Klass
class   methodKlass;
//表示constMethodOop的Klass
class   constMethodKlass;
//表示methodDataOop的Klass
class   methodDataKlass;
//作为klass链的端点,klassKlass的Klass就是它自身
class   klassKlass;
//表示instanceKlass的Klass
class     instanceKlassKlass;
//表示arrayKlass的Klass
class     arrayKlassKlass;
//表示objArrayKlass的Klass
class       objArrayKlassKlass;
//表示typeArrayKlass的Klass
class       typeArrayKlassKlass;
//表示array类型的抽象基类
class   arrayKlass;
//表示objArrayOop的Klass
class     objArrayKlass;
//表示typeArrayOop的Klass
class     typeArrayKlass;
//表示constantPoolOop的Klass
class   constantPoolKlass;
//表示constantPoolCacheOop的Klass
class   constantPoolCacheKlass;
```

### java内存模型

> java内存模型是一种抽象的概念,并不真实存在

- jmm 是一组规范,各个 jvm 的实现都需要遵守 jmm 规范,通过这组规范定义了程序中各个变量的访问方式,即关注在虚拟机中**把变量值存储到内存和从内存中取出变量值**这样的底层细节

- 为什么需要设计 jmm?
  - 屏蔽各种硬件和操作系统的内存访问差异,以实现让Java程序在各种平台下都能达到一致的内存访问效果
- JMM作用?
  - **缓存一致性协议,是读写内存数据的规范**

#### 主内存与本地内存

:::caution JMM规定

1. 所有的状态变量都存储在主内存中,同时每个线程也有自己独立的本地内存,本地内存中的变量内容是主内存的拷贝
2. `线程不能直接读写主内存中的变量`,而是只能操作自己本地内存中的变量,然后同步到主内存中
3. 主内存是多个线程之间共享的,但是线程间不共享本地内存。**如果多线程之间需要通信,需要借助主内存中转来完成**

:::

- `主内存`
  - 主要存储的是状态变量,所有线程创建的状态变量都存放在主内存中
    - 这里所说的变量和 java 中的变量并不对等, 包括了共享的类信息、常量、静态变量, 但不包括局部变量和方法参数,因为后者是线程私有的,不会被共享,所以也不会存在竞争问题
  - 由于是共享数据区域,所以在多线程对同一个变量进行访问可能会发生线程安全问题

- `本地内存`
  - **主要存储当前方法的所有本地变量信息,包括主内存中的变量副本拷贝**
  - 本地内存是一个抽象的概念,包含了: `一级缓存、二级缓存、寄存器以及其他的硬件`
  - 每个线程只能访问自己的本地内存,即线程中的本地变量对其它线程是不可见的,就算是两个线程执行的是同一段代码,它们也会各自在自己的本地内存中创建属于当前线程的本地变量,当然也包括了字节码行号指示器、相关 Native 方法的信息
    - 由于本地内存是每个线程的私有数据,线程间无法相互访问本地内存,因此**存储在本地内存的数据不存在线程安全问题**

![主内存与本地内存](./../image/2.并发编程基础/image-20210829134541459.png)

##### 线程通信步骤

:::tip 线程通信步骤

1. 本地内存A和本地内存B中存储着主内存中共享变量M的副本
2. 线程A更新本地内存A中的的值
3. 线程A和线程B需要通信时,线程A会将本地内存A中变更后的数据刷新到 主内存中
4. 线程B到主内存中读取线程A更新后M的值

**JMM 通过控制主内存与每个线程的本地内存之间的交互,来保证内存的可见性**
:::

#### 内存间交互操作

> 关于主内存与工作内存之间具体的交互协议，即**一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节**

jmm 中定义了以下 8 种操作, jvm 在实现的时候必须保证下面提及的每一种操作都是原子的、不可再分的:

1. `lock  [锁定]`
   - 作用于主内存的变量,把一个变量标记为一条线程独占状态

2. `unlock  [解锁]`
   - 作用于主内存的变量,把一个处于锁定状态的变量释放出来,释放后的变量才可以被其他线程锁定

3. `read  [读取]`
   - 作用于主内存的变量,把一个变量值从主内存传输到线程的本地内存中,以便随后的 load 动作使用

4. `load  [装载]`
   - 作用于本地内存的变量,它把 read 操作从主内存中得到的变量值放入本地内存的变量副本中

5. `use  [使用]`
   - 作用于本地内存的变量,把本地内存中的一个变量值传递给执行引擎
6. `assign  [赋值]`
   - 作用于本地内存的变量,它把一个从执行引擎接收到的值赋给本地内存的变量
7. `store  [存储]`
   - 作用于本地内存的变量,把本地内存中的一个变量的值传送到主内存中,以便随后的 write 的操作
8. `write  [写入]`
   - 用于主内存的变量,它把 store 操作从本地内存中的一个变量的的值放入到主内存的变量中

:::danger

1. 如果要把一个共享变量从主内存中复制到本地内存中,就需要按顺序地执行 read 和 load 操作。如果把变量从本地内存中同步到主内存中,就需要按顺序地执行 store 和 write 操作。

2. jmm 只要求上述操作必须按顺序执行,而**没有保证必须是连续执行**,也就是说 read 与 load 之间、store 与 write 之间是可插入其他指令的。
    - 如对主内存中的共享变量 a、b 进行访问时,一种可能出现的顺序是 read a、read b、load b、load a

:::

![内存间交互操作](./../image/2.并发编程基础/image-20210829140002954.png)

##### 交互操作规则

1. `不允许read和load、store和write操作之一单独出现`
   - 即不允许一个变量从主内存读取了,但是本地内存不接受,或者本地内存发起了回写,但是主内存不接受
2. `不允许线程丢弃它的最近的assign操作`
   - 即变量在本地内存中改变之后,必须同步回主内存
3. `不允许一个线程无原因地（没有发生过任何assign操作）把数据从本地内存同步回主内存中`

4. `一个新的状态变量只能在主内存中诞生,不允许在本地内存中直接使用一个未被初始化（load或者assign）的变量`
   - 即就是对一个变量实施use和store操作之前,必须先自行 assign和load操作

5. `一个变量在同一时刻只允许一条线程对其进行lock操作,但lock操作可以被同一线程重复执行多次多次执行lock后,只有执行相同次数的unlock操作,变量才会被解锁`
   - 即一个变量在某个时刻只能被一个线程加锁(独占性),可以重复多次加锁,但也要多次释放锁(可重入性)

6. `如果对一个变量执行lock操作,将会清空本地内存中此变量的值,在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值`
   - 即加锁之后会清空本地内存中共享变量的值,并且在使用该变量之前需要重新从主内存中获取该变量的值

7. `如果一个变量事先没有被lock操作锁定,则不允许对它执行unlock操作。也不允许 unlock一个被其他线程锁定的变量`
   - 即释放锁的前提是需要先加锁,并且线程之间相互隔离,无法操作其他线程
8. `对一个变量执行unlock操作之前,必须先把此变量同步到主内存中(执行store和write操作)`
   - 即释放锁的之前,需要将本地内存中修改后的数据同步到主内存中

上述的操作规则很麻烦, 所以一般通过[Happend-Before 原则](jmm#happens-before) 来思考并发问题,判断并发是否安全。

## 三大特性

jmm 有三大重要的特点:

1. 原子性
2. 有序性
3. 可见性

### 原子性

- 通过 jmm 来直接保证原子性的变量操作包括: `read、load、assign、use、store 和 write`。可以认为 **基本数据类型的访问、读写都是具备原子性的(long 和 double 会有特殊的原则)**

- 如果需要更大范围的原子性保证(方法之间的调用，不同状态变量的使用等), jmm 还提供了 `lock 和 unlock` 来满足这种需求。
  - jvm 通过字节码指令 `monitorenter` 和 `monitorexit` 来隐式的使这两个操作, 这两个字节码指令反映到 java 代码中就是 `synchronized` 关键字

### 重排序

> 重排序是 jmm 有序性的一部分体现

- 有序性的完整体现是: **如果在本线程内观察，所有的操作都是有序的; 但如果在一个线程中观察另一个线程，所有的操作都是无序的**
  - 前者是指: **线程内似乎表现为串行的语义(Within-Thread As-If-Serial Semantics)**
  - 后者是指: **指令重排序、工作内存和主内存同步延迟的情况**

- 在重排序下, 代码的实际执行顺序与代码中的文件顺序不一致,代码指令并不是严格按照代码语句顺序执行的,顺序被改变了。
- 重排序是对代码指令的一种优化,可以提高性能。但是在多线程的情况下可能会引起线程安全问题

![重排序前](./../image/2.并发编程基础/image-20210829131429740.png)

![重排序后](./../image/2.并发编程基础/image-20210829131357182.png)

#### 重排序代码

```java
/**
 * <b>演示重排序</b>
 * @author <a href="mailto:zhuyuliangm@gmail.com">zyl</a>
 */
public class OutOfOrderExecutionDemo {
    private static int x = 0, y =0;
    private static int a = 0, b =0;

    public static void main(String[] args) throws InterruptedException {
        int i = 0;
        for(;;) {
            i++;
            x = 0;
            y = 0;
            a = 0;
            b = 0;
            Thread t1 = new Thread(() -> {
                // a=1 和 x=b没有数据依赖性
                a = 1;
                x = b;
            });
            Thread t2 = new Thread(() -> {
                // b=1 和 y=a没有数据依赖性
                b = 1;
                y = a;
            });
            t1.start();
            t2.start();
            t1.join();
            t2.join();
            String result = "第" + i + "次（" + x + "," + y + ")";
            if (x == 0 && y == 0) {
                System.out.println(result);
                break;
            } else {
                System.out.println(result);
            }
        }
    }
}
```

- 根据线程执行顺序的不同,有以下3种情况
  - a=1; x=b; b=1；y=a;  -> 最终结果： x=0,y=1
  - b=1; y=a; a=1；x=b;  -> 最终结果： x=1,y=0
  - a=1; b=1; x=b；y=a;  -> 最终结果： x=1,y=1
- 实际在运行时出现了 x=0,y=0 的情况,原因就是发生了`重排序`,代码执行顺序可能变成了以下的方式
  - y=a;a=1;x=b;b=1

![重排序](./../image/2.并发编程基础/image-20210829102628760.png)

#### 数据依赖性

- **如果两个操作访问同一个变量,并且这两个操作中有一个是写操作,那么这两个操作之间就存在数据依赖性**
- 编译器和处理器在在重排序时,会遵守数据依赖性,不会改变存在数据依赖关系的两个操作的顺序,因为这种排序会改变执行结果。如果操作之间不存在数据依赖性,就可能出现重排序
- 数据依赖性 **仅针对单个处理器中执行的指令序列和单个线程中执行的操作**，对于多线程的情况,编译器和处理器则无法保证

| 名称  | 代码示例       | 说明                         |
| ----- | -------------- | ---------------------------- |
| 写-读 | a=1;b=a; | 写一个变量后,再读取这个变量 |
| 写-写 | a=1;<br />a=2; | 写一个变量后,再写这个变量   |
| 读-写 | a=b;<br />b=1; | 读一个变量后,再写这个变量   |

#### 重排序类型

在执行程序时,为了提高性能,编译器和处理器常常会对指令进行重排序。分为以下 3 种类型:

1. `编译器优化的重排序`
    - 包括 jvm、jit编译器等
2. `CPU指令级并行的重排序`
    - 现在CPU通过指令级并行技术,将多条指令重叠执行。如果不存在数据依赖性,CPU可以改变语句对应机器指令的执行顺序
3. `内存系统的重排序`
    - 由于CPU使用了缓存和读/写缓冲区,让加载和存储操作看上去是乱序执行
    - 线程A的修改,线程B无法看到 -> 内存可见性

**java源代码到最终执行的指令序列流程**

- 对于步骤1来说,属于编译器重排序
- 对于步骤2、3来说,属于处理器重排序

![alt](./../image/2.并发编程基础/image-20210829132405531.png)

### 可见性

> 可见性的含义就是: `当一个线程修改了共享变量的值时,其他线程能够立即得知这个修改`

#### 可见性代码

- 可见性分析
  - 线程A先运行,线程B在运行 -> a=3,b=3
  - 线程B先运行,线程A在运行 -> a=1,b=2
  - 线程A运行一半,线程B再运行 -> a=3,b=2

- 实际在运行时发现另外的情况:  **a=1,b=3**

  - 注意: 数据 a 和 数据 b 都是共享变量,都存储在主内存中, 所以线程 A 和线程 B 的本地内存中都会持有 a 和 b 的变量副本
  - 原因: 线程A对数据修改后,需要将本地内存中的数据同步到主内存中,此时还没有将修改后的数据 a 同步到主内存中,就开始执行 change 方法,并且数据 B 同步到了主内存中,导致此时看到的b是同步后的正确数据,而a是同步前的错误数据

![alt](./../image/2.并发编程基础/image-20210829151945857.png)

解决方案: 将 a、b 用 volatile 修饰:

```java
public class FieldVisiable {
    private  int a =1 ;
    private  int b =2 ;
    private void change() {
        a = 3;
        b = a;
    }
    private void print() {
        System.out.println("b=" + b + ",a=" + a);
    }

    public static void main(String[] args) {
        while(true) {
            FieldVisiable visiable = new FieldVisiable();
            new Thread(() -> {
                try {
                    Thread.sleep(1);
                    visiable.change();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            },"ThreadA").start();
            new Thread(() -> {
                try {
                    Thread.sleep(1);
                    visiable.print();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            },"ThreadB").start();
        }
    }
}
```

#### 可见性问题分析

- CPU有多级缓存,导致读的数据过期
  - 高速缓存的容量比主内存小,但是速度仅次于寄存器,所以在CPU与主内存中间引入了 Cache层
  - 线程之间的对于共享变量的可见性问题是由 `多缓存 `引起的
  - 如果所有的CPU核心只是用一个缓存,那么也不会有内存可见性问题
  - 每个CPU核心需要将自己需要的数据读取到本地内存中,数据修改也是在本地内存中,然后等待刷新到主内存中。这个就会导致其他CPU核心访问到的是过期的数据

## Happens-Before

- Happens-Before 是 jmm 中定义的两项操作之间的偏序关系。 比如说操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到
  - 这里的 "影响" 包括修改了内存中共享变量的值、发送了消息、调用了方法...

:::caution Happens-Before 说明

在 jmm 中,**如果一个操作执行的结果需要对另一个操作可见**,那么这两个操作之间必须要存在 `happens-before` 关系。两个操作既可以是一个线程之内,也可以是不同线程之间

:::

### 八大原则

1. `顺序性规则`
    - **在一个线程内(多线程情况不适用), 按照控制流顺序(要考虑分支、循环等结构), 书写在前面的操作 Happens-Before 书写在后面的操作**
    - 这种情况下,前面的操作所产生的影响对于后面的操作是可见的

2. `锁操作规则​`
    - **无论是在单线程环境还是多线程环境,一个 unlock 操作 Happens-Before 后面对同一个锁的 lock 操作**
      - 这里必须强调的是`同一个锁`, 而 `后面` 是指时间上的先后
    - 这种情况下, unlock 操作所产生的影响对于同一个锁的 lock 操作是可见的

    ![alt](./../image/2.并发编程基础/image-20210901213220006.png)

3. `volatile变量规则`
    - **对一个 volatile 变量的写操作 Happens-Before 后面对这个 volatile 变量的读操作**
      - 这里的 `后面` 同样是指时间上的先后
    - 这种情况下,  对这个 volatile 变量的写操作所产的影响对于这个 volatile 变量的读是可见的
      - 即: 如果线程 1 写入了 volatile 变量 V(临界资源), 接着线程 2 读取了 V,那么线程 1 写入 V 及之前的写操作都对线程 2 可见 (线程 1 和线程 2 可以是同一个线程)

    ```java
    int a =1 ;
    volatile int b =2 ;
    private void change() {
      a = 3;
      b = a;
    }
    private void print() {
      // b加上了volatile,所以读取b的数据时,一定能看到对volatile变量b 的写操作 -> b = a
      // 并且根据顺序性规则,b=a 一定看得到a=3的操作 -> 读取b时一定能看到a=3的操作
      System.out.println("b=" + b + ",a=" + a);
    }
    ```

4. `线程启动规则`

    - **Thread 对象的 start() 方法 happens-before 此线程中的每一个动作**
    - 对线程 start() 方法的调用所产生的影响对于该该线程的每一个动作都是可见的
      - 即: 假定线程 A 在执行过程中,通过执行 ThreadB.start() 来启动线程 B,那么**在线程 B 开始执行前**, 线程 A 对共享变量的修改对线程 B 中的操作是可见的
      - 注意：线程B启动之后,线程A在对变量修改线程B未必可见

    ```java
    // 主线程在start()之前对a的操作,对于线程B是可见的
    Thread threadB = new Thread(() -> {
      // 主线程调用threadB.start()方法之前,所有对共享变量的操作都是可见的
      // 这里 a=77
    });
    a=77;
    threadB.start();
    ```


5. `线程终止规则`
    - **线程中发生的所有操作 happen—before 对该线程的终止检测(join、isAlive)**
    - 这种情况下, 线程中的所有操作所产生的影响对于调用线程 Thread.join() 或者 Thread.isAlive() 都是可见的
      - 即: 主线程 A 等待子线程 B 完成,当子线程完成后(join方法返回),主线程 A 可以看到子线程 B 的操作

    ```java
    Thread threadB = new Thread(() -> {
      a=1;
    });
    threadB.start();
    threadB.join();
    // 子线程对变量的修改,主线程可以看得到。这里a=1
    ```


6. `线程中断规则`
    - **对于同一个线程, 对线程 interrupt() 的调用 happen—before 该线程检测到中断事件的发生**
    - 这种情况下,线程 interrupt() 方法调用所产生的影响对于该线程检测到中断事件是可见的
      - 即: 线程t1写入的所有变量,调用t2.interrupt(), 被打断的线程t2可以看到t1的全部操作

7. `对象终结规则`
    - **对于同一个对象, 一个对象的初始化完成（构造函数执行结束）happen—before它的 finalize() 方法的开始**
    - 这种情况下, 一个对象的构造方法结束所产生的影响, 对于它的 finalize() 方法开始执行是可见的

8. `传递性`
    - **如果A happens-bfore B,B happens-bfore C ,那么A happens-bfore C**
    - 这种情况下, 操作 A 所产生的所有影响对于操作 C 是可见的

### 示例分析

下面的示例中, 假设存在线程 A 和 B，线程 A 先(时间上的先后) 调用了 setValue(1), 然后线程 B 调用了同一个对象的 getValue()，那么线程 B 收到的返回值是什么?

```java
private int value = 0;
public void setValue(int value) {
 this.value = value;
}
public int getValue() {
 return value;
}
```

1. 由于是多线程的情况，所以顺序性原则不适用;
2. 由于没有加锁,所以锁操作原则不适用
3. 由于共享变量 value 没有使用 volatile, 所以 volatile 原则也不适用
4. 后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系

综上分析: **没有一条 Happens-Before 原则适用,那么尽管线程 A 在时间上先于线程 B 执行, 但依旧是线程不安全的!**

### 工具类的Happens-Before

- 线程安全的容器 get一定能看到在此之前的put等动作
- CountDownLatch
- Semaphore
- CyclicBarrier
- Future
- 线程池
