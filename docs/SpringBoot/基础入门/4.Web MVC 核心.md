---
id: Web MVC 核心
title: Web MVC 核心
cssclasses:
  - wide-page
---
## SpringMvc 架构

### 基础架构-Servlet

![Servlet架构](./image/Mvc/Servlet架构.webp)

Servlet 有以下的特点:

1. 请求模式: 请求/响应式(Request/Response)
2. 会屏蔽网络通信的细节,无需关注底层请求的处理
3. 包含完整的生命周期

Servlet 有以下的职责:

1. 处理请求
2. 资源管理 (连接数据库,处理本地资源...)
3. 视图的渲染

### 核心架构-前端控制器

> SpringMvc 核心架构使用 *前端控制器(FrontController)* 的模式

![前端控制器](./image/Mvc/前端控制器.webp)

- 大致流程
  - 首先客户端发送请求给前端控制器(FrontController)
  - 然后前端控制器将请求"委派"给应用控制器(ApplicationController)处理
  - 应用控制器收到请求后会将请求转发给具体的视图(View),同时还可能会执行某个服务,并将该服务产生的数据给到视图去"渲染"
- SpringMVC 中的具体实现类: `DispatcherServlet`

### SpringMvc 架构

![SpringMvc 架构](./image/Mvc/SpringMvc架构.webp)

## 认识 SpringMvc

### 一般认识

一般情况下,我们需要通过以下步骤来处理一个 http 请求:

1. 实现 Controller
2. 配置 Web MVC 组件
    - ComponentScan
    - RequestMappingHandlerMapping
    - RequestMappingHandlerAdapter
    - InternalResourceViewResolver
3. 部署 DispatcherServlet

首先需要创建一个 Controller:

```java
@Controller  
public class AddressController {  
    /**  
     * 返回一个 View 的字符串名称  
     */  
    @GetMapping("")  
    public String index() {  
        return "index";  
    }  
}
```

然后在 webapp 目录下创建 WEB-INF/jsp 目录,用于存放 jsp 文件,然后新建 `WEB-INF/app-context.xml` 文件,也就是 MVC 的应用上下文配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
       xmlns:context="http://www.springframework.org/schema/context"  
       xsi:schemaLocation="  
        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd">  
  
    <!--配置组件扫描-->  
    <context:component-scan base-package="com.pacos"/>  
  
    <!--配置 RequestMappingHandler-->    <bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/>  
    <bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/>  
  
    <!--配置视图解析器:jsp-->  
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">  
        <!-- 相对于 webapp 目录下-->  
        <property name="prefix" value="/WEB-INF/jsp/"/>  
        <property name="suffix" value=".jsp"/>  
    </bean>  
</beans>
```

最后在 webapp 下新建 web.xml, 来配置 `DispatcherServlert`

```xml
<web-app>
    <servlet>
        <servlet-name>app</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/app-context.xml</param-value>
        </init-param>
    </servlet>
    <servlet-mapping>
        <servlet-name>app</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

### 重新认识

#### 核心组件

1. 处理器管理
    - 映射: `HandlerMapping`
    - 适配器: `HandlerAdapter`
    - 执行链: `HandlerExecutionChain`
2. 页面渲染
    - 视图解析: `ViewResolver`
    - 国际化: `LocaleResolver`、`LocalContextResolver`
    - 个性化: `ThemeResolver`
3. 异常处理
    - 异常解析: `HandlerExceptionResolver`

下面是组件的说明:

1. [HandlerMapping](https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.html#mvc-handlermapping)
   - 请求(Request) 与 处理器(Handler)和拦截器 (HandlerInterceptor) 的映射列表，其映射关系基于不同的 `HandlerMapping` 有不同的实现细节
     - Handler 就是自定义的处理方法
   - 有两种主要的 HandlerMapping 实现:
     - `RequestMappingHandlerMapping` :支持标注 `@RequestMapping` 的方法
     - SimpleUrlHandlerMapping:  维护精确的URI 路径与处理器的映射
2. HandlerAdapter
   - 帮助 `DispatcherServlet` 调用请求处理器(Handler), 无需关注其中实际的调用细节。比如，调用注解实现的 Controller 需要解析其关联的注解
   - **HandlerAdapter 的主要目的是为了屏蔽与 `DispatcherServlet` 之间的诸多细节**
3. [HandlerExceptionResolver](https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers)
   - 解析异常相关
   - 可能策略是将异常处理映射到其他处理器(Handlers), 或到某个 HTML 错误页面,或者其他
4. [ViewResolver](https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.html#mvc-viewresolver)
   - 从处理器(Handler)返回字符类型的逻辑视图名称解析出实际的 `View` 对象,该对象将渲染后的内容输出到HTTP 响应中
5. LocaleResolver、LocaleContextResolver
   - 从客户端解析出 `Locale`, 为其实现国际化视图
6. [MultipartResolver](https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.html#mvc-multipart)
   - 解析多部分请求(如 Web 浏览器文件上传)的抽象实现

组件之间的交互在 `DispatcherServlet#doDispatch`,其中的大致流程如下:

![交互流程](./image/Mvc/交互流程.webp)

#### 注解驱动

> 注解驱动下, 可以通过以下的注解、类来拓展 SpringMvc,其中很重要的就是 `@EnableWebMvc`

1. 配置注解: `@Configuration`
2. 组件激活: `@EnableWebMvc`
    - 该注解会注册一些核心组件,比如*RequestMappingHandlerMapping*、*RequestMappingHandlerAdapter*...
1. 自定义组件: 实现 `WebMvcConfigurer` 接口中的目标方法,比如 *addInterceptors*

下面是 @EnableWebMvc 注解的基本处理功能,它 *@Import* 了 `DelegatingWebMvcConfiguration` 及其父类 `WebMvcConfigurationSupport`

```java
// @EnableWebMvc 注解
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc {
  
}

// DelegatingWebMvcConfiguration 类
@Bean
public RequestMappingHandlerMapping requestMappingHandlerMapping(...) {
  // ... [注册 RequestMappingHandlerMapping]
}

@Bean
@Nullable
public HandlerMapping viewControllerHandlerMapping() {
  // ... [注册 HandlerMapping]
}

@Bean
public RequestMappingHandlerAdapter requestMappingHandlerAdapter(...){
  // ... [注册 RequestMappingHandlerAdapter]
}

// ...

// WebMvcConfigurationSupport 类
@Bean
public HttpRequestHandlerAdapter httpRequestHandlerAdapter() {
  return new HttpRequestHandlerAdapter();
}

@Bean
public HandlerExceptionResolver handlerExceptionResolver(...) {
  // ...
}

// ...
```

下面使用注解的方式修改[代码](Web%20MVC%20核心#一般认识):

首先定义一个 SpringMvc 的配置注解类,**@EnableWebMvc 默认 注册的 ViewResolver 没有配置 prefix 和 suffix,所以需要调整**:

```java
/**
 * SpringMvc 的配置注解类
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 *
 * @see Configuration
 * @see EnableWebMvc
 */

@Configuration
@EnableWebMvc
public class WebMvcConfig {
    @Bean
    public ViewResolver viewResolver() {
        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
        viewResolver.setPrefix("/WEB-INF/jsp/");
        viewResolver.setSuffix(".jsp");
        return viewResolver;
    }
}
```

然后在 WEB-INF 下 的 SpringMvc 应用上下文配置文件中,配置启用包扫描(也会启用注解功能)

```xml
<!--配置组件扫描-->
<context:component-scan base-package="com.pacos"/>
```

#### 其他注解

SpringMvc 还有其他的一些注解:

1. 模型属性: `@ModelAttribute`
2. 请求头: `@RequestHeader`
3. Cookie: `@CookieValue`
4. 参数校验: `@Valid、@Validated` ,这个依赖于 Spring 本身的数据校验绑定
5. 异常处理: `@ExceptionHandler`
   - 对应的 Resolver:  `ExceptionHandlerExceptionResolver`
   - 在 [WebMvcConfigurationSupport](Web%20MVC%20核心#注解驱动) 中进行注册
6. 切面通知: `@ControllerAdvice`

SpringMvc 中, 通常会注册 `RequestMappingHandlerAdapter`,它是[核心组件-HandlerAdapter 接口](Web%20MVC%20核心#核心组件) 的实现类,它还实现了 *InitializingBean*,所以在 它进行初始化的时候的时候会执行 *afterPropertiesSet* 方法,其中会有几个重要方法:

1. **getDefaultArgumentResolvers**: 返回处理方法参数的 Resolver,比如处理 @RequestParam、@RequestBody、@RequestHeader…
2. **getDefaultInitBinderArgumentResolvers**: 返回处理方法参数绑定的 Resolver,比如处理  @RequestParam、@PathVariable …
3. **getDefaultReturnValueHandlers**: 返回处理返回值的 Handler,比如处理@ResponseBody、@ModelAttribute、@RequestResponseBody…

```java

	@Override
	public void afterPropertiesSet() {
		// Do this first, it may add ResponseBody advice beans
		initControllerAdviceCache();

		if (this.argumentResolvers == null) {
      // 返回处理方法参数的 Resolver
			List<HandlerMethodArgumentResolver> resolvers = getDefaultArgumentResolvers();
			this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
		}
		if (this.initBinderArgumentResolvers == null) {
      // 返回处理方法参数绑定的 Resolver
			List<HandlerMethodArgumentResolver> resolvers = getDefaultInitBinderArgumentResolvers();
			this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
		}
		if (this.returnValueHandlers == null) {
      // 返回处理返回值的 Handler
			List<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();
			this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);
		}
	}
```

### SpringMvc 的启动

> 这里的 Servlet 容器以 Tomcat 为例

在 Servlet3.0 之前,我们需要定义 `web.xml`,比如下面的:

```xml
<web-app>
	<!-- 
			配置contextConfigLocation 初始化参数：指定Spring IoC容器配置文件路径
 	-->
  <context-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>/WEB-INF/applicationContext.xml</param-value>
  </context-param>

  <!-- 配置 ContextLoaderListerner：Spring MVC在Web容器中的启动类，负责Spring IoC容器在Web上下文中的初始化 -->
  <listener>
      <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>

  <servlet>
      <servlet-name>court</servlet-name>
      <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
      <init-param>
          <!-- court-servlet.xml：定义WebAppliactionContext上下文中的bean -->
          <param-name>contextConfigLocation</param-name>
          <param-value>classpath*:court-servlet.xml</param-value>
      </init-param>
      <load-on-startup>0</load-on-startup>
  </servlet>

  <servlet-mapping>
      <servlet-name>court</servlet-name>
      <url-pattern>/</url-pattern>
  </servlet-mapping>
</web-app>
```

在 上述的 web.xml 配置文件中,有两个主要的配置:

1. `ContextLoaderListener` : SpringMvc 的 Web 容器中的启动类,并且负责 Spring IOC 容器在 Web 上下文中的初始化
2. `DispatcherServlet`: 前端控制器,主要用于接受的 HTTP 请求和转发 HTTP 请求

#### Tomcat 的启动

Tomcat 使用的 web.xml 有下面的节点(按照解析顺序)

- `context-param`: 为 ServletContext 提供键值对，即应用程序上下文信息
- `listener`
- `filter`
- `servlet`
  - 用于定义 Servlet 的名称 和 类的限定名
  - servlet 的初始化顺序按照 `load-on-startup` 元素指定的值
    - 如果值为正数或零，则按照从小到大的顺序初始化
    - 如果值为负数或未定义，则在第一次请求时初始化
  - servlet-mapping 用于访问指定 servlet 的 URL, 且 servlet-mapping 必须出现在 servlet 之后

Tomcat 大致流程解析流程:

1. Tomcat 启动的时候会解析 `context-param`,然后创建 `ServletContext` 对象,并且将 context-param 转为键值对赋给 ServletContext
2. 然后解析 `listener` 标签,并且根据 listener-class 创建监听器实例
   - 如果监听器类实现了 `ServletContextListener` 接口,那么它的 `contextInitialized(ServletContextEvent sce)` 和 `contextDestroyed(ServletContextEvent sce)`会在  ServletContext 对象创建和销毁时被调用
   - Spring 的 `ContextLoaderListener` 就实现了  ServletContextListener 接口

#### 上下文的层次性

> **关于 DispacherServlet、WebApplicationContext、ServletContext 的关系?**

首先需要了解 SpringMvc 的启动过程:

1. 首先对于一个 Web 应用来说, 我们会将其部署在 Tomcat 这种 Servlet 容器中, 容器提供了一个全局的上下文环境,这个上下文环境就是 `ServletContext`, 它为 SpringIOC 容器提供一个宿主环境

2. 然后在 Tomcat 启动的时候,会触发容器初始化事件, 配置的 `ContextLoaderListener` 会监听到这个事件,然后会触发 `contextInitialized` 方法

    - SpringMvc 会创建一个 Spring Web 应用上下文(*根上下文*): `WebApplicationContext`, 它有一个实现类: `XmlWebApplicationContext`

    - 在创建 WebApplicationContext 的时候,会通过 `ServletContext` 获取到 web.xml 中的 context-param 的值 [ param-name= contextConfigLocation], 然后在读取到值之后,就会将其设置给 Spring Web 应用上下文
    - 当 Spring Web 应用上下文初始化完成后, 会将器存储在 `ServletContext` 中

3. 其次 ContextLoaderListener 监听器初始化完成之后, Tomcat 会开始初始化 web.xml 中配置的 Servlet,比如 `DispatcherServlet`:

    - DispatcherServlet 就是前端控制器,用于转发、匹配、处理每一个 Servlet 请求
    - **DispatcherServlet 上下文在初始化的时候会建立自己的 应用上下文**
      - 首先会根据 *根上下文(WebApplicationContext)* 作为自己的 parent-context
      - 然后再利用 parent-context 初始化自己持有的上下文,初始化的过程在 `initStrategies` 中
    - DispatcherServlet 初始化完成后,SpringMvc 会**以 Servlet 的名称作为 *key*, 也将其存储在 `ServletContext`中**, 这样每个 Servlet 都会有自己的 ApplicationContext 上下文

```java
// ContextLoaderListener
public class ContextLoaderListener extends ContextLoader implements ServletContextListener {
  public ContextLoaderListener() {
  }
  public ContextLoaderListener(WebApplicationContext context) {
      super(context);
  }
  // highlight-start
  public void contextInitialized(ServletContextEvent event) {
    this.initWebApplicationContext(event.getServletContext());
  }
  public void contextDestroyed(ServletContextEvent event) {
    this.closeWebApplicationContext(event.getServletContext());
    ContextCleanupListener.cleanupAttributes(event.getServletContext());
  }
  // highlight-end
}

// 初始化 WebApplicationContext
public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {
  try {
    if (this.context == null) {
       // highlight-start
      // 创建 WebApplicationContext
      this.context = createWebApplicationContext(servletContext);
       // highlight-end
    }
    if (this.context instanceof ConfigurableWebApplicationContext) {
      // Servlet 自己的上下文
      ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;
      if (!cwac.isActive()) {
        if (cwac.getParent() == null) {
          ApplicationContext parent = loadParentContext(servletContext);
          // highlight-start
          cwac.setParent(parent);
          // highlight-end
        }
        // 配置和刷新 WebApplicationContext
        configureAndRefreshWebApplicationContext(cwac, servletContext);
      }
    }
    // 将 WebApplicationContext 存储到 ServletContext
    servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);
    ClassLoader ccl = Thread.currentThread().getContextClassLoader();
    if (ccl == ContextLoader.class.getClassLoader()) {
      currentContext = this.context;
    }
    else if (ccl != null) {
      currentContextPerThread.put(ccl, this.context);
    }
    return this.context;
  }
  catch (RuntimeException | Error ex) {
    // ...
  }
}

// 创建 WebApplicationContext
protected WebApplicationContext createWebApplicationContext(ServletContext sc) {
  Class<?> contextClass = determineContextClass(sc);
  return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);
}

// 探测 ContextClass 类
protected Class<?> determineContextClass(ServletContext servletContext) {
  String contextClassName = servletContext.getInitParameter("contextClass");
  if (contextClassName != null) {
    return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());
  }
  else {
    // highlight-start
    // 这一步读取返回 XmlWebApplicationContext
    contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());
    // 默认创建 XmlWebApplicationContext
    return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());
    // highlight-end    
  }
}
```

:::tip WebApplicationContext 和 DispatcherServlet 上下文的区别

1. WebApplicationContext 主要用于整个 Web 应用共享一些组件,而 DispatcherServlet 创建的 ApplicationContext 主要用于该 Servlet 相关的组件,比如 Controller、ViewResolver
2. **对于作用范围而言，在 DispatcherServlet 中可以引用由 ContextLoaderListener 所创建的ApplicationContext, 而反过来不行**
3. 这两个 ApplicationContext 都通过 **ServletContext#setAttribute** 放在 ServletContext 中,但是 WebApplicationContext 会先存储进去,并且 DispatcherServlet 上下文会将 WebApplicationContext 作为自己的 parent-context

:::

#### 自动装配

> 自动装配依赖于 Servlet 3.0+, 在 Servlet 3.0 之后可以使用注解,比如 [@WebSevlet](基础知识#注册servlet组件注解)

Servlet 3.0+ 规范中提出 一个 **容器初始化器**: `ServletContainerInitializer`,用于**在容器启动阶段,通过编程的方式注册 WEB 三大组件(Listener、Servlet、Filter),以取代 web.xml 配置**。

ServletContainerInitializer 是基于 java *SPI* 机制的,Servlet 容器在启动的时候,通过 *SPI* 获取所有 ServletContainerInitializer 的实现类,然后执行其 `onStartUp()` 方法

根据 SPI 的加载机制, 相应的 SPI 文件会放在 META-INF/service 目录下,SpringMvc 就实现了 ServletContainerInitializer

```txt title=spring-web-5.2.2.RELEASE.jar!/META-INF/services/javax.servlet.ServletContainerInitializer
org.springframework.web.SpringServletContainerInitializer
```

Spring 中的实现类是:  `SpringServletContainerInitializer`,并且 SpringMvc 还提供了自己的 SPI: `WebApplicationInitializer`,有两个常见的实现类:

1. 基于编程驱动: `AbstractDispatcherServletInitializer`
2. 基于注解驱动: `AbstractAnnotationConfigDispatcherServletInitializer`

对于 Servlet 容器来说,会调用 `SpringServletContainerInitializer#onStartUp()`,将 SpringMvc 添加到 Servlet 容器的生命周期中,并且 Spring 提供的 SPI(WebApplicationInitializer) 可以自定义初始化逻辑,不需要再去实现 ServletContainerInitializer 接口
