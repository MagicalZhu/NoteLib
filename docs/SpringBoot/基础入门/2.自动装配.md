---
id: 自动装配
title: 自动装配
cssclasses:
  - wide-page
---

## Spring 手动装载

Spring 提供以下的方式进行配置元信息的手动装载:

1. Spring 模式注解

### 模式注解

> 利用 Spring 注解来装载 Spring 配置元信息,[详细参见 Spring 配置元信息](../../Spring/Spring编程思想/配置元信息#模式注解) 以及[模式注解](../../Spring/Spring编程思想/注解处理#模式注解stereotype-annotations)

- 一种用于声明在应用中扮演 "组件" 角色的注解
  - `@Component` : 通用组件模式注解
  - `@Service` : 服务模式注解
  - `@Controller` : Web 控制器模式注解
  - `@Repository` : 数据仓储模式注解
  - `@Configuration` : 配置类模式注解
- 装配 : @ComponentScan [对应 XML 的 < context:component-scan/>]

#### 组件扫描(注解)

通过 @ComponentScan 注解可以扫描指定 basepackage 下的组件:

```java
@ComponentScan(basePackages = {"com.pacos.components"})
public class BootDemo {
	//...
}
```

#### 组件扫描(XML)

除了使用注解,还可以通过 XML 配置的方式扫描指定 basepackage 下的组件,需要如下的步骤:

1. 开启注解扫描
2. 设置组件扫描的 basepackage

```xml
  <!--激活注解驱动-->
  <context:annotation-config/>
  <!--设置扫描的 base-package-->
  <context:component-scan base-package="com.pacos.components"/>
```

### @Enable 模块

> 详细可以参看 [Spring 核心编程的 @Enable 模块](./../Spring/Spring编程思想/注解处理#enable-模块驱动)

- 具有相同领域的功能组件集合,组合形成一个独立的单元。比如 : @EnableWebMvc , @EnableAutoConfiguration…
- 实现方式:
  - 注解方式: `@Import`
  - 编程方式:
    - `ImportSelector`: 返回需要注册的组件的全类名数组
    - `ImportBeanDefinitionRegistrar`

@Enable 模块示例:

| 框架实现         | @Enable 注解模块                 | 激活模块            |
| ---------------- | -------------------------------- | ------------------- |
| Spring Framework | `@EnableWebMvc`                  | Web MVC 模块        |
|                  | `@EnableTransactionManagement`   | 事务管理模块        |
|                  | `@EnableCaching`                 | Caching 模块        |
|                  | `@EnableMBeanExport`             | JMX 模块            |
|                  | `@EnableAsync`                   | 异步处理模块        |
|                  | `@EnableWebFlux`                 | Web Flux 模块       |
|                  | `@EnableAspectJAutoProxy`        | AspectJ 代理模块    |
| Spring Boot      | `@EnableAutoConfiguration`       | 自动装配模块        |
|                  | `@EnableManagementContext`       | Actuator 管理模块   |
|                  | `@EnableConfigurationProperties` | 配置属性绑定模块    |
|                  | `@EnableOAuth2Sso`               | OAuth2 单点登录模块 |
| Spring Cloud     | `@EnableEurekaServer`            | Eureka服务器模块    |
|                  | `@EnableConfigServer`            | 配置服务器模块      |
|                  | `@EnableFeignClients`            | Feign客户端模块     |
|                  | `@EnableZuulProxy`               | 服务网关 Zuul 模块  |
|                  | `@EnableCircuitBreaker`          | 服务熔断模块        |

#### 注解方式

通过 @Import 注解导入目标配置类:

```java
// 定义配置类
public class AddressConfig {
}


// 通过 @Import 注解导入配置元信息
@Import(value = {AddressConfig.class})
public class BootDemo {
  public static void main(String[] args) {
    // ...
  }
}
```

#### 接口方式

操作上和注解方式区别不大,不过将配置类修改为 *ImportSelector* 接口的实现类

### 条件装配

> 详细参看 [Spring 核心条件注解](../../Spring/Spring编程思想/注解处理#条件注解)

- Bean装配的前置判断, 按照一定的条件判断后, 将满足条件的bean 注册到 IOC容器中
- 比如
  - `@Profile` : 配置化条件装配,Spring 4 后@Profile 基于@Conditional 实现
  - `@Conditional` : 编程条件装配
- 实现方式
  - **Profile 注解**
  - **Conditional 编程**

#### 注解

首先定义两个组件,并且使用 Profile 标记:

```java
@Profile({"Linux"})
@Service
public class LinuxEchoService implements EchoService{
    @Override
    public void say() {
        System.out.println("This is Linux...");
    }
}

@Profile({"Mac"})
@Service
public class MacEchoService implements EchoService{
    @Override
    public void say() {
        System.out.println("This is MacOs...");
    }
}
```

然后在运行 SpringBoot 应用之前设置激活的 Profile:

```java
@SpringBootApplication(
        // 指定扫描路径
        scanBasePackages = {"com.ConditionaLoad"}
)
public class ConditionalDemo {
    public static void main(String[] args) {
        SpringApplicationBuilder application = new SpringApplicationBuilder(ConditionalDemo.class);
        ConfigurableApplicationContext context = application.web(WebApplicationType.NONE)
                // 设置激活的 profile
                .profiles("Mac")
                .run(args);

        EchoService bean = context.getBean(EchoService.class);
 				// out: This is MacOs...
      	bean.say();
        context.close();
    }
}
```

#### 编程

首先定义一个条件配置类,实现 Conditional 接口:

```java
public class ConditionOnPropertyConfig implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        Map<String, Object> attributes = metadata.getAnnotationAttributes("ConditionOnProperty");
        String name = String.valueOf(attributes.get("name"));
        String value = String.valueOf(attributes.get("value"));

        if (StringUtils.hasText(name) && name.equals("Sys") && StringUtils.hasText(value) && value.equals("Linux")) {
            return true;
        }
        return false;
    }
}
```

然后定义一个注解,使用 `@Conditional` 作为元注解,将配置类添加到 @Conditional 注解中,然后在需要该条件判断的组件上标注该注解即可:

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(value = { ConditionOnPropertyConfig.class })
public @interface ConditionOnProperty {
    // 属性名
    String name();
    // 属性值
    String value();
}
```

## SpringBoot 自动装配

- 底层装配技术

  - Spring 模式注解装配
  - Spring @Enable 模块装配
  - Spring 条件装配
  - Spring 工厂加载机制
    - 抽象类： `SpringFactoriesLoader`
    - 配置资源： `META-INF/spring.factories`

- 比如 :参看 META-INF/spring.factories

- 实现方法

  1. 激活自动装配: `@EnableAutoConfiguration`
     - 该注解会导入 spring.factories 中 EnableAutoConfiguration 对应的 class
  
  2. 实现自动装配: `XXXAutoConfiguration`
  
  3. 配置自动装配实现: `META-INF/spring.factories`
     - 在 Properties 中配置 `EnableAutoConfiguration` 对应的值

### 使用示例

首先定义一个自动装配类, 并在该类上标注 @EnableAutoConfiguration 注解

```java
// 配置类
@Configuration
// 这里还可以通过 @Enable 模块、@Import、@Conditional 等注解进行额外的处理
public class PacosAutoConfiguration {
    @Bean
    public User user() {
        return new User("pacos", 28);
    }
}
```

然后在 classpath 下创建一个 /META-INF/spring.factories 文件,文件中配置 *key = EnableAutoConfiguration* 的属性:

```ini
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.AutoConfiguration.PacosAutoConfiguration
```

最后在引导类中进行测试:

```java
@SpringBootApplication
public class AutoConfigurationDemo {
    public static void main(String[] args) {
        SpringApplicationBuilder builder = new SpringApplicationBuilder(AutoConfigurationDemo.class);
        ConfigurableApplicationContext context = builder.web(WebApplicationType.NONE).run(args);
        User bean = context.getBean(User.class);
        // out: User{name='pacos', age=28}
        System.out.println(bean);
    }
}
```
