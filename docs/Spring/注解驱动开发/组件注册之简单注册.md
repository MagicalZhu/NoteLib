---
id: 组件注册
title: 组件注册
---

## @Configuration和@Bean

- **标注在类上**
- **作用 : 可以`向IOC 容器中注册组件 ( 代替之前的配置文件 `)**
- **注解的含义?**
   - `@Configuration`
      - **标注在配置类上, 表明这是一个配置类**
      - 等同于之前Spring的配置文件
   - `@Bean`
      - **标注在获取Bean 对象的方法上 , 用于给容器注册一个Bean**
      - 等同于Spring 配置文件中的 `<bean id="xxx" class="xxxx"> </bean>`
         - `返回值类型` : 就是bean 的类型class
         - `方法名` : 就是bean 的唯一标识id

:::info 注解使用步骤?
1. **定义一个配置类 , 并且使用 @Configuration 注解在该类上进行标注**

2. **定义一个获取Bean对象的方法,并且使用 @Bean 对该方法进行标注**

3. **使用AnnotationConfigApplicationContext 指定配置类的位置,并获取bean对象**
    - 可以通过 `annotationConfigApplicationContext.getBeanDefinitionNames()` 获取IOC容器中所有注册的bean

![](./Image/@Configuration和@Bean.png)

:::



## @ComponentScan(包扫描注册)

- **标注在配置类上面**

- **作用: 通过包扫描的方式向 IOC中注入Bean**
  - 相当于配置文件中的 `<context:component-scan>`, 以及包含排除bean 的 子节点
   
- **注解的属性?**
  
   - `value` :   指定要扫描的包
    
   - `excludeFilters`  : 扫描时 指定需要排除的bean
    
   - 是一个 `@Filter 注解的数组` , 包含以下属性
     
      - `type` : 按什么方式进行排除,**默认是 Annotation**
      - `classes` : 哪些类型的需要排除 (比如可以指定不扫描带有 @Controller注解的类)
    
   - `includeFilters`    : 需要扫描的包
    
   - `useDefaultFilters`  : 是否使用默认过滤,使用@includeFilters 时必须使用这个注解

:::info 使用步骤

1. 在配置类上 标注上 @ComponentScan 注解 , 通过 value 属性指定要扫描的包
2. 可以通过 excludeFilters /  includeFilters  属性指定扫描规则

![](./Image/@ComponentScan.png)

:::



### @Filter注解详解

- **作用 : @Filter 注解 可以在包扫描时, 指定扫描规则**

- **@Filter的type属性**
   - `FilterType.Annotation`  :  按照注解过滤
   - `FilterType.Assignable_Type` : 按照指定的类过滤
   - `FilterType.Custom`       : 按照自定义规则
   - `FilterType.Regex` : 使用正则表达式过滤
   - `FilterType.AspectJ`    : 使用AspectJ表达式过滤
- **如何自定义过滤规则?**
   1. **实现 TypeFilter接口**

   2. 重写 `match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)`方法
      - `metadataReader`  : 当前扫描到的类的信息

         - `metadataReader.getAnnotationMetadata()` : 获取当前类的注解信息

         - `metadataReader.getClassMetadata()`      : 获取当前类的类信息

         - `metadataReader.getResource()`: 获取当前类的资源信息

       - `metadataReaderFactory`  : 可以获取其他任何类的信息
   3. **在@Filter 注解中使用**
      - type 就是  FilterType.Custom 
      - classes 就是自定义规则类

:::info 代码实现

**1.自定义TypeFilter实现类**

![](./Image/@Filter自定义规则类.png)

<br/>

**2. 自定义TypeFilter实现类**
![](./Image/@Filter使用自定义规则类.png)

:::


### @Lazy

- **标注在 获取Bean 对象的方法上面**
- **作用 : 针对@Scope 作用域是 singleton 的单实例bean , 可以在容器初始化时不创建对象,而是在第一次获取这个bean 的时候再去创建**

![](./Image/@Lazy.png)


## @Conditional(按条件注册)

### 概述

- 标注在`类`或者`方法`上面 ( **标注在类上可以统一判断**)

- **作用: 按照一定的条件判断后, 将满足条件的bean 注册到 IOC容器中**

- **相关属性**
  - `value`	: 指定条件判断类

:::info 使用步骤

1. 定义条件判断类,并且实现Condition接口

2. 重写 `matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)` 方法
    - `conditionContext` : 判断条件可以使用的上下文,包括系统环境、类加载器等 
      - conditionContext.getBeanFactory() : 获取IOC使用的BeanFactory
      - conditionContext.getClassLoader()	: 获取类加载器
      - conditionContext.getEnvironment()	: 获取系统环境(包括JVM的信息)
      - context.getRegistry()             :  获取Bean定义的注册类
    - `annotatedTypeMetadata` 	:  注解信息

3. 在类或者方法上标注@Conditional 注解,同时指定第一步的条件判断类

:::

### 代码实现

**1. 定义条件判断类**

> **实现Condition接口,实现 matches() 方法**, 返回 true 的会被扫描注册进IOC容器中

```java
/**
 * 自定义条件判断类
 *  - 实现Condition接口中的 matches方法
 *  - ConditionContext : 判断条件可以使用的环境
 *      -> conditionContext.getBeanFactory()	: 获取IOC使用的BeanFactory
 *      -> conditionContext.getClassLoader()	: 获取类加载器
 *      -> conditionContext.getEnvironment()	: 获取系统环境(包括JVM的信息)
 *      -> context.getRegistry()                : 获取Bean定义的注册类
 *  - AnnotatedTypeMetadata : 注解信息
 */
public class MyCondition implements Condition 
{
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata)
    {
        // 获取IOC使用的BeanFactory
        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
        // 获取类加载器
        ClassLoader classLoader = context.getClassLoader();
        // 获取系统环境(包括JVM的信息)
        Environment environment =  context.getEnvironment();

        // 获取Bean定义的注册类
        BeanDefinitionRegistry registry = context.getRegistry();
        Arrays.stream(registry.getBeanDefinitionNames()).forEach(System.out::println);
        System.out.println("------");
        // 获取注解信息
        if (metadata instanceof ClassMetadata) {
            ClassMetadata classMetadata = (ClassMetadata) metadata;
            System.out.println("className-->"+classMetadata.getClassName());
        }
        if(metadata instanceof MethodMetadata){
            MethodMetadata methodMetadata = (MethodMetadata) metadata;
            System.out.println("methodName-->"+methodMetadata.getMethodName());
        }
        return true;
    }
}
```



**2. 使用@Conditional注解**

```java
 @Conditional({MyCondition.class})
 @Bean(value = "person2")
 public Person person2()
 {
     System.out.println("Create person2...");
     return new Person("person2",25);
 }
```



## @Import

**通过@Import 快速的给容器中注册一个组件**

1. @Import( {要导入的组件} ), 容器会自动注册这个组件,id默认是全类名

2. 自定义导入选择器,实现ImportSelector接口 , 返回需要注册的组件的全类名数组

3. 自定义注册类 , 实现ImportBeanDefinitionRegistrar接口 , 直接向 IOC中注册组件

## 其他针对Bean对象的注解

1. `@Scope`
2. `@Lazy`

### @Scope

- **标注在 获取Bean 对象的方法上面**
- **作用 : 指定组件的作用域 ( 默认IOC容器中的组件都是单例的! )**
  -  相当于 `<bean>` 的 `scope` 属性
- 通过 @Scope 的 `value` 属性**指定作用域**有两个可选值

   - `singleton    `
     - 单例的 , 默认值 
     - **初始化IOC容器时 , 就会创建bean 的实例**
   - `prototype`
     - 原型的 ( 多实例的! )
     - **每次从IOC容器中获取bean对象时 , 都会创建bean的实例**

- **使用方式?**
  - 在获取Bean对象的方法上面进行标注 @Scope 注解

**代码示例:**

```java
/**
  @Scope 注解的使用
*/
@Configuration
public class MyConfig2 {

    //@Scope(value = "prototype")  
    //prototype : 原型的,每次从IOC容器中获取bean对象时,都会创建bean的实例
    //singleton  : 单例的,初始化IOC容器时,就会创建bean的实例,然后使用
    @Scope(value = "singleton")   
    @Bean(value = "person")
    public Person person(){
        return new Person("Lucy",25);
    }
}
```
