---
id: AOP设计与实现
title: AOP设计与实现
cssClass: wide-page
---

## 整体设计

1. `Joinpoint`
2. `Pointcut`
3. Advice 执行动作: `Advice`
4. Advice 容器: `Advisor`
5. Introduction: `IntroductionInfo`
6. 代理对象创建基础类: `ProxyCreatorSupport`
7. 代理工厂: `ProxyFactory、ProxyFactoryBean`
8. AopProxyFactory 配置管理器: `AdvisedSupport`
9. IOC 容器自动代理抽象: `AbstractAutoProxyCreator`

## 连接点(Joinpoint)

Joinpoint 的子接口: Interceptor 的执行上下文 `Invocation` :

- 方法拦截子接口: `MethodInvocation`
  - 基于反射的实现: `ReflectiveMethodInvocation`
  - 基于 CGLIB的实现: `CglibMethodInvocation`
- ~~构造器拦截子接口: ConstructorInvocation~~

类层次结构图:

```ini
├── Joinpoint
│   └── Invocation
│     └── MethodInvocation
│       └── ProxyMethodInvocation
│         └── ReflectiveMethodInvocation
│           └── CglibMethodInvocation
```

我们查看下 `Joinpoint` 接口,主要有下面 3 个方法

1. `proceed()` : 动作的执行,一般指的是方法
2. `getThis()`: 包含被执行方法的对象
3. `getStaticPart()`: 返回静态部分,对 Spring AOP 来说就是返回方法 Method 对象

```java
public interface Joinpoint {
  Object proceed() throws Throwable;  
  Object getThis();  
  AccessibleObject getStaticPart();  
}
```

然后观察 `Invocation` 和它的子接口 `MethodInvocation`:

1. `getArguments()`: 返回方法的参数
2. `getMethod()` : 返回方法对象 Method(和 *getStaticPart* 返回的是一样的结果)

```java
// Invocation
public interface Invocation extends Joinpoint {  
  Object[] getArguments();
}

// MethodInvocation
public interface MethodInvocation extends Invocation {  
  Method getMethod();  
}
```

## 连接点条件(Pointcut)

### 常规实现

> 主要是负责一个判断

在 [AOP 基础](./AOP基础#api-编程) 中层概述过:

- 核心组件:
  1. 类过滤器: `ClassFilter`
  2. 方法过滤器: `MethodMatcher`

```java
public interface Pointcut {
  ClassFilter getClassFilter();  
  MethodMatcher getMethodMatcher();  
}
```

查看下 `ClassFilter` 和 `MethodMatcher` 接口的源码:

```java
// ClassFilter
public interface ClassFilter {
  // 判断类是否匹配
  boolean matches(Class<?> clazz);
}

// MethodMatcher
public interface MethodMatcher {
  // 判断方法是否匹配
  boolean matches(Method method, Class<?> targetClass);
  // 判断方法是否匹配,同时还可以对方法的参数进行判断过滤
  boolean matches(Method method, Class<?> targetClass, Object... args);

  // 判断方法是否是运行时生成的
  boolean isRuntime();
}
```

下面是一个示例演示 Pointcut 接口如何使用

首先定义一个 `Pointcut` 的实现类(并没有采用[AOP 基础](./AOP基础#api-编程) 中的 *StaticMethodMatcherPointcut*)

```java
/**
 * {@link Pointcut} 的实现示例,分别实现: getClassFilter、getMethodMatcher 方法
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see Pointcut
 */
public class DefaultPoint implements Pointcut {
    @Override
    public ClassFilter getClassFilter() {
        return new ClassFilter() {
            @Override
            public boolean matches(Class<?> clazz) {
                // 判断是不是 EchoService
                return EchoService.class.isAssignableFrom(clazz);
            }
        };
    }

    @Override
    public MethodMatcher getMethodMatcher() {
        return new MethodMatcher() {
            @Override
            public boolean matches(Method method, Class<?> targetClass) {
                // 判断方法名是 echo 的方法
                return "echo".equals(method.getName()) &&
                        method.getParameterTypes().length == 1 &&
                        method.getParameterTypes()[0].equals(String.class);
            }

            @Override
            public boolean isRuntime() {
                // 默认不是运行时生成的方法
                return false;
            }

            @Override
            public boolean matches(Method method, Class<?> targetClass, Object... args) {
                return false;
            }
        };
    }
}	
```

然后就是进行测试,还是需要使用 PointcutAdvisor 适配器的默认实现 `DefaultPointcutAdvisor`

```java
/**
 * {@link Pointcut} 的示例
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see Pointcut
 * @see Advisor
 * @see DefaultPointcutAdvisor
 * @see AspectJProxyFactory
 */
public class PointCutDemo {
    public static void main(String[] args) {
        // 创建AspectJ代理工厂
        AspectJProxyFactory proxyFactory = new AspectJProxyFactory(new DefaultEchoService());

        // 创建 Pointcut 实例
        Pointcut pointcut = new DefaultPoint();

        // 创建 PointcutAdvisor 默认实现
        PointcutAdvisor pointcutAdvisor = new DefaultPointcutAdvisor(pointcut, new MethodBeforeAdvice() {
            @Override
            public void before(Method method, Object[] args, Object target) throws Throwable {
                System.out.println("[PointCutDemo] echo ...");
            }
        });
        proxyFactory.addAdvisor(pointcutAdvisor);

        // 获取代理对象
        EchoService proxy = (EchoService)proxyFactory.getProxy();
        // 通过代理对象执行方法
        proxy.echo("Hello,World");
    }
}
/**
 * out:
 *  [PointCutDemo] echo ...
 *  [DefaultEchoService] echo executed... 
 */
```

### 组合实现(ComposablePointcut)

> - 除了可以采用 [常规实现](AOP设计与实现#常规实现) 的方式直接实现 `Pointcut` 接口,还可以采用组合实现的方式
>
> - 所谓采用组合的方式,就是将多个 Pointcut 联合起来

- 基础实现类: `ComposablePointcut`

- 工具类:
  - ClassFilter 工具类: `ClassFilters`
  - MethodMatcher 工具类: `MethodMatchers`
  - Pointcut 工具类: `Pointcuts`

- 核心方法
  - `ComposablePointcut#union(...)`: 将多个 MethodMatcher、ClassFilter 连接起来(并集)
  - `ComposablePointcut#intersection(...)`: 取多个 MethodMatcher、ClassFilter 的交集

下面是演示代码:

为了测试,修改了前面提供的 EchoService 接口以及默认实现:

```java
/**
 * 默认的 {@link EchoService} 实现
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class DefaultEchoService implements EchoService{
    @Override
    public String echo(String message) {
        System.out.println("[DefaultEchoService] echo executed... ");
        if (message.equals("error")) {
            int i = 1 /0;
            return String.valueOf(i);
        } else {
            return "[Echo]:" + message;
        }
    }
		// highlight-start
    @Override
    public String say(String message) throws NullPointerException {
        System.out.println("[DefaultEchoService] say executed... ");
        return "[Say]:" + message;
    }

    @Override
    public String call(String message) throws NullPointerException {
        System.out.println("[DefaultEchoService] call executed... ");
        return "[Call]:" + message;
    }

    @Override
    public String print(String message) throws NullPointerException {
        System.out.println("[DefaultEchoService] print executed... ");
        return "[Print]:" + message;
    }
    // highlight-end
}
```

首先还是定义一个用于返回 `ComposablePointcut` 对象的方法:

```java
/**
 * 使用 {@link ComposablePointcut} 来组合 Pointcut
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see  ComposablePointcut
 * @see Pointcut
 * @see ClassFilters
 * @see MethodMatchers
 */
public class ComposablePoint {
    public ComposablePointcut getComposablePointcut() {
        // 创建 DefaultPoint,匹配 EchoService#echo 方法
        DefaultPoint echoPoint = new DefaultPoint();
        ComposablePointcut pointcut = new ComposablePointcut(echoPoint);

        // 添加对 EchoService#say 方法的匹配
        pointcut.union(new StaticMethodMatcher() {
            @Override
            public boolean matches(Method method, Class<?> targetClass) {
                return "say".equals(method.getName()) &&
                        method.getParameterTypes().length == 1 &&
                        method.getParameterTypes()[0].equals(String.class);
            }
        }).union(new StaticMethodMatcher() {
          // 添加对 call 方法的支持
            @Override
            public boolean matches(Method method, Class<?> targetClass) {
                return "call".equals(method.getName()) &&
                        method.getParameterTypes().length == 1 &&
                        method.getParameterTypes()[0].equals(String.class);
            }
        });

        return pointcut;
    }
}
```

最后进行测试,可以看到测试结果中同时对*echo、say、call* 方法拦截了:

```java
/**
 * {@link ComposablePointcut} 的示例
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class ComposablePointcutDemo {
    public static void main(String[] args) {
        // 创建AspectJ 代理工厂
        AspectJProxyFactory proxyFactory = new AspectJProxyFactory(new DefaultEchoService());
        proxyFactory.addAdvisor(new DefaultPointcutAdvisor(new ComposablePoint().getComposablePointcut(), new MethodBeforeAdvice() {
            @Override
            public void before(Method method, Object[] args, Object target) throws Throwable {
                System.out.println("ComposablePointcut execute method:["+ method.getName() +"]");
            }
        }));

        EchoService proxy = (EchoService) proxyFactory.getProxy();
        proxy.echo("Pacos");
        proxy.say("Pacos");
        proxy.call("Pacos");
        proxy.print("Pacos");
    }
}
/**
 * out:
 *  ComposablePointcut execute method:[echo]
 *  [DefaultEchoService] echo executed... 
 *  ComposablePointcut execute method:[say]
 *  [DefaultEchoService] say executed... 
 *  ComposablePointcut execute method:[call]
 *  [DefaultEchoService] call executed... 
 *  [DefaultEchoService] print executed... 
*/
```

### 便捷实现

Spring 还为开发者提供了几种便利的实现:

1. 静态 Pointcut: `StaticMethodMatcherPointcut`
2. 正则表达式 Pointcut: `JdkRegexpMethodPointcut`
    - 是 *StaticMethodMatcherPointcut* 的一种实现
3. 控制流 Pointcut: `ControlFlowPointcut`
    - 它主要是基于堆栈`StackTrace` 来实现

### AspectJ 实现

> 用于处理 AspectJ 的 pointcut 表达式注解

这个 Spring Pointcut 与 AspectJ 表达式的一个整合:

- 实现类: `AspectJExpressionPointcut`
- 指令支持: `SUPPORTED_PRIMITIVES`
- 表达式: `org.aspectj.weaver.tools.PointcutExpression`

这个实现将 Pointcut 的判断处理交给了 ASpectJ 来实现,Spring 仅仅是负责桥接、调用 AspectJ:

```java
public class AspectJExpressionPointcut extends AbstractExpressionPointcut
		implements ClassFilter, IntroductionAwareMethodMatcher, BeanFactoryAware {
	  
  private static final Set<PointcutPrimitive> SUPPORTED_PRIMITIVES = new HashSet<>();
	// 支持的指令,一种只有 10 种
	static {
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.EXECUTION);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.ARGS);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.REFERENCE);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.THIS);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.TARGET);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.WITHIN);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_ANNOTATION);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_WITHIN);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_ARGS);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_TARGET);
	}
  
  // 组合了 AspectJ 的 Pointcut 表达式
  @Nullable
	private transient PointcutExpression pointcutExpression;
  
  // 获取 AspectJ 的 Pointcut 表达式
  private PointcutExpression obtainPointcutExpression() {
		if (this.pointcutExpression == null) {
			this.pointcutClassLoader = determinePointcutClassLoader();
			this.pointcutExpression = buildPointcutExpression(this.pointcutClassLoader);
		}
		return this.pointcutExpression;
	}
  
  // 判断 Class 是否是目标类
  @Override
	public boolean matches(Class<?> targetClass) {
		PointcutExpression pointcutExpression = obtainPointcutExpression();
    // 简化后的代码,主要通过 AspectJ 的 PointcutExpression 进行处理
		return pointcutExpression.couldMatchJoinPointsInType(targetClass);
	}
  // 还有其他重载的 matches 方法用于 Pointcut 的判断
	// ....
}
```

## 连接点执行动作(Advice)

- Around Advice: `Interceptor`
  - 拦截接口 : `MethodInterceptor`, 其他类型的 Advice 对应的 *interceptor* 实现了该接口
- 前置动作
  - 标准接口: `BeforeAdvice`
  - 方法级别的子接口: `MethodBeforeAdvice`
- 后置动作
  - `AfterAdvice`
  - `AfterReturningAdvice`
  - `ThrowsAdvice`

### BeforeAdvice

#### 标准实现

> 所谓的标准实现就是: SpringAOP 没有引入 ASpectJ 之前的内部实现

- 接口
  - 标准接口: `BeforeAdvice`
  - 方法级别的子接口: `MethodBeforeAdvice`
- 实现: `MethodBeforeAdviceInterceptor`

所有的 MethodBefore 拦截 都是通过 `MethodBeforeAdviceInterceptor` 执行的,它分别实现了方法拦截器 `MethodInterceptor` 和 标记接口 `BeforeAdvice`:

```java
public class MethodBeforeAdviceInterceptor implements MethodInterceptor, BeforeAdvice, Serializable {

	private final MethodBeforeAdvice advice;

	public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {
		this.advice = advice;
	}

  // highlight-start
	@Override
	public Object invoke(MethodInvocation mi) throws Throwable {
		this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());
		return mi.proceed();
	}
  // highlight-end
}
```

:::tip 说明

有多少个 MethodBeforeAdvice,SpringAop 内部就会包装多少个与之对应的 MethodBeforeAdviceInterceptor 去执行

:::

#### AspectJ 实现

- 实现类: `AspectJMethodBeforeAdvice`, 同时也是 *MethodBeforeAdvice* 的实现类

```java
// AspectJ 实现 AspectJMethodBeforeAdvice
public class AspectJMethodBeforeAdvice extends AbstractAspectJAdvice implements MethodBeforeAdvice, Serializable {

	public AspectJMethodBeforeAdvice(Method aspectJBeforeAdviceMethod, 
                                   AspectJExpressionPointcut pointcut,
                                   AspectInstanceFactory aif) {
		super(aspectJBeforeAdviceMethod, pointcut, aif);
	}

	@Override
	public void before(Method method, Object[] args, @Nullable Object target) throws Throwable {
		invokeAdviceMethod(getJoinPointMatch(), null, null);
	}
	// ..
}
```



- 对于 AspectJ 注解处理来说: 会在 `ReflectiveAspectJAdvisorFactory` 中根据注解的类型选择创建哪一个 AspectJ 的实现
- 对于 XML 配置来说, 会在 `ConfigBeanDefinitionParser` 中的 *parse* 方法的调用链中创建相关的 BeanDefinition 并注册到容器中



:::tip 说明

Advice 的 AspectJ 实现,一般都会实现一个抽象类: `AbstractAspectJAdvice`

:::

### AfterAdvice

#### 标准实现

- 接口
  - `AfterAdvice`
  - `AfterReturningAdvice`
  - `ThrowsAdvice`
- 实现:
  - `ThrowsAdviceInterceptor`
  - `AfterReturningAdviceInterceptor`

#### AspectJ 实现

## Advice 容器接口(Advisor)

### Pointcut 与 Advice 连接器(PointcutAdvisor)

### Introduction 与 Advice 连接器(IntroductionAdvisor)

## Advisor 的 Interceptor 适配器(AdvisorAdapter)

### AdvisorAdapter 实现

## AOP 代理接口(AopProxy)

### AopProxy 工厂接口与实现

#### JdkDynamicAopProxy

#### CglibAopProxy

## AopProxyFactory 配置管理器(AdvisedSupport)

## Advisor 链工厂接口与实现(AdvisorChainFactory)

## 目标对象来源接口与实现(TargetSource)

## 代理对象创建基础类(ProxyCreatorSupport)

## AdvisedSupport 事件监听器(AdvisedSupportListener)

## ProxyCreatorSupport 的实现

### 标准实现(ProxyFactory)

### IOC 容器实现(ProxyFactoryBean)

### AspectJ 实现(AspectJProxyFactory)

## IOC 容器自动代理抽象(AbstractAutoProxyCreator)

### 标准实现

### AspectJ 实现(AspectJAwareAdvisorAutoProxyCreator)

## AOP Infrastructure Bean 接口(AopInfrastructureBean)

## AOP 上下文辅助类(AopContext)

## 代理工厂工具类(AopProxyUtil)

## AspectJ Enable 模块驱动(@EnableAspectJAutoProxy)

## AspectJ XML 配置驱动

### AOP 配置

### Aspect 配置

### Pointcut 配置

### Around Advice 配置

### Before Advice 配置

### After Advice 配置

### After Returning Advice 配置

### After Throwing Advice 配置

### Adviser 实现

### Introduction 配置

### 作用域代理配置

