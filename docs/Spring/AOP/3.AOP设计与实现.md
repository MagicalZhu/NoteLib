---
id: AOP设计与实现
title: AOP设计与实现
cssClass: wide-page
---

## 整体设计

1. `Joinpoint`
2. `Pointcut`
3. Advice 执行动作: `Advice`
4. Advice 容器: `Advisor`
5. Introduction: `IntroductionInfo`
6. 代理对象创建基础类: `ProxyCreatorSupport`
7. 代理工厂: `ProxyFactory、ProxyFactoryBean`
8. AopProxyFactory 配置管理器: `AdvisedSupport`
9. IOC 容器自动代理抽象: `AbstractAutoProxyCreator`

## 连接点(Joinpoint)

Joinpoint 的子接口: Interceptor 的执行上下文 `Invocation` :

- 方法拦截子接口: `MethodInvocation`
  - 基于反射的实现: `ReflectiveMethodInvocation`
  - 基于 CGLIB的实现: `CglibMethodInvocation`
- ~~构造器拦截子接口: ConstructorInvocation~~

类层次结构图:

```ini
├── Joinpoint
│   └── Invocation
│     └── MethodInvocation
│       └── ProxyMethodInvocation
│         └── ReflectiveMethodInvocation
│           └── CglibMethodInvocation
```

我们查看下 `Joinpoint` 接口,主要有下面 3 个方法

1. `proceed()` : 动作的执行,一般指的是方法
2. `getThis()`: 包含被执行方法的对象
3. `getStaticPart()`: 返回静态部分,对 Spring AOP 来说就是返回方法 Method 对象

```java
public interface Joinpoint {
  Object proceed() throws Throwable;  
  Object getThis();  
  AccessibleObject getStaticPart();  
}
```

然后观察 `Invocation` 和它的子接口 `MethodInvocation`:

1. `getArguments()`: 返回方法的参数
2. `getMethod()` : 返回方法对象 Method(和 *getStaticPart* 返回的是一样的结果)

```java
// Invocation
public interface Invocation extends Joinpoint {  
  Object[] getArguments();
}

// MethodInvocation
public interface MethodInvocation extends Invocation {  
  Method getMethod();  
}
```

## 连接点条件(Pointcut)

### 常规实现

> 主要是负责一个判断

在 [AOP 基础](./AOP基础#api-编程) 中层概述过:

- 核心组件:
  1. 类过滤器: `ClassFilter`
  2. 方法过滤器: `MethodMatcher`

```java
public interface Pointcut {
  ClassFilter getClassFilter();  
  MethodMatcher getMethodMatcher();  
}
```

查看下 `ClassFilter` 和 `MethodMatcher` 接口的源码:

```java
// ClassFilter
public interface ClassFilter {
  // 判断类是否匹配
  boolean matches(Class<?> clazz);
}

// MethodMatcher
public interface MethodMatcher {
  // 判断方法是否匹配
  boolean matches(Method method, Class<?> targetClass);
  // 判断方法是否匹配,同时还可以对方法的参数进行判断过滤
  boolean matches(Method method, Class<?> targetClass, Object... args);

  // 判断方法是否是运行时生成的
  boolean isRuntime();
}
```

下面是一个示例演示 Pointcut 接口如何使用

首先定义一个 `Pointcut` 的实现类(并没有采用 [AOP 基础](./AOP基础#api-编程) 中的 *StaticMethodMatcherPointcut*)

```java
/**
 * {@link Pointcut} 的实现示例,分别实现: getClassFilter、getMethodMatcher 方法
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see Pointcut
 */
public class DefaultPoint implements Pointcut {
    @Override
    public ClassFilter getClassFilter() {
        return new ClassFilter() {
            @Override
            public boolean matches(Class<?> clazz) {
                // 判断是不是 EchoService
                return EchoService.class.isAssignableFrom(clazz);
            }
        };
    }

    @Override
    public MethodMatcher getMethodMatcher() {
        return new MethodMatcher() {
            @Override
            public boolean matches(Method method, Class<?> targetClass) {
                // 判断方法名是 echo 的方法
                return "echo".equals(method.getName()) &&
                        method.getParameterTypes().length == 1 &&
                        method.getParameterTypes()[0].equals(String.class);
            }

            @Override
            public boolean isRuntime() {
                // 默认不是运行时生成的方法
                return false;
            }

            @Override
            public boolean matches(Method method, Class<?> targetClass, Object... args) {
                return false;
            }
        };
    }
}	
```

然后就是进行测试,还是需要使用 PointcutAdvisor 适配器的默认实现 `DefaultPointcutAdvisor`

```java
/**
 * {@link Pointcut} 的示例
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see Pointcut
 * @see Advisor
 * @see DefaultPointcutAdvisor
 * @see AspectJProxyFactory
 */
public class PointCutDemo {
    public static void main(String[] args) {
        // 创建AspectJ代理工厂
        AspectJProxyFactory proxyFactory = new AspectJProxyFactory(new DefaultEchoService());

        // 创建 Pointcut 实例
        Pointcut pointcut = new DefaultPoint();

        // 创建 PointcutAdvisor 默认实现
        PointcutAdvisor pointcutAdvisor = new DefaultPointcutAdvisor(pointcut, new MethodBeforeAdvice() {
            @Override
            public void before(Method method, Object[] args, Object target) throws Throwable {
                System.out.println("[PointCutDemo] echo ...");
            }
        });
        proxyFactory.addAdvisor(pointcutAdvisor);

        // 获取代理对象
        EchoService proxy = (EchoService)proxyFactory.getProxy();
        // 通过代理对象执行方法
        proxy.echo("Hello,World");
    }
}
/**
 * out:
 *  [PointCutDemo] echo ...
 *  [DefaultEchoService] echo executed... 
 */
```

### 组合实现(ComposablePointcut)

> - 除了可以采用 [常规实现](AOP设计与实现#常规实现) 的方式直接实现 `Pointcut` 接口,还可以采用组合实现的方式
>
> - 所谓采用组合的方式,就是将多个 Pointcut 联合起来

- 基础实现类: `ComposablePointcut`

- 工具类:
  - ClassFilter 工具类: `ClassFilters`
  - MethodMatcher 工具类: `MethodMatchers`
  - Pointcut 工具类: `Pointcuts`

- 核心方法
  - `ComposablePointcut#union(...)`: 将多个 MethodMatcher、ClassFilter 连接起来(并集)
  - `ComposablePointcut#intersection(...)`: 取多个 MethodMatcher、ClassFilter 的交集

下面是演示代码:

为了测试,修改了前面提供的 EchoService 接口以及默认实现:

```java
/**
 * 默认的 {@link EchoService} 实现
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class DefaultEchoService implements EchoService{
    @Override
    public String echo(String message) {
        System.out.println("[DefaultEchoService] echo executed... ");
        if (message.equals("error")) {
            int i = 1 /0;
            return String.valueOf(i);
        } else {
            return "[Echo]:" + message;
        }
    }
		// highlight-start
    @Override
    public String say(String message) throws NullPointerException {
        System.out.println("[DefaultEchoService] say executed... ");
        return "[Say]:" + message;
    }

    @Override
    public String call(String message) throws NullPointerException {
        System.out.println("[DefaultEchoService] call executed... ");
        return "[Call]:" + message;
    }

    @Override
    public String print(String message) throws NullPointerException {
        System.out.println("[DefaultEchoService] print executed... ");
        return "[Print]:" + message;
    }
    // highlight-end
}
```

首先还是定义一个用于返回 `ComposablePointcut` 对象的方法:

```java
/**
 * 使用 {@link ComposablePointcut} 来组合 Pointcut
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see  ComposablePointcut
 * @see Pointcut
 * @see ClassFilters
 * @see MethodMatchers
 */
public class ComposablePoint {
    public ComposablePointcut getComposablePointcut() {
        // 创建 DefaultPoint,匹配 EchoService#echo 方法
        DefaultPoint echoPoint = new DefaultPoint();
        ComposablePointcut pointcut = new ComposablePointcut(echoPoint);

        // 添加对 EchoService#say 方法的匹配
        pointcut.union(new StaticMethodMatcher() {
            @Override
            public boolean matches(Method method, Class<?> targetClass) {
                return "say".equals(method.getName()) &&
                        method.getParameterTypes().length == 1 &&
                        method.getParameterTypes()[0].equals(String.class);
            }
        }).union(new StaticMethodMatcher() {
          // 添加对 call 方法的支持
            @Override
            public boolean matches(Method method, Class<?> targetClass) {
                return "call".equals(method.getName()) &&
                        method.getParameterTypes().length == 1 &&
                        method.getParameterTypes()[0].equals(String.class);
            }
        });

        return pointcut;
    }
}
```

最后进行测试,可以看到测试结果中同时对*echo、say、call* 方法拦截了:

```java
/**
 * {@link ComposablePointcut} 的示例
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class ComposablePointcutDemo {
    public static void main(String[] args) {
        // 创建AspectJ 代理工厂
        AspectJProxyFactory proxyFactory = new AspectJProxyFactory(new DefaultEchoService());
        proxyFactory.addAdvisor(new DefaultPointcutAdvisor(new ComposablePoint().getComposablePointcut(), new MethodBeforeAdvice() {
            @Override
            public void before(Method method, Object[] args, Object target) throws Throwable {
                System.out.println("ComposablePointcut execute method:["+ method.getName() +"]");
            }
        }));

        EchoService proxy = (EchoService) proxyFactory.getProxy();
        proxy.echo("Pacos");
        proxy.say("Pacos");
        proxy.call("Pacos");
        proxy.print("Pacos");
    }
}
/**
 * out:
 *  ComposablePointcut execute method:[echo]
 *  [DefaultEchoService] echo executed... 
 *  ComposablePointcut execute method:[say]
 *  [DefaultEchoService] say executed... 
 *  ComposablePointcut execute method:[call]
 *  [DefaultEchoService] call executed... 
 *  [DefaultEchoService] print executed... 
*/
```

### 便捷实现

SpringAop 为开发者提供了几种便利的实现:

1. 静态 Pointcut: `StaticMethodMatcherPointcut`
2. 正则表达式 Pointcut: `JdkRegexpMethodPointcut`
    - 是 *StaticMethodMatcherPointcut* 的一种实现
3. 控制流 Pointcut: `ControlFlowPointcut`
    - 它主要是基于堆栈`StackTrace` 来实现

### AspectJ 实现

> 用于处理 AspectJ 的 pointcut 表达式注解

这个 Spring Pointcut 与 AspectJ 表达式的一个整合:

- 实现类: `AspectJExpressionPointcut`
- 指令支持: `SUPPORTED_PRIMITIVES`
- 表达式: `org.aspectj.weaver.tools.PointcutExpression`

这个实现将 Pointcut 的判断处理交给了 ASpectJ 来实现,Spring 仅仅是负责桥接、调用 AspectJ:

```java
public class AspectJExpressionPointcut extends AbstractExpressionPointcut
		implements ClassFilter, IntroductionAwareMethodMatcher, BeanFactoryAware {
	  
  private static final Set<PointcutPrimitive> SUPPORTED_PRIMITIVES = new HashSet<>();
	// 支持的指令,一种只有 10 种
	static {
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.EXECUTION);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.ARGS);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.REFERENCE);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.THIS);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.TARGET);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.WITHIN);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_ANNOTATION);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_WITHIN);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_ARGS);
		SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_TARGET);
	}
  
  // 组合了 AspectJ 的 Pointcut 表达式
  @Nullable
	private transient PointcutExpression pointcutExpression;
  
  // 获取 AspectJ 的 Pointcut 表达式
  private PointcutExpression obtainPointcutExpression() {
		if (this.pointcutExpression == null) {
			this.pointcutClassLoader = determinePointcutClassLoader();
			this.pointcutExpression = buildPointcutExpression(this.pointcutClassLoader);
		}
		return this.pointcutExpression;
	}
  
  // 判断 Class 是否是目标类
  @Override
	public boolean matches(Class<?> targetClass) {
		PointcutExpression pointcutExpression = obtainPointcutExpression();
    // 简化后的代码,主要通过 AspectJ 的 PointcutExpression 进行处理
		return pointcutExpression.couldMatchJoinPointsInType(targetClass);
	}
  // 还有其他重载的 matches 方法用于 Pointcut 的判断
	// ....
}
```

## 连接点执行动作(Advice)

- Around Advice: `Interceptor`
  - 拦截接口 : `MethodInterceptor`, 其他类型的 Advice 对应的 *interceptor* 实现了该接口
- 前置动作
  - 标准接口: `BeforeAdvice`
  - 方法级别的子接口: `MethodBeforeAdvice`
- 后置动作
  - `AfterAdvice`
  - `AfterReturningAdvice`
  - `ThrowsAdvice`

### BeforeAdvice

#### 标准实现

> 所谓的标准实现就是: SpringAOP 没有引入 AspectJ 之前的内部实现

- 接口
  - 标准接口[标记接口]: `BeforeAdvice`
  - 方法级别的子接口: `MethodBeforeAdvice`
- 实现: `MethodBeforeAdviceInterceptor`

所有的前置拦截实际上都是通过 `MethodBeforeAdviceInterceptor` 执行的,它分别实现了方法拦截器 `MethodInterceptor` 和 标记接口 `BeforeAdvice`:

```java
public class MethodBeforeAdviceInterceptor implements MethodInterceptor, BeforeAdvice, Serializable {

	private final MethodBeforeAdvice advice;

	public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {
		this.advice = advice;
	}

  // highlight-start
	@Override
	public Object invoke(MethodInvocation mi) throws Throwable {
		this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());
		return mi.proceed();
	}
  // highlight-end
}
```

并且通过 **组合** 的方式,将 MethodBeforeAdvice 包装为 *MethodBeforeAdviceInterceptor*, 也就是说实际执行 Advice 通知动作的还是 MethodBeforeAdvice, 只是通过包装的方式可以提供一个统一的入口 *invoke* 去调用 Advice

:::tip 提示

有多少个 MethodBeforeAdvice,SpringAop 内部就会包装多少个与之对应的 *MethodBeforeAdviceInterceptor* 去执行

:::

#### AspectJ 实现

- 实现类: `AspectJMethodBeforeAdvice`, 同时也是 *MethodBeforeAdvice* 的实现类(所以也会被包装为 MethodBeforeAdviceInterceptor)

```java
// AspectJ 实现 AspectJMethodBeforeAdvice
public class AspectJMethodBeforeAdvice extends AbstractAspectJAdvice implements MethodBeforeAdvice, Serializable {

	public AspectJMethodBeforeAdvice(Method aspectJBeforeAdviceMethod, 
                                   AspectJExpressionPointcut pointcut,
                                   AspectInstanceFactory aif) {
		super(aspectJBeforeAdviceMethod, pointcut, aif);
	}

	@Override
	public void before(Method method, Object[] args, @Nullable Object target) throws Throwable {
		invokeAdviceMethod(getJoinPointMatch(), null, null);
	}
	// ..
}
```



- 对于 AspectJ 注解处理来说: 会在 `ReflectiveAspectJAdvisorFactory` 中根据注解的类型选择创建哪一个 AspectJ 的实现
- 对于 XML 配置来说, 会在 `ConfigBeanDefinitionParser` 中的 *parse* 方法调用链中创建相关的 BeanDefinition 并注册到容器中

:::tip 说明

Advice 的 AspectJ 实现,都会实现一个抽象类: `AbstractAspectJAdvice`:

```java title="org.springframework.aop.aspectj.AbstractAspectJAdvice#invokeAdviceMethod"
protected Object invokeAdviceMethod(JoinPoint jp, @Nullable JoinPointMatch jpMatch,
    @Nullable Object returnValue, @Nullable Throwable t) throws Throwable {

  return invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));
}

protected Object invokeAdviceMethodWithGivenArgs(Object[] args) throws Throwable {
  Object[] actualArgs = args;
  if (this.aspectJAdviceMethod.getParameterCount() == 0) {
    actualArgs = null;
  }
  try {
    // 设置可访问
    ReflectionUtils.makeAccessible(this.aspectJAdviceMethod);
    // 执行方法
    return this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);
  }
	// 异常处理...
}
```

在这个抽象类中会通过 `invokeAdviceMethod` 执行 Advice 方法

:::

### AfterAdvice

####  标准实现

- 接口
  - `AfterAdvice`
  - `AfterReturningAdvice`
  - `ThrowsAdvice`
- 实现:
  - `ThrowsAdviceInterceptor`
  - `AfterReturningAdviceInterceptor`

在实现上,ThrowsAdviceInterceptor 和 AfterReturningAdviceInterceptor 与前面的 [BeforeAdvice 的标准实现](AOP设计与实现#标准实现) 是类似的,实现了标记接口 `AfterAdvice` 和 方法拦截器 `MethodInterceptor`,并且分为将 Advice 包装为对应的 Interceptor:

```java
// AfterReturningAdviceInterceptor
public class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable {
	private final AfterReturningAdvice advice;

	public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) {
		this.advice = advice;
	}

	@Override
	public Object invoke(MethodInvocation mi) throws Throwable {
		Object retVal = mi.proceed();
    // highlight-start
		this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());
    // highlight-end
		return retVal;
	}
}
// ThrowsAdviceInterceptor
public class ThrowsAdviceInterceptor implements MethodInterceptor, AfterAdvice {
  
  private static final String AFTER_THROWING = "afterThrowing";
  
  public ThrowsAdviceInterceptor(Object throwsAdvice) {
		this.throwsAdvice = throwsAdvice;

		Method[] methods = throwsAdvice.getClass().getMethods();
		for (Method method : methods) {
        // 方法名固定为 afterThrowing
			if (method.getName().equals(AFTER_THROWING) &&
          // 方法参数要么是 1 个,要么是 4 个
					(method.getParameterCount() == 1 || method.getParameterCount() == 4)) {
				Class<?> throwableParam = method.getParameterTypes()[method.getParameterCount() - 1];
				if (Throwable.class.isAssignableFrom(throwableParam)) {
					// An exception handler to register...
					this.exceptionHandlerMap.put(throwableParam, method);
				}
			}
		}
	}
  
	@Override
	public Object invoke(MethodInvocation mi) throws Throwable {
		try {
			return mi.proceed();
		}
		catch (Throwable ex) {
			Method handlerMethod = getExceptionHandler(ex);
			if (handlerMethod != null) {
        // highlight-start
				invokeHandlerMethod(mi, ex, handlerMethod);
        // highlight-end
			}
			throw ex;
		}
	}
}
```

:::caution 关于 ThrowsAdvice

1. ThrowsAdvice 接口中并没有提供诸如 `BeforeAdvice#before` 和 `AfterReturningAdvice#afterReturning` 这样的方法,而是在拦截器(ThrowsAdviceInterceptor) 中通过反射判断方法名是否等于 `afterThrowing`
2. ThrowsAdvice 除了判断方法名,还会判断方法参数个数,要么是 1 个,要么是 4 个。所以支持以下两种格式:
   - public void afterThrowing(Exception ex)
   - public void afterThrowing(Method method, Object[] args, Object target, Exception ex)
3. 还有一个注意点: **ThrowsAdvice 的实现类也必须是 public 的,不是 private,也不能是 匿名内部类**

:::

#### ThrowsAdvice 示例

在前面的 [后置拦截动作的 AfterReturning](AOP基础#api-编程-3) 中演示过 AfterReturningAdvice API 的使用方式,这里对 `ThrowsAdvice` 进行演示:

首先需要创建一个 public 的类,并且实现 `ThrowsAdvice`:

```java
  public static class CusThrowsAdvice implements ThrowsAdvice {
      public void afterThrowing(Exception ex) {
          System.out.println("[afterThrowing] 发生异常了...");
      }
  }
```

然后进行测试,将 ThrowsAdvice 添加到 Advice Chain 中:

```java
/**
 * {@link ThrowsAdvice} 的示例
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see ThrowsAdvice
 * @see Advisor
 * @see DefaultPointcutAdvisor
 * @see AspectJProxyFactory
 */
public class PointCutDemoByError {
    public static void main(String[] args) {
        // 创建AspectJ代理工厂
        AspectJProxyFactory proxyFactory = new AspectJProxyFactory(new DefaultEchoService());

        // 创建 Pointcut 实例
        Pointcut pointcut = new DefaultPoint();

        // 创建 PointcutAdvisor 默认实现
        PointcutAdvisor pointcutAdvisor = new DefaultPointcutAdvisor(pointcut, new CusThrowsAdvice());
        proxyFactory.addAdvisor(pointcutAdvisor);

        // 获取代理对象
        EchoService proxy = (EchoService)proxyFactory.getProxy();
        // 通过代理对象执行方法,传入 error 会抛出异常
        proxy.echo("error");
    }
}
/**
 * out:
 *      [DefaultEchoService] echo executed... 
 *      [afterThrowing] 发生异常了...
 *      Exception in thread "main" java.lang.ArithmeticException: / by zero
 *      at aop.domain.DefaultEchoService.echo(DefaultEchoService.java:13)
 *      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
 *      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
 *      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
 *      at java.lang.reflect.Method.invoke(Method.java:498)
 */
```

#### AspectJ 实现

> 除了标准的 xxxInterceptor 实现之外,还有相应的 aspectj 的实现

- 接口
  - `AfterAdvice`
  - `AfterReturningAdvice`
  - `ThrowsAdvice`
- 相关的实现
  - `AspectJAfterAdvice`
  - `AspectJAfterReturningAdvice`
  - `AspectJAfterThrowingAdvice`

对于 **AspectJAfterAdvice** 来说: 它本身就是一个 *MethodInterceptor* 的实现,所以会被 SpringAop 调用 `invoke()`,然后调用 [AbstractAspectJAdvice#invokeAdviceMethod()](AOP设计与实现#aspectj-实现-1)

```java
// AspectJAfterAdvice
public class AspectJAfterAdvice extends AbstractAspectJAdvice
		implements MethodInterceptor, AfterAdvice, Serializable {

	public AspectJAfterAdvice(Method aspectJBeforeAdviceMethod,
                            AspectJExpressionPointcut pointcut,
                            AspectInstanceFactory aif) {
		super(aspectJBeforeAdviceMethod, pointcut, aif);
	}

	@Override
	public Object invoke(MethodInvocation mi) throws Throwable {
		try {
			return mi.proceed();
		}
		finally {
			invokeAdviceMethod(getJoinPointMatch(), null, null);
		}
	}
	// ...
}
```

**AspectJAfterReturningAdvice、AspectJAfterThrowingAdvice** 的的实现与 [AspectJ 的前置通知](AOP设计与实现#aspectj-实现-1) 类似: Spring 会将 Advice 包装为对应的 AdviceInterceptor,然后被 SpringAop 调用

```java
// 这里以 AspectJAfterReturningAdvice 为例:
public class AspectJAfterReturningAdvice extends AbstractAspectJAdvice
		implements AfterReturningAdvice, AfterAdvice, Serializable {

	public AspectJAfterReturningAdvice(Method aspectJBeforeAdviceMethod, 
                                     AspectJExpressionPointcut pointcut,
                                     AspectInstanceFactory aif) {
		super(aspectJBeforeAdviceMethod, pointcut, aif);
	}

	@Override
	public void afterReturning(@Nullable Object returnValue, 
                             Method method, Object[] args,
                             @Nullable Object target) throws Throwable {
		if (shouldInvokeOnReturnValueOf(method, returnValue)) {
			invokeAdviceMethod(getJoinPointMatch(), returnValue, null);
		}
	}
}
```

:::tip 说明

在 AspectJ 的实现中,SpringAop 仅仅是利用 aspectj 的能力,将 aspectj 表达式 "转换为" 对应的 Method 对象,然后调用 Method

:::

## Advice 容器接口(Advisor)

> Advisor 是 AspectJ 的 AOP 中没有的概念

- 接口: `Advisor`
  - 通用实现: `DefaultPointcutAdvisor`

对 Advisor 来说,**一个 Advisor 绑定一个 Advice**,通过 `getAdvice` 返回一个 Advice(Interceptor、before-advice、throws-advice、after-returning-advice…)

```java
public interface Advisor {
	Advice EMPTY_ADVICE = new Advice() {};

	Advice getAdvice();

	boolean isPerInstance();
}
```

### 与 Pointcut 的连接器(PointcutAdvisor)

> Advisor 只能获取到 Advice, 通过 PointcutAdvisor 可以进一步获取到 Pointcut, Pointcut 可以进一步增强对 Joinpoint 的过滤

- 接口: `PointcutAdvisor`
  - 通用实现: `DefaultPointcutAdvisor`
  - AspectJ 实现
    - `AspectJExpressPointcutAdvisor` 
    - `AspectJPointcutAdvisor`
  - 静态方法实现: `StaticMethodMatcherPointcutAdvisor`
  - IOC 容器实现: `AbstractBeanFactoryPointcutAdvisor`

- 相对于 Advisor 来说, PointcutAdvisor 包含了获取 Pointcut 的方法 `getPointcut()`

  ```java
  public interface PointcutAdvisor extends Advisor {
    // 获取 Pointcut
  	Pointcut getPointcut();
  }
  ```

- **DefaultPointcutAdvisor** 继承了 **AbstractGenericPointcutAdvisor** 和 **AbstractPointcutAdvisor**,它们分别具有写入(`setAdvice`) 和 设置顺序(`setOrder`) 的能力

- **AspectJExpressPointcutAdvisor** 则会通过 **组合** 的方式,具备 [AspectJExpressionPointcut](AOP设计与实现#aspectj-实现) 的能力:

  - 传入的 Pointcut 表达式会作为参数透传给 AspectJExpressionPointcut, 其他的操作也是通过这个组合的 AspectJExpressionPointcut 进行的
  - 它同样继承自 **AbstractGenericPointcutAdvisor**

  ```java
  public class AspectJExpressionPointcutAdvisor extends AbstractGenericPointcutAdvisor implements BeanFactoryAware {
  
  	private final AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
  
  	public void setExpression(@Nullable String expression) {
  		this.pointcut.setExpression(expression);
  	}
  	public void setLocation(@Nullable String location) {
  		this.pointcut.setLocation(location);
  	}
  
    // ...
  	@Override
  	public Pointcut getPointcut() {
  		return this.pointcut;
  	}
  }
  ```

- AspectJPointcutAdvisor 是直接实现了 *PointcutAdvisor* 接口的,但本质上还是通过组合的方式,通过 `AbstractAspectJAdvice` 来实现内部功能,这个 AbstractAspectJAdvice 是 [BeforeAdvice](AOP设计与实现#aspectj-实现-1)、[AfterAdvice](AOP设计与实现#aspectj-实现-2) 的 AspectJ 实现的共同抽象

  ```java
  public class AspectJPointcutAdvisor implements PointcutAdvisor, Ordered {
  
  	private final AbstractAspectJAdvice advice;
  
  	private final Pointcut pointcut;
  
  	public AspectJPointcutAdvisor(AbstractAspectJAdvice advice) {
  		this.advice = advice;
      // highlight-start
      // 通过 AbstractAspectJAdvice#buildSafePointcut 创建一个 Pointcut
  		this.pointcut = advice.buildSafePointcut();
      // highlight-end
  	}
  
  	@Override
  	public Advice getAdvice() {
  		return this.advice;
  	}
  
  	@Override
  	public Pointcut getPointcut() {
  		return this.pointcut;
  	}
  
  	public String getAspectName() {
  		return this.advice.getAspectName();
  	}
  }
  ```

:::tip 说明
PointcutAdvisor 大多数都实现了 Ordered 接口,所以具有排序的能力,也就是说对 Advisor 排序后再取出 Advisor 中的 Advice
:::

### 与 Introduction 的连接器(IntroductionAdvisor)

- 接口: `IntroductionAdvisor`
  - 元信息: `IntroductionInfo`
  - 通用实现: `DefaultIntroductionAdvisor`
  - AspectJ 实现: `DeclareParentsAdvisor`
- 对于 IntroductionAdvisor 来说

## Advisor 的 Interceptor 适配器(AdvisorAdapter)

### AdvisorAdapter 实现

## AOP 代理接口(AopProxy)

### AopProxy 工厂接口与实现

#### JdkDynamicAopProxy

#### CglibAopProxy

## AopProxyFactory 配置管理器(AdvisedSupport)

## Advisor 链工厂接口与实现(AdvisorChainFactory)

## 目标对象来源接口与实现(TargetSource)

## 代理对象创建基础类(ProxyCreatorSupport)

## AdvisedSupport 事件监听器(AdvisedSupportListener)

## ProxyCreatorSupport 的实现

### 标准实现(ProxyFactory)

### IOC 容器实现(ProxyFactoryBean)

### AspectJ 实现(AspectJProxyFactory)

## IOC 容器自动代理抽象(AbstractAutoProxyCreator)

### 标准实现

### AspectJ 实现(AspectJAwareAdvisorAutoProxyCreator)

## AOP Infrastructure Bean 接口(AopInfrastructureBean)

## AOP 上下文辅助类(AopContext)

## 代理工厂工具类(AopProxyUtil)

## AspectJ Enable 模块驱动(@EnableAspectJAutoProxy)

## AspectJ XML 配置驱动

### AOP 配置

### Aspect 配置

### Pointcut 配置

### Around Advice 配置

### Before Advice 配置

### After Advice 配置

### After Returning Advice 配置

### After Throwing Advice 配置

### Adviser 实现

### Introduction 配置

### 作用域代理配置

