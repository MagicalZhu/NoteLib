---
id: IOC容器
title: IOC容器
---

## 基础

Spring是一个轻量级的JEE开源IOC(DI)和AOP容器框架,Spring的优良特性包括:

- `非侵入式 (轻量级)`
  - 基于Spring开发的应用中的对象可以不依赖于Spring的API
- `依赖注入`
  - Dependency Injection(DI)，反转控制(IOC)最经典的实现
- `面向切面编程`
  - Aspect Oriented Programming(AOP)
- `容器`
  - Spring是一个容器，因为它包含并且管理应用对象的生命周期
- `组件化` 
  - Spring实现了使用简单的组件配置组合成一个复杂的应用
  - 在 Spring 中可以使用XML和Java注解组合这些对象。
- `一站式`
  - 在IOC和AOP的基础上可以整合各种企业应用的开源框架和优秀的第三方类库
  - 实际上Spring 自身也提供了表述层的SpringMVC和持久层的Spring JDBC


![image-20221030223638592](./image/1.IOC/image-20221030223638592.png)

## Spring的使用

从一个简单的 Spring 应用程序说起,需要由下面的步骤
1. 引入 Spring 相关的依赖
1. 定义一个 Bean 对象
1. 创建一个 Spring 的容器配置文件
1. 在容器中设置 Bean 对象的 instance
   - **创建容器对象 [支持注解、配置文件等多种方式] **
     -  `ApplicationContext context=new ClassPathXmlApplicationContext(String fileName)`
   - **从容器中获取 Bean 对象的 instance**
     - `context.getBean(...)`

:::info 基本的示例

**1. 在 classpath 下定义Spring 容器的配置文件, 并且向容器中加入 Bean 的 instance**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
  	<!-- 在容器中设置 Bean 对象的 instance -->
    <bean id="person" class="Demo1.Person" name="huakucha">
        <property name="address" value="CZ"/>
        <property name="name" value="huakucha"/>
        <property name="age" value="1"/>
    </bean>
</beans>
```

**2.获取Spring的容器对象,以及容器中的 Bean 的 instance**

```java
public class Hello {
    public static void main(String[] args) {
      	// 创建一个 SpringIOC 容器对象(基于 XML 加载Bean对象)
        ApplicationContext ctx = new ClassPathXmlApplicationContext("app.xml");
        Person p = (Person) ctx.getBean("huakucha");
        System.out.println(p);
    }
}
```

:::



## IOC 或 DI

- Spring 框架的核心就是基于`控制反转(Inversion Of Control,IOC)` 的原理, IOC 是一种将**组件依赖项的创建和管理外部化的技术**。
  - 比如类 Foo 依赖于类Bar,传统方式中,我们需要 new 一个Bar的实例,但是在 IOC 中,Bar 的实例会**在运行的时候由外部 process 提供给 Foo**

  - 这种`运行时注入依赖项`的行为, [Martin Fowler](https://martinfowler.com/) *将 IOC重新命名为更具描述性的 `依赖注入(Dependency Injection ,DI)`*

- Spring 的 DI 实现基于两个 Java 核心概念`JavaBeans` 和 `Interface`

  - 当使用 Spring 作为 DI 提供程序时,可以通过不同方式(XML、Java 配置类、注解等)灵活的配置依赖项,**事实上被 Spring 管理的资源都统称为 `bean`**

  - 通过接口允许 Spring 利用 **JDK 动态代理(Proxy)**为横切关注点提供 `AOP` 的功能
    - Spring 的**事务管理**就是 AOP 的典型应用

### IOC 类型

- *IOC的核心是 DI* , 旨在提供一种更简单的机制来设置`组件依赖项`(对 IOC 来说则可以理解为目标对象),并且**在生命周期中管理这些对象**
- 从**操作对象的方式**来说, IOC 一般有两种类型:
  - `依赖查找`, 通常依赖查找有两种类型
    - **依赖拉取(dependency pull,DL)** 
    - **上下文依赖查找(contextualized dependency lookup,CDL)**
  - `依赖注入`,  通常依赖注入也有两种类型
    - **构造函数注入**
    - **setter注入**

#### 依赖拉取

依赖拉取是最常见的 IOC 类型。在依赖拉取的过程中,根据需要`从注册表中获取依赖项`,流程如下:

![image-20221113130034914](./image/1.IOC/image-20221113130034914.png)

#### 上下文依赖查找

这种查找方式与 DL 相似,但是这种上下文依赖查找直接作用于容器,**而不是注册表**

![image-20221113131524537](./image/1.IOC/image-20221113131524537.png)

我们可以看到**组件调用容器的查找方法查询依赖项,然后将依赖项设置到本身**

```java title="CDL 模拟代码"
/**
 * <b>容器接口</b>
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public interface Container {
    /**
     * 提供给外部根据依赖名称获取容器中的管理对象
     * @param dependencyName
     * @return Object
     */
    Object getDependency(String dependencyName);
}

/**
 * <b>组件的接口,直接作用于容器</b>
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public interface Component {
    /**
     * 利用容器查询组件,而不是注册表
     * @param container
     */
    void allowQuery(Container container);
}

/**
 * <b>组件</b>
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class CDLComponent implements Component {
    private Dependency dependency;
    @Override
    public void allowQuery(Container container) {
      	// 直接利用容器的方法查询依赖
        // highlight-start
        this.dependency = (Dependency)container.getDependency("dependenceyName");
	      // highlight-end
    }
}
```

#### 构造函数注入

- **当组件的构造函数中提供了某些依赖项后,就会发生`构造函数依赖注入`**,即声明**一个或者一组构造函数,并且其他依赖项作为参数,然后该组件在实例化的时候会由`IOC容器`将依赖项作为构造函数的参数传入给组件**
- 构造函数有一个问题就是: <mark>如果某个依赖项不存在的话,那么该组件也无法被创建初始化</mark> 

```java title="构造函数注入的模拟代码"
public class ContructorInjection {
  	private Dependency dependency;
    // highlight-start
  	// 依赖项作为组件构造函数的参数
  	public ContructorInjection(Dependency dependency) {
      this.dependency = dependency;
    }
    // highlight-end
}
```

#### Setter 注入

- 相对于构造函数来说,Setter 注入则是利用的符合 JavaBean 规约的 `Setter 方法`,将依赖项注入到组件中
- Setter 注入的好处是: 即使组件的某个依赖不存在的话,这个组件也还可以被创建,后期需要的话再利用 setter 方法进行设置
  - 所以:setter 注入是使用最为广泛的依赖注入方式

```java title="Setter 注入的模拟代码"
	public class SetterInjection {
  	private Dependency dependency;
    // highlight-start
    public void setDependency(Dependency dependency) {
       this.dependency = dependency;
    }
    // highlight-end
  }
```

:::tip 说明

1. 事实上,在 Spring 中还提供了另外一种依赖注入方式: `字段注入(Field Injection)`,在后面的`@AutoWire` 注解的自动装配中会说明
2. 使用依赖查找还是依赖注入,大多数的情况下是由IOC容器确定的
   - 比如: 使用 EJB2.1 或者更早的版本的话,就必须使用依赖查找,通过 JNDI 从EJB 容器志平获取 EJB
   - 在 Spring 中,除了初始 Bean 的查找, **组件及其依赖项使用使用依赖注入的方式**

3. 如果可以选择依赖查找还是依赖注入,那么依旧是依赖注入,因为依赖查找的耦合性较高,需要主动从容器获取,而依赖注入对组件代码没有任何影响

:::

## Spring 的依赖注入

> IOC 是 Spring 的重要组成部分,Spring 实现的核心是基于 DI,虽然也使用了 DL,但是DI 的优先级高于 DL
>
> Spring 对于 DI 的支持是很全面的,不仅仅支持 Setter 注入、构造函数注入,还支持方法注入

### BeanFactory

- Spring IOC容器的核心是`BeanFactory 接口`,BeanFactory 负责**管理组件,包括组件的依赖项以及组件的生命周期**。在 Spring 的术语中,我们将由容器管理的任何组件都称之为`Bean`
- 虽然 BeanFactory可以通过编程的方式设置,但是更加常见的方式就是使用*配置文件*
  - **Bean 的配置信息由 `BeanDefinition 接口`实现类的实例表示,Bean 的配置信息中还包含了该 Bean 的依赖项信息**
  - **对于实现了 BeanDefinitionReader 接口的 BeanFactory 实现类来说,通过 `PropertiesBeanDefinitionReader`或`XmlBeanDefinitionReader` 从配置文件中读取配置信息,前者利用properties 文件,后者则是 Xml 文件**

#### BeanFactory 实现

我们可以利用下面的方式初始化并且获取Bean, `DefaultListableBeanFactory` 是 Spring 提供的BeanFactory 两种主要实现之一

```java
public class XmlConfigWithBeanFactory {
     public static void main(String[] args) {
        // highlight-start
        DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
        reader.loadBeanDefinitions("xml-config-with-beanFactory.xml");
       // highlight-end
        Address address = (Address)factory.getBean("CZ_Address");
        System.out.println(address);
    }
}
```

### ApplicationContext

- 我们可以自定义 BeanFactory 的实现类来满足自己的业务需求,但是这个非常复杂。

- 在 Spring 中,`ApplicationContext` 接口是 BeanFactory 的一个拓展。除了常规的 DI 功能,还提供了其他功能,比如`事务、AOP、国际化(i18n)的消息源、事件处理...`所以实际开发的时候建议通过 ApplicationContext 接口与 Spring 交互

#### 基本配置

对于 Spring 的 XML 配置文件来说,需要使用 Spring 提供的*namespace*,下面的是最基本的示例:

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
 </beans>
```

但是除了 beans 的 namespace,Spring 还提供了很多其他的namespace,比如针对 ApplicationContext配置的`Context`,用于 AOP 支持的`aop`,用于事务支持的`tx`…

如果需要对使用 Spring 的注解支持,可以在 XML 中进行使用`context的包扫描`配置,通过**Component-Scan**可以扫描指定包下面被@Component 以及派生注解标记的 Bean。当然,也支持对扫描进行过滤。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       	http://www.springframework.org/schema/beans/spring-beans.xsd
        <!--highlight-start-->                   
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/spring-context.xsd">
  <!--highlight-end-->       
  <!-- 开启支持 Spring 的注解扫描,设置扫描的基础包路径 -->
  <!--highlight-start-->           
  <context:component-scan base-package="Demo2">
  </context:component-scan>
  <!--highlight-end-->    
</beans>
```

#### Setter 注入示例

:::info 创建 Bean 的示例

```java title="Java 代码"


```

:::
