---
id: 上下文生命周期
title: 应用上下文生命周期
---

## 应用上下文启动准备(prepareRefresh)

Spring 应用上下文启动准备阶段的处理入口在: `AbstractApplicationContext#prepareRefresh`, 它主要会做下面一些事:

1. 设置启动时间: startupDate
2. 设置状态标识: closed(false)、active(true)
3. 初始化 PropertySources: `initPropertySources()`
    - 这里的处理由子类实现
4. 检验 Environment 中的必须属性: `getEnvironment().validateRequiredProperties()`
    - *getEnvironment* 中,如果上下文的 Environment 对象为空,则会创建
5. 初始化事件监听集合
6. 初始化早期 Spring 事件集合

```java
protected void prepareRefresh() {
  this.startupDate = System.currentTimeMillis();
  this.closed.set(false);
  this.active.set(true);

  // 这类
  initPropertySources();
  getEnvironment().validateRequiredProperties();

  if (this.earlyApplicationListeners == null) {
    this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);
  }
  else {
    this.applicationListeners.clear();
    this.applicationListeners.addAll(this.earlyApplicationListeners);
  }
  this.earlyApplicationEvents = new LinkedHashSet<>();
}

// 如果上下文中不包含 environment,则会创建
public ConfigurableEnvironment getEnvironment() {
  if (this.environment == null) {
    this.environment = createEnvironment();
  }
  return this.environment;
}
```

:::tip 小技巧
可以在 Spring 应用上下文 prepareRefresh 之前, 通过 `setEnvironment` 方法提前装配好 Environment,这个操作在 SpringBoot 有很多.
:::

## BeanFactory 创建(obtainFreshBeanFactory)

Spring 应用上下文中 BeanFactory 创建的处理入口在: `AbstractApplicationContext#obtainFreshBeanFactory`, 它主要会做下面一些事:

1. 刷新 Spring 应用上下文底层 BeanFactory: `refreshBeanFactory()`
    - 如果已经存在,则销毁或者关闭 BeanFactory
    - 创建 BeanFactory: `createBeanFactory()`
    - 设置 BeanFactory Id
    - 设置 "是否允许 BeanDefinition 重复定义": `customizeBeanFactory()`
    - 设置 "是否允许 循环引用(依赖)": `customizeBeanFactory()`
    - 加载 BeanDefinition - `loadBeanDefinitions()`
    - 关联创建的 BeanFactory 到 Spring 应用上下文
2. 返回 Spring 应用上下文底层 BeanFactory: `getBeanFactory()`

```java title="AbstractRefreshableApplicationContext#refreshBeanFactory"
protected final void refreshBeanFactory() throws BeansException {
  if (hasBeanFactory()) {
    destroyBeans();
    closeBeanFactory();
  }
  try {
    DefaultListableBeanFactory beanFactory = createBeanFactory();
    beanFactory.setSerializationId(getId());
    customizeBeanFactory(beanFactory);
    loadBeanDefinitions(beanFactory);
    // 关联创建的 BeanFactory 到 Spring 应用上下文
    synchronized (this.beanFactoryMonitor) {
      this.beanFactory = beanFactory;
    }
  }
  catch (IOException ex) {
    throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
  }
}
```

## BeanFactory 准备(prepareBeanFactory)

Spring 应用上下文中 BeanFactory 准备的处理入口在: `AbstractApplicationContext#prepareBeanFactory`, 它主要会做下面一些事:

1. 关联 ClassLoader, 把 ApplicationContext 的 ClassLoader 传递到 BeanFactory 中
    - 比如: 对于 XML 配置的 Bean 来说,没有 Class 的概念,所以加载这个 Bean 的话需要传入 ClassLoader
2. 设置 Bean 表达式处理器,与 SpEl 相关
3. 添加 PropertyEditorRegistrar 实现: `ResourceEditorRegistrar`
4. 添加 Aware 回调接口 *BeanPostProcessor* 实现 `ApplicationContextAwareProcessor`
    - 这里就是 [ApplicationContext 环境下,Aware 接口的回调](Bean生命周期#依赖applicationcontext)
5. 忽略 Aware 回调接口作为 依赖注入接口
6. 注册游离对象(**ResolvableDependency**)
    - `BeanFactory`
    - `ResourceLoader`
    - `ApplicationEventPublisher`
    - `ApplicationContext`
7. 注册 BeanPostProcessor 子类: ApplicationListenerDetector 对象
    - **注册所有 ApplicationListener 的 作用域为单例(singleton)的对象**
8. 如果存在 *beanName="loadTimeWeaver"*,就注册 BeanPostProcessor 子类 `LoadTimeWeaverAwareProcessor`
9. 如果存在 *beanName="environment"*, 就注册 **"单例对象(外部对象)"** : `Environment`
10. 如果存在 *beanName="systemProperties"*, 就注册 **"单例对象(外部对象)"** : `Java System Properties`
11. 如果存在 *beanName="systemEnvironment"*, 就注册 **"单例对象(外部对象)"** : `OS 环境变量`

```java title="AbstractApplicationContext#prepareBeanFactory"
protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
  // Tell the internal bean factory to use the context's class loader etc.
  beanFactory.setBeanClassLoader(getClassLoader());
  beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
  beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

  // Configure the bean factory with context callbacks.
  beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
  beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
  beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
  beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
  beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
  beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
  beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

  // BeanFactory interface not registered as resolvable type in a plain factory.
  // MessageSource registered (and found for autowiring) as a bean.
  beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
  beanFactory.registerResolvableDependency(ResourceLoader.class, this);
  beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
  beanFactory.registerResolvableDependency(ApplicationContext.class, this);

  // Register early post-processor for detecting inner beans as ApplicationListeners.
  beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

  // Detect a LoadTimeWeaver and prepare for weaving, if found.
  if (beanFactory.containsBean("loadTimeWeaver")) {
    beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
    // Set a temporary ClassLoader for type matching.
    beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
  }

  // Register default environment beans.
  if (!beanFactory.containsLocalBean("environment")) {
    beanFactory.registerSingleton("environment", getEnvironment());
  }
  if (!beanFactory.containsLocalBean("systemProperties")) {
    beanFactory.registerSingleton("systemProperties", getEnvironment().getSystemProperties());
  }
  if (!beanFactory.containsLocalBean("systemEnvironment")) {
    beanFactory.registerSingleton("systemEnvironment", getEnvironment().getSystemEnvironment());
  }
}
```

## BeanFactory 后置处理

> **此时所有的 BeanDefinition 都已经被加载了, 但尚未实例化任何 Bean**

Spring 应用上下文中BeanFactory 后置处理的有两部分:

1. postProcessBeanFactory
2. invokeBeanFactoryPostProcessors

### postProcessBeanFactory

- 这一步的操作是一个空实现, **一般由子类覆盖该方法**,入口为:  `AbstractApplicationContext#postProcessBeanFactory`
  - 比如某些 ApplicationContext 会在该方法中注册特殊的 BeanPostProcessor 、Bean 、Bean 的作用域等

我们看下 WebMvc 的GenericWebApplicationContext 对该方法的实现:

```java title="GenericWebApplicationContext#postProcessBeanFactory"
protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
  if (this.servletContext != null) {
    // 注册 ServletContextAwareProcessor
    beanFactory.addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext));
    beanFactory.ignoreDependencyInterface(ServletContextAware.class);
  }
  // 注册 web 应用程序的作用域,比如
  WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);
  WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext);
}

// WebApplicationContextUtils#registerWebApplicationScopes
public static void registerWebApplicationScopes(ConfigurableListableBeanFactory beanFactory,
                                                ServletContext sc) {
  // 作用域的注册(Request、Session、Application)
  beanFactory.registerScope(WebApplicationContext.SCOPE_REQUEST, new RequestScope());
  beanFactory.registerScope(WebApplicationContext.SCOPE_SESSION, new SessionScope());
  if (sc != null) {
    ServletContextScope appScope = new ServletContextScope(sc);
    beanFactory.registerScope(WebApplicationContext.SCOPE_APPLICATION, appScope);
    sc.setAttribute(ServletContextScope.class.getName(), appScope);
  }
  // 注册 ResolvableDependency
  beanFactory.registerResolvableDependency(ServletRequest.class, new RequestObjectFactory());
  beanFactory.registerResolvableDependency(ServletResponse.class, new ResponseObjectFactory());
  beanFactory.registerResolvableDependency(HttpSession.class, new SessionObjectFactory());
  beanFactory.registerResolvableDependency(WebRequest.class, new WebRequestObjectFactory());
  if (jsfPresent) {
    FacesDependencyRegistrar.registerFacesDependencies(beanFactory);
  }
}
```

:::tip 说明
这种通过继承的方式去拓展 BeanFactory 过于麻烦,一般来说建议通过 [invokeBeanFactoryPostProcessors](上下文生命周期#invokebeanfactorypostprocessors) 的方式拓展 BeanFactory
:::

### invokeBeanFactoryPostProcessors

这一步的入口为:  `AbstractApplicationContext#invokeBeanFactoryPostProcessors`, 它主要会做下面一些事:

1. 调用 `BeanFactoryPostProcessor` 或 `BeanDefinitionRegistryPostProcessor` 的后置处理方法
    - BeanDefinitionRegistryPostProcessor 是 BeanFactoryPostProcessor 子接口
2. 如果需要的话, 注册 `LoadTimeWeaverAwareProcessor`

```java title="AbstractApplicationContext#invokeBeanFactoryPostProcessors"
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
  // highlight-start
  // 执行 BeanFactory 的后置处理方法
  PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
  // highlight-end

  // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
  // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
  if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean("loadTimeWeaver")) {
    beanFactory.addBeanPostProcessor(new  (beanFactory));
    beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
  }
}
```

而实际上是调用委托方法`PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors`,有如下的处理流程:

1. 如果当前 BeanFactory 是 BeanDefinitionRegistry
    - 遍历与当前应用上下文中关联的 BeanFactoryPostProcessor(通过 *addBeanFactoryPostProcessor* 添加进来的)
      - 如果是 **BeanDefinitionRegistryPostProcessor**, 就执行 `postProcessBeanDefinitionRegistry` 方法,在添加到 `registryProcessor` 中
      - 否则就添加到 `regularPostProcessors`
    - 通过依赖查找获取容器中**注册**的 `BeanDefinitionRegistryPostProcessor` 类型的 Bean (忽略 FactoryBean) [ **会有 3 次相同的依赖查找过程,但里面判断逻辑不同** ]
      - **第 1 次依赖查找的判断过程** :
        - 判断该 Bean 是否实现了 `PriorityOrdered` 接口,如果有则其添加到`registryProcessors` 中,并在排序后执行其 `postProcessBeanDefinitionRegistry`
      - **第 2 次依赖查找的判断过程** :
        - 判断该 Bean 是否实现了 `Ordered` 接口,如果有则其添加到`registryProcessors` 中,并在排序后执行其 `postProcessBeanDefinitionRegistry`
      - **第 3 次依赖查找的判断过程** :
        - 将剩余的 Bean 添加到`registryProcessors` 中,并在排序后执行其 `postProcessBeanDefinitionRegistry`
    - 执行 *registryProcessor* 中的 `postProcessBeanFactory` 方法
    - 执行 *regularPostProcessors* 中的 `postProcessBeanFactory` 方法
2. 如果当前 BeanFactory 不是 BeanDefinitionRegistry,执行 当前应用上下文中关联的 BeanFactoryPostProcessor 的 `postProcessBeanFactory` 方法
3. 通过依赖查找获取容器中注册的 `BeanFactoryPostProcessor` 类型的 Bean (忽略 FactoryBean)
    - 如果该 Bean 实现了 `PriorityOrdered` 接口,则将其添加到 `priorityOrderedPostProcessors` 中
    - 否则, 如果该 Bean 实现了 `Ordered` 接口,则将其添加到 `orderedPostProcessorNames` 中
    - 否则, 就将其添加到 `nonOrderedPostProcessorNames` 中
4. 对 *priorityOrderedPostProcessors* 排序,并执行`postProcessBeanFactory` 方法
5. 对 *orderedPostProcessorNames* 排序,并执行`postProcessBeanFactory` 方法
6. 执行 *nonOrderedPostProcessorNames* 的 `postProcessBeanFactory` 方法

:::caution 注意
总的来说,有以下的注意点:

1. 先处理 BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry 方法,在处理 BeanFactoryPostProcessor#postProcessBeanFactory
2. 对于**实现了优先级接口(PriorityOrdered、Ordered) 来说**,先处理 PriorityOrdered,再处理 Ordered
3. 对于**关联应用上下文的后置处理器 和 在应用上下文注册的后置处理器 Bean**,先处理关联的,再处理注册的 BeanDefinition

:::

```java title="PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors"
/**
 * @param beanFactory BeanFactory
 * @param beanFactoryPostProcessors 所有的 BeanFactoryProcessor
 */
public static void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory,
                                                   List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {
  Set<String> processedBeans = new HashSet<>();

  if (beanFactory instanceof BeanDefinitionRegistry) {
    BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
    List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();
    List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();

    for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
      if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
        BeanDefinitionRegistryPostProcessor registryProcessor =
            (BeanDefinitionRegistryPostProcessor) postProcessor;
        registryProcessor.postProcessBeanDefinitionRegistry(registry);
        registryProcessors.add(registryProcessor);
      }
      else {
        regularPostProcessors.add(postProcessor);
      }
    }
    List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();
    // 首先,执行 实现了 PriorityOrdered 接口的 BeanDefinitionRegistryPostProcessor 的 postProcessBeanDefinitionRegistry 方法
    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    for (String ppName : postProcessorNames) {
      if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
        processedBeans.add(ppName);
      }
    }
    sortPostProcessors(currentRegistryProcessors, beanFactory);
    registryProcessors.addAll(currentRegistryProcessors);
    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
    currentRegistryProcessors.clear();

    // 然后,执行 实现了 Ordered 接口的 BeanDefinitionRegistryPostProcessor 的 postProcessBeanDefinitionRegistry 方法
    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    for (String ppName : postProcessorNames) {
      if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
        processedBeans.add(ppName);
      }
    }
    sortPostProcessors(currentRegistryProcessors, beanFactory);
    registryProcessors.addAll(currentRegistryProcessors);
    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
    currentRegistryProcessors.clear();

    // 最后, 执行剩余的 BeanDefinitionRegistryPostProcessor 接口的 postProcessBeanDefinitionRegistry 方法
    boolean reiterate = true;
    while (reiterate) {
      reiterate = false;
      // 只获取 Bean 的名称,而不是直接 getBean 实例化
      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      for (String ppName : postProcessorNames) {
        if (!processedBeans.contains(ppName)) {
          currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
          processedBeans.add(ppName);
          reiterate = true;
        }
      }
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      registryProcessors.addAll(currentRegistryProcessors);
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();
    }

    // 执行  BeanFactoryPostProcessor#postProcessBeanFactory
    invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
    invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
  }
  else {
    // 执行与 应用上下文关联的 BeanFactoryPostProcessor#postProcessBeanFactory
    invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
  }

  String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
  List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
  List<String> orderedPostProcessorNames = new ArrayList<>();
  List<String> nonOrderedPostProcessorNames = new ArrayList<>();
  for (String ppName : postProcessorNames) {
    if (processedBeans.contains(ppName)) {
      // skip - already processed in first phase above
    }
    else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
      priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
    }
    else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
      orderedPostProcessorNames.add(ppName);
    }
    else {
      nonOrderedPostProcessorNames.add(ppName);
    }
  }
  // 首先,执行 实现了 PriorityOrdered 接口的 BeanFactoryPostProcessor 的 postProcessBeanFactory 方法
  sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
  invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

  // 然后,执行 实现了 Ordered 接口的 BeanFactoryPostProcessor 的 postProcessBeanFactory 方法
  List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());
  for (String postProcessorName : orderedPostProcessorNames) {
    orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
  }
  sortPostProcessors(orderedPostProcessors, beanFactory);
  invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

  // 最后, 执行剩余的 BeanFactoryPostProcessor 接口的 postProcessBeanFactory 方法
  List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());
  for (String postProcessorName : nonOrderedPostProcessorNames) {
    nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
  }
  invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);
  beanFactory.clearMetadataCache();
}
```

## BeanFactory 注册 BeanPostProcessor (registerBeanPostProcessors)

Spring 应用上下文中 BeanFactory 注册BeanPostProcessor 的入口: `AbstractApplicationContext#registerBeanPostProcessors`:

```java
protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {
  PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);
}
```

可以看出来,实际上会委托 `PostProcessorRegistrationDelegate#registerBeanPostProcessors` 进行注册 BeanPostProcessor,大致有下面的几步:

1. 实现获取所有注册的 `BeanPostProcessor`  BeanDefinition 的 beanName
    - 如果该 BeanDefinition 对应的 bean 实现了 `PriorityOrdered` 接口,则添加到 `priorityOrderedPostProcessors`
      - 如果该 BeanPostProcessor 还实现了 `MergedBeanDefinitionPostProcessor` 接口,则还会添加到 `internalPostProcessors`
      - **注意: 这里会提前初始化实现了 PriorityOrdered 接口的 BeanPostProcessor**
    - 如果该 BeanDefinition 对应的 bean 实现了 `Ordered` 接口,则添加到 `orderedPostProcessorNames`
    - 剩余的添加到 `nonOrderedPostProcessorNames`

2. 排序并注册 *priorityOrderedPostProcessors* 中的 BeanPostProcessor
3. 遍历 *orderedPostProcessorNames*, 通过 `getBean` 会实例化 BeanPostProcessor,将其添加到 `orderedPostProcessors` 中
    - 如果该 BeanPostProcessor 还实现了 `MergedBeanDefinitionPostProcessor` 接口,则还会添加到 `internalPostProcessors`
4. 排序并注册 *orderedPostProcessors* 中的 BeanPostProcessor

5. 遍历 *nonOrderedPostProcessorNames*, 通过 `getBean` 会实例化 BeanPostProcessor,将其添加到 `nonOrderedPostProcessors` 中
    - 如果该 BeanPostProcessor 还实现了 `MergedBeanDefinitionPostProcessor` 接口,则还会添加到 `internalPostProcessors`
6. 注册 *nonOrderedPostProcessors* 中的 BeanPostProcessor
7. 排序并注册 *internalPostProcessors* 中的 BeanPostProcessor
8. 注册 `ApplicationListenerDetector`

:::info 总结
总的来说就是:

1. 注册 `PriorityOrdered` 类型的 BeanPostProcessor
2. 注册 `Ordered` 类型的 BeanPostProcessor
3. 注册 `普通`的 BeanPostProcessor
4. 注册 MergedBeanDefinitionPostProcessor
5. 注册 ApplicationListenerDetector

:::

```java title="oPostProcessorRegistrationDelegate#registerBeanPostProcessors"
public static void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory,
                                              AbstractApplicationContext applicationContext) {

  String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);
  int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
  beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

  List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
  List<BeanPostProcessor> internalPostProcessors = new ArrayList<>();
  List<String> orderedPostProcessorNames = new ArrayList<>();
  List<String> nonOrderedPostProcessorNames = new ArrayList<>();
  for (String ppName : postProcessorNames) {
    if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
      priorityOrderedPostProcessors.add(pp);
      if (pp instanceof MergedBeanDefinitionPostProcessor) {
        internalPostProcessors.add(pp);
      }
    }
    else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
      orderedPostProcessorNames.add(ppName);
    }
    else {
      nonOrderedPostProcessorNames.add(ppName);
    }
  }

  // 首先注册所有实现了 PriorityOrdered 接口的 BeanPostProcessor [先排序,后注册]
  sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
  registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

  // 然后,注册所有实现了 Ordered 接口的 BeanPostProcessor [先排序,后注册]
  List<BeanPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());
  for (String ppName : orderedPostProcessorNames) {
    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
    orderedPostProcessors.add(pp);
    if (pp instanceof MergedBeanDefinitionPostProcessor) {
      internalPostProcessors.add(pp);
    }
  }
  sortPostProcessors(orderedPostProcessors, beanFactory);
  registerBeanPostProcessors(beanFactory, orderedPostProcessors);

  // 最后,注册剩余的 BeanPostProcessor
  List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());
  for (String ppName : nonOrderedPostProcessorNames) {
    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
    nonOrderedPostProcessors.add(pp);
    if (pp instanceof MergedBeanDefinitionPostProcessor) {
      internalPostProcessors.add(pp);
    }
  }
  registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

  // 对实现了 MergedBeanDefinitionPostProcessor 接口的 BeanPostProcessor 进行排序,然后注册
  sortPostProcessors(internalPostProcessors, beanFactory);
  registerBeanPostProcessors(beanFactory, internalPostProcessors);

  // 注册 ApplicationListenerDetector
  beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
}
```

## 初始化消息源(initMessageSource)

> 该部分对应[国际化](国际化)

Spring 应用上下文中 初始化 MessageSource 的入口: `AbstractApplicationContext#initMessageSource`,主要的逻辑是:

1. 如果"本地的"容器中包含 *beanName="messageSource"* 的 BeanDefinition,就通过 *getBean* 的方式实例化,并且设置为与当前应用上下文关联的 MessageSource
2. 否则的话,就创建一个空实现 `DelegatingMessageSource`,与当前应用上下文关联

```java title="AbstractApplicationContext#initMessageSource"
protected void initMessageSource() {
  ConfigurableListableBeanFactory beanFactory = getBeanFactory();
  if (beanFactory.containsLocalBean("messageSource")) {
    this.messageSource = beanFactory.getBean("messageSource", MessageSource.class);
    if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) {
      HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;
      if (hms.getParentMessageSource() == null) {
        hms.setParentMessageSource(getInternalParentMessageSource());
      }
    }
  }
  else {

    // 没有 Bean 的话,就注册一个默认的空实现 DelegatingMessageSource
    DelegatingMessageSource dms = new DelegatingMessageSource();
    dms.setParentMessageSource(getInternalParentMessageSource());
    this.messageSource = dms;
    beanFactory.registerSingleton("messageSource", this.messageSource);
  }
}
```

可以看到: `MessageSource` 默认是空实现 *DelegatingMessageSource*, 也就是没有任何国际化文案信息。如果需要的话则应该手动注册,**一般来说在 BeanFactoryPostProcessor 中注册相关的 BeanDefinition**(不在 BeanPostProcessor 中处理是因为还没有执行 Bean 后置处理方法)

## 初始化事件广播器(initApplicationEventMulticaster)

> 该部分对应[事件编程](事件编程)

Spring 应用上下文中 初始化事件广播器 的入口: `AbstractApplicationContext#initApplicationEventMulticaster`,主要的逻辑是:

1. 如果"本地的"容器中包含 *beanName="applicationEventMulticaster"* 的 BeanDefinition,就通过 *getBean* 的方式实例化,并且设置为与当前应用上下文关联的 ApplicationEventMulticaster

2. 否则的话,就创建一个 `SimpleApplicationEventMulticaster`,与当前应用上下文关联

```java title="AbstractApplicationContext#initApplicationEventMulticaster"
protected void initApplicationEventMulticaster() {
  ConfigurableListableBeanFactory beanFactory = getBeanFactory();
  // 如果存在 beanName = "applicationEventMulticaster" 的话,就使用它
  if (beanFactory.containsLocalBean("applicationEventMulticaster")) {
    this.applicationEventMulticaster =
        beanFactory.getBean("applicationEventMulticaster", ApplicationEventMulticaster.class);
  }
  else {
    // 如果没有 beanName = "applicationEventMulticaster" 的话,就创建一个  SimpleApplicationEventMulticaster
    this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
    beanFactory.registerSingleton("applicationEventMulticaster", this.applicationEventMulticaster);
  }
}
```

可以看出来,初始化事件广播器的逻辑和初始化 MessageSource 差不多,也可以**手动注册事件广播器**,但是 Spring 默认注册的 `SimpleApplicationEventMulticaster` 事件广播器基本是可以满足日常使用的

## 应用上下文刷新(onRefresh)

和 [Bean 后置处理的 postprocessbeanfactory](上下文生命周期#postprocessbeanfactory) 一样, 这一步**也是一个空实现,也是通过子类覆盖的方式进行扩展**,它的入口在: `AbstractApplicationContext#onRefresh`

```java title="AbstractApplicationContext#onRefresh"
protected void onRefresh() throws BeansException {
  // For subclasses: do nothing by default.
}
```

比如在 WebMVc 中就对它进行了拓展,初始化了主题资源

```java title="AbstractRefreshableWebApplicationContext#onRefresh"
@Override
protected void onRefresh() {
  this.themeSource = UiApplicationContextUtils.initThemeSource(this);
}
```

再比如在 `ReactiveWebServer` 中,它会去创建一个 webServer,SpringBoot 就是据此进行拓展(<mark>通过应用上下文去启动内嵌的容器</mark>):

```java title="ReactiveWebServerApplicationContext#onRefresh"
@Override
protected void onRefresh() {
  super.onRefresh();
  try {
    createWebServer();
  }
  catch (Throwable ex) {
    throw new ApplicationContextException("Unable to start reactive web server", ex);
  }
}
```

## 注册事件监听器(registerListeners)

> 该部分对应[事件编程](事件编程)

Spring 应用上下文中 注册事件监听器 的入口: `AbstractApplicationContext#registerListeners`, 它主要会做下面一些事:

1. 添加与当前应用上下文所关联的 ApplicationListener 对象(集合)
2. 添加 BeanFactory 中注册的 ApplicationListener Beans (忽略 FactoryBean)
3. 发布 Spring 的[早期事件](上下文生命周期#应用上下文启动准备preparerefresh)

```java title="AbstractApplicationContext#registerListeners"
  protected void registerListeners() {
    // 添加与当前应用上下文所关联的 ApplicationListener
    for (ApplicationListener<?> listener : getApplicationListeners()) {
      getApplicationEventMulticaster().addApplicationListener(listener);
    }

    // 添加 BeanFactory 中注册的 ApplicationListener Beans (忽略 FactoryBean)
    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
    for (String listenerBeanName : listenerBeanNames) {
      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
    }

    // 发布 Spring 的 早期事件
    Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;
    this.earlyApplicationEvents = null;
    if (earlyEventsToProcess != null) {
      for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
        getApplicationEventMulticaster().multicastEvent(earlyEvent);
      }
    }
  }
```

## BeanFactory 初始化完成(finishBeanFactoryInitialization)

Spring 应用上下文中 BeanFactory 初始化完成 的入口: `AbstractApplicationContext#finishBeanFactoryInitialization`, 它主要会做下面一些事:

1. 如果存在 *beanName="conversionService"* 的 ConversionService,就将其与应用上下文进行关联, [参见 ConversionService](类型转换#统一类型转换服务conversionservice)
2. 通过Lambda 表达式的方式添加 `StringValueResolver`, [参见 @Value 的原理](Environment抽象#value-基本流程)
3. 依赖查找 `LoadTimeWeaverAware` Bean
4. BeanFactory 设置 临时 ClassLoader 为 null
5. BeanFactory 冻结配置,类似于一种快照
6. **BeanFactory 初始化非延迟单例 Beans** : `preInstantiateSingletons`

```java title="AbstractApplicationContext#finishBeanFactoryInitialization"
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
  // 如果存在 beanName = conversionService 的话,就将其与应用上下文关联
  if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
    beanFactory.setConversionService(beanFactory.getBean("conversionService", ConversionService.class));
  }

  // 通过Lambda 表达式的方式添加 StringValueResolver
  if (!beanFactory.hasEmbeddedValueResolver()) {
    beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));
  }

  String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
  for (String weaverAwareName : weaverAwareNames) {
    getBean(weaverAwareName);
  }

  beanFactory.setTempClassLoader(null);
  beanFactory.freezeConfiguration();
  // 初始化非延迟加载的单例 Bean
  beanFactory.preInstantiateSingletons();
}
```

所以,**注册的非单例的 BeanDefinition 会在 `preInstantiateSingletons` 中完成实例化、初始化的过程**,主要有如下的处理逻辑:

1. 如果 BeanDefinition 是一个 FactoryBean,就判断是否"饥饿加载" `isEagerInit`,如果是的话则通过 getBean 的方式进行实例化
2. 如果不是 FactoryBean, 则通过 getBean 的方式实例化 Bean
3. 最后如果实例化后的单例 Bean 实现了 `SmartInitializingSingleton` 接口,则调用该 Bean 的 `afterSingletonsInstantiated`方法,详细参看[这里](Bean生命周期#初始化完成后)

```java title="DefaultListableBeanFactory#preInstantiateSingletons"
public void preInstantiateSingletons() throws BeansException {
  List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);

  for (String beanName : beanNames) {
    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
    if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
      if (isFactoryBean(beanName)) {
        Object bean = getBean("&" + beanName);
        if (bean instanceof FactoryBean) {
          final FactoryBean<?> factory = (FactoryBean<?>) bean;
          boolean isEagerInit;
          // ...
          isEagerInit = (factory instanceof SmartFactoryBean && ((SmartFactoryBean<?>) factory).isEagerInit());
          if (isEagerInit) {
            getBean(beanName);
          }
        }
      }
      else {
        getBean(beanName);
      }
    }
  }
  for (String beanName : beanNames) {
    Object singletonInstance = getSingleton(beanName);
    if (singletonInstance instanceof SmartInitializingSingleton) {
      final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
      // ...
      smartSingleton.afterSingletonsInstantiated();
    }
  }
}
```

## 应用上下文刷新完成(finishRefresh)

Spring 应用上下文 刷新完成 的入口: `AbstractApplicationContext#finishRefresh`, 它主要会做下面一些事:

1. 清除 `ResourceLoader` 缓存: `clearResourceCaches`  [@since 5.0]
2. 初始化 `LifecycleProcessor` 对象: `initLifecycleProcessor()`
    - 如果存在 beanName="lifecycleProcessor",就将其与应用上下文关联,否则就创建一个 *DefaultLifecycleProcessor*
3. 调用 `LifecycleProcessor#onRefresh` 方法
4. 发布 Spring 应用上下文已刷新事件: `ContextRefreshedEvent`
5. 向 `MBeanServer` 托管 Live Beans

```java
protected void finishRefresh() {
  // 清空资源缓存
  clearResourceCaches();

  // 初始化生命周期处理器
  initLifecycleProcessor();
  getLifecycleProcessor().onRefresh();

  // 发布容器刷新完成事件
  publishEvent(new ContextRefreshedEvent(this));

  LiveBeansView.registerApplicationContext(this);
}
```

## 应用上下文启动(start)

Spring 应用上下文 启动 的入口: `AbstractApplicationContext#start`, 它主要会做下面一些事:

1. 启动 LifecycleProcessor : `LifecycleProcessor#start`
2. 发布 Spring 上下文已启动事件 `ContextStartedEvent`

```java title="AbstractApplicationContext#start"
public void start() {
  // 启动 LifecycleProcessor
  getLifecycleProcessor().start();
  // 发布 Spring 上下文已启动事件
  publishEvent(new ContextStartedEvent(this));
}
```

## 应用上下文停止(stop)

Spring 应用上下文 停止 的入口: `AbstractApplicationContext#stop`, 它主要会做下面一些事:

1. 停止 LifecycleProcessor : `LifecycleProcessor#stop`
2. 发布 Spring 上下文已停止事件 `ContextStoppedEvent`

```java title="AbstractApplicationContext#stop"
getLifecycleProcessor().stop();
publishEvent(new ContextStoppedEvent(this));
```

## 应用上下文关闭(close)

Spring 应用上下文 关闭 的入口: `AbstractApplicationContext#close`, 它主要会做下面一些事:

```java title="AbstractApplicationContext#close"
public void close() {
  synchronized (this.startupShutdownMonitor) {
    // highlight-start
    doClose();
    // highlight-end
    // If we registered a JVM shutdown hook, we don't need it anymore now:
    // We've already explicitly closed the context.
    if (this.shutdownHook != null) {
      try {
        Runtime.getRuntime().removeShutdownHook(this.shutdownHook);
      }
      catch (IllegalStateException ex) {
        // ignore - VM is already shutting down
      }
    }
  }
}
```

上下文关闭的关键是调用了 `doClose` 方法,该方法主要处理以下的事情:

1. 设置状态标识: active(false)、closed(true)
2. Live Beans JMX 取消托管: `LiveBeansView.unregisterApplicationContext`
3. 发布应用上下文已经关闭事件: `ContextClosedEvent`
4. 关闭 `LifecycleProcessor`
5. 销毁 Spring Beans
6. 关闭 BeanFactory
7. 回调 `onClose()`,让子类做一些最终的清理工作

```java title="AbstractApplicationContext#doClose"
protected void doClose() {
  // Check whether an actual close attempt is necessary...
  if (this.active.get() && this.closed.compareAndSet(false, true)) {
    // Live Beans JMX 取消托管
    LiveBeansView.unregisterApplicationContext(this);

    // 发布应用上下文已经关闭事件(ContextClosedEvent)
    publishEvent(new ContextClosedEvent(this));

    // 关闭 LifecycleProcessor
    if (this.lifecycleProcessor != null) {
      this.lifecycleProcessor.onClose();
    }

    // 销毁 Spring Beans
    destroyBeans();

    // 关闭 BeanFactory
    closeBeanFactory();

    // 回调 onClose()
    onClose();

    if (this.earlyApplicationListeners != null) {
      this.applicationListeners.clear();
      this.applicationListeners.addAll(this.earlyApplicationListeners);
    }
    this.active.set(false);
  }
}
```
