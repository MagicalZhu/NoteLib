---
id: 国际化
title: 国际化
---

## 使用场景

主要有下面的几种使用场景:

1. 普通国际化文案
2. Bean Validation 校验国际化文案
3. Web 站点页面渲染
4. webMvc 错误消息提示

## Java 国际化标准实现(ResourceBundle)

- 核心接口
  - 抽象实现: `ResourceBundle`
    - Properties 资源实现: `PropertyResourceBundle`
    - 例举实现: `ListResourceBundle`
- ResourceBundle 核心特性
  - Key-Value 的设计
  - 层次性设计
  - 缓存设计
  - **字符编码控制**: `ResourceBundle.Control` [@since 1.6]
    - 这种方式需要自己去添加字符集的支持
  - **Control SPI 拓展**: `java.util.spi.ResourceBundleControlProvider` [@since 1.8]

- ResourceBundle 的 bundleName 一般来说是 `baseName + _ + language + _ + country`

一个简单的示例:

首先在 classpath 下创建一个 `properties` 文件,文件名为: `db_en.properties`(也就是 baseName = db, language=en)

```ini
user=pacos
```

然后在代码中通过 ResourceBundle 加载资源文件:

```java
public class ResourceBundleDemo {
  static  Locale en = Locale.ENGLISH;

  public static void main(String[] args) throws UnsupportedEncodingException {
    // 创建 ResourceBundle 对象
    ResourceBundle resourceBundle = ResourceBundle.getBundle("db", en);
    String userMsg = resourceBundle.getString("user");
    // out: pacos
    System.out.println(userMsg);
  }
}
```

## Java 文本格式化(MessageFormat)

- 核心接口
  - `java.text.MessageFormat`
- 基本用法
  - 设置消息格式模板: `new MessageFormat(模板字符串)`
  - 格式化: `format(new Object[] {参数列表} )`
- 消息格式模式
  - 格式元素: **{ argument-index,[,format-type, [format-style] ] }**
    - format-type: 消息格式类型,可选值为 `number | date | time | choice`
    - format-style: 消息格式风格,可选值为: `short | medium | long | full | integer | currency | percent`
- 高级特性
  - 重置消息格式模板: `applyPattern`
  - 重置 Locale: `setLocale`
  - 重置 Format: `setFormat(int formatElementIndex, Format newFormat)`

### 基础示例

```java
/**
 * {@link MessageFormat} 的示例
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class MessageFormatDemo {
    public static void main(String[] args) {

        Integer planet = 7;
        String event = "a disturbance in the Force";
        String result = MessageFormat.format(
                "At {1,time, medium} on {1,date,short}, there was {2} on planet {0,number,integer}.",
                planet, new Date(), event);
        // out: At 12:37:28 on 23-7-25, there was a disturbance in the Force on planet 7.
        System.out.println(result);
    }
}
```

### 高级使用示例

```java
/**
 * {@link MessageFormat} 的高级示例
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class MessageFormatDemo2 {
    public static void main(String[] args) {
        Integer planet = 7;
        String event = "a disturbance in the Force";
        String messagePattern = "At {1,time, full} on {1,date,full}, there was {2} on planet {0,number,integer}.";


        // 基本的使用
        MessageFormat messageFormat = new MessageFormat(messagePattern);
        String message = messageFormat.format(new Object[]{planet, new Date(), event});
        // out: At 下午01时12分26秒 CST on 2023年7月25日 星期二, there was a disturbance in the Force on planet 7.
        System.out.println(message);


        // 高级特性: 替换 pattern
        messagePattern = "What i say is : {0}";
        messageFormat.applyPattern(messagePattern);
        message = messageFormat.format(new Object[]{"Hello,World"});
        // out: What i say is : Hello,World
        System.out.println(message);

        // 高级特性: 替换 Locale,需要先设置 Locale,在重置 pattern
        messagePattern = "At {1,time, full} on {1,date,full}, there was {2} on planet {0,number,integer}.";
        messageFormat.setLocale(Locale.ENGLISH);
        messageFormat.applyPattern(messagePattern);
        message =  messageFormat.format(new Object[]{planet, new Date(), event});
        // out: At 1:23:06 PM CST on Tuesday, July 25, 2023, there was a disturbance in the Force on planet 7.
        System.out.println(message);

        // 高级特性: 重置 Format
        messageFormat.setFormat(1, new SimpleDateFormat("YYYY-MM-DD HH:mm:ss"));
        message =  messageFormat.format(new Object[]{planet, new Date(), event});
        // out: At 1:24:06 PM CST on 2023-07-206 13:24:06, there was a disturbance in the Force on planet 7.
        System.out.println(message);
    }
}
```

## Spring 国际化接口(MessageSource)

- 核心接口: `MessageSource`
- 主要概念
  - 文案模板编码(code)
  - 文案模板参数(args)
  - 区域(Locale)

```java
public interface MessageSource {
  // highlight-start
  /**
   * @param code 文案模板编码,比如 'calculator.noRateSet'
   * @param args 文案模板参数,参数可以只给出占位符 {0},也可以给出占位符形式 {1,date}
   * @param defaultMessage 文案解析的兜底方案
   * @param locale 区域
   */
  @Nullable
  String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale);
  // highlight-end
  String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException;
  // MessageSourceResolvable 整合了 code、args、defaultMessage
  String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException;
}
```

MessageSource 是一个`策略接口`,它支持消息的`参数化`以及`国际化`,Spring 提供了两个开箱即用的实现:

1. `ResourceBundleMessageSource`
2. `ReloadableResourceBundleMessageSource`

### 层次性 MessageSource

> 层次性就是当前的类或者接口存在 "parent",这个 parent 可以是具体的类或者接口,也可以是关联某个类/接口的属性(比如 BeanDefinition 只关联了 parent-name)

之前提及的Spring 层次性接口有下面几个:

- HierarchicalBeanFactory
- ApplicationContext
- BeanDefinition

对于国际化接口 MessageSource 来说,也存在层次性: `HierarchicalMessageSource`

```java
public interface HierarchicalMessageSource extends MessageSource {

  void setParentMessageSource(@Nullable MessageSource parent);
  // highlight-start
  // 层次性的体现,可以获取 parent 消息接口
  @Nullable
  MessageSource getParentMessageSource();
  // highlight-end
}
```

**对于 MessageSource 来说,层次性可以在当前 MessageSource 中无法获取国际化文案消息的时候,去 parent MessageSource 中获取。**

### MessageSource 即用实现

> ResourceBundle + MessageFormat ?

MessageSource 了两个开箱即用的实现:

1. 基于 ResourceBundle 和 MessageFormat 实现的: `ResourceBundleMessageSource`
2. 可重载 Properties 和 MessageFormat 实现的: `ReloadableResourceBundleMessageSource`

### MessageSource 内建实现

> 和前面 ResourceLoader 一样,在 Spring 应用上下文的环境下, MessageSource 对象等同于 ApplicationContext 对象

MessageSource 内建 Bean 的可能来源

1. 预注册 Bean 名称为 **messageSource**,类型为 MessageSource
2. 默认内建实现: `DelegatingMessageSource`

在 Spring 应用上下文的 `initMessageSource` 中进行 MessageSource 的内建处理

```java title="AbstractApplicationContext#initMessageSource"
// highlight-start
public static final String MESSAGE_SOURCE_BEAN_NAME = "messageSource";
// highlight-end
protected void initMessageSource() {
  ConfigurableListableBeanFactory beanFactory = getBeanFactory();
  if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {
    // 获取 messageSource
    this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);
    if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) {
      // MessageSource 具有层次性,设置 父 MessageSource
      HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;
      if (hms.getParentMessageSource() == null) {
        hms.setParentMessageSource(getInternalParentMessageSource());
      }
    }
  }
  else {
    // 兜底空实现
    DelegatingMessageSource dms = new DelegatingMessageSource();
    dms.setParentMessageSource(getInternalParentMessageSource());
    this.messageSource = dms;
    beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);
  }
}

protected MessageSource getInternalParentMessageSource() {
  return (getParent() instanceof AbstractApplicationContext ? ((AbstractApplicationContext) getParent()).messageSource : getParent());
}
```

### 问题

SpringBoot 为什么要新建 MessageSource 的 Bean?

1. AbstractApplicantContext 的实现决定了 MessageSource 内建实现
2. SpringBoot 通过外部化配置简化 MessageSource  Bean 构建
3. SpringBoot 基于 Bean Validation 校验很普遍

### 实现配置自动刷新的 MessageSource

> Spring 有内建的 ReloadableResourceBundleMessageSource, 但是它不能够实现自动刷新

这里会采用几种新的技术来实现:

1. Java NIO2 : `java.nio.file.watchService`
2. Java Concurrency: `java.util.concurrent.ExecutorService`
3. Spring: `AbstractMessageSource`

实现步骤:

1. 定位资源位置,比如 *META-INF*
2. 初始化 Properties 文件,比如可以借助资源加载器 ResourceLoader 进行加载读取
3. 实现 DynamicResourceMessageResource#resolveCode 方法
     - 利用传入的文案编码 code 去 Properties 中获取对应的文案模板
4. 监听资源文件(NIO 2 watchService)
    - 操作方式:
      1. 获取当前 OS 的文件系统对象: `FileSystem`
      2. 通过 FileSystem 创建 `WatchService` 对象
      3. 获取需要监听的文件所在根目录 Path 路径
      4. 为根目录 Path 注册监听服务 WatchService
      5. 为了异步处理事件,将处理放在线程池中
5. 使用线程池处理文件变化
    - 这里为了异步的处理监听事件
      1. 获取 `WatchKey` 对象,并且判断 WatchKey 是否是有效的(isValidate)
      2. 如果有效的话,那么轮询所有的事件 `WatchEvent`
      3. 通过 WatchEvent 获取事件发生的目录(是一个相对路径): WatchEvent#context
      4. 通过 WatchKey 可以获取实际注册监听服务的哪个目录: WatchKey#watchable
      5. 最后就得到了实际发生变化的文件的绝对路径
6. 替换 Properties 存储的数据
    - 由于使用了线程池,需要注意线程安全,所以使用了 `synchronized`

```java
/**
 * 动态更新资源{@link MessageSource} 的实现
 * 实现步骤
 *  1. 定位资源位置(使用 Properties 文件)
 *  2. 初始化 Properties 对象,这里使用 ResourceLoader 加载资源
 *  3. 实现 DynamicResourceMessageResource#resolveCode 方法
 *  4. 监听资源文件(NIO 2 watchService)
 *  5. 使用线程池处理文件变化
 *  6. 替换 Properties 存储的数据
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class DynamicResourceMessageResource  extends AbstractMessageSource implements ResourceLoaderAware {
    // 1. 定位资源位置(使用 Properties 文件)
    private final String RESOURCE_PATH = "/META-INF/msgs.properties";
    private final String ENCODE = "UTF-8";
    // 定义 Properties 资源对应的 Resource
    private final Resource messagResource;
    // 使用 Properties 存储
    private final Properties messageProperties;

    // 注入 ResourceLoader
    private ResourceLoader resourceLoader;

    // 线程池
    private final ExecutorService executorService;

    public DynamicResourceMessageResource() throws IOException {
        this.messagResource = getResource();
        // 2. 初始化 Properties 对象,这里使用 ResourceLoader 加载资源
        this.messageProperties = loadProperties();
        this.executorService = Executors.newSingleThreadExecutor();
        // 4. 监听资源文件(NIO 2 watchService)
        onMessagePropertiesChange();
    }

    private void onMessagePropertiesChange() {
        // 如果资源是文件的话
        if (this.messagResource.isFile()) {
            try {
                // 获取资源对应的文件
                File messagePropertiesFile = this.messagResource.getFile();
                // 获取资源文件所在的路径
                Path messagePropertiesFilePath = messagePropertiesFile.toPath();
                // 获取获取资源文件的目录
                Path parentDir = messagePropertiesFilePath.getParent();
                // 获取当前操作系统的 文件系统
                FileSystem fs = FileSystems.getDefault();
                // 获取 WatchService
                WatchService watchService = fs.newWatchService();
                // 将 WatchService 注册到资源文件的目录
                parentDir.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
                //  5. 使用线程池处理文件变化
                processMessagePropertiesChange(watchService);
            }catch (IOException ex) {
                throw new RuntimeException();
            }
        }
    }

    /**
     * 异步处理资源的变化
     */
    private void processMessagePropertiesChange(WatchService watchService) {
        this.executorService.submit(() -> {
            while (true) {
                WatchKey watchKey = watchService.take();
                // 判断 watchKey 是否有效
                try {
                    if(watchKey.isValid()) {
                        // 轮询所有的修改时间
                        List<WatchEvent<?>> events = watchKey.pollEvents();
                        for (WatchEvent<?> event : events) {
                            // 获取注册的监听目录
                            Path watchDir = (Path)watchKey.watchable();
                            // 获取事件发生的路径,是相对路径
                            Path eventPath = (Path)event.context();
                            // 处理为绝对路径
                            Path filePath = watchDir.resolve(eventPath);

                            //  6. 替换 Properties 存储的数据
                            File updateFile = filePath.toFile();
                            // 多线程避免线程安全问题
                            synchronized (this.messageProperties) {
                                this.messageProperties.clear();
                                this.messageProperties.putAll(loadProperties(new FileReader(updateFile)));
                            }
                        }
                    }
                }finally {
                    // 重置监听的令牌
                    watchKey.reset();
                }
            }
        });
    }


    private Properties loadProperties() throws IOException {
        // 获取资源
        EncodedResource resource = new EncodedResource(this.messagResource, ENCODE);
        // 读取资源到 Properties
        return loadProperties(resource.getReader());
    }

    private Properties loadProperties(Reader reader) throws IOException {
        Properties properties = new Properties();
        try {
            properties.load(reader);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            if (reader != null) {
                reader.close();
            }
        }
        return properties;
    }

    private Resource getResource() {
        ResourceLoader loader = getResourceLoader();
        return loader.getResource(RESOURCE_PATH);
    }

    /**
     *  实现 DynamicResourceMessageResource#resolveCode 方法
     * Properties 以 k-v 形式存储, code 就是 key
     */
    @Override
    protected MessageFormat resolveCode(String code, Locale locale) {
        String msgPattern = this.messageProperties.getProperty(code);
        if (StringUtils.hasText(msgPattern)) {
            return new MessageFormat(msgPattern, locale);
        }
        return null;
    }

    @Override
    public void setResourceLoader(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }

    private ResourceLoader getResourceLoader() {
        return this.resourceLoader == null ? new DefaultResourceLoader() : this.resourceLoader;
    }

    public static void main(String[] args) throws InterruptedException, IOException {
        DynamicResourceMessageResource dynamicResourceMessageResource = new DynamicResourceMessageResource();
        for (int i = 0; i < 10000; i++) {
            String name = dynamicResourceMessageResource.getMessage("name", new Object[]{}, Locale.getDefault() );
            System.out.println(name);
            Thread.sleep(1000);
        }

    }
}
```
