---
id: 依赖注入
title: 依赖注入
---

## 依赖注入的模式与类型

**依赖注入的模式**

1. 手动模式(配置或者编程的方式,提前安排注入规则)
    - XML资源配置元信息
    - java注解配置元信息
    - api配置元信息(手动定义 BeanDefinition,Spring 最底层的实现)
2. 自动模式(实现方提供依赖自动关联的方式,按照内建的方式注入规则)
    - Autowiring (自动绑定)

**`依赖注入的类型`**

| 依赖注入的类型    | 配置元数据举例    |
| -------------- | ----------------------------------------------- |
| `Setter方法`    | <property name="user" ref="userBean" / >        |
| `构造器`        | <constructor-arg name="user" ref="userBean" / > |
| `字段`          | @Autowired User user;                         |
| `方法`          | @Autowired public void user(User user){…}     |
| `接口回调`       | Class MyBean implements BeanFactoryAware{…}   |

## 自动绑定/注入（Autowiring）

**这里的 Autowiring 并不等价于 @Autowire 注解**,这里的 Autowiring 指的是AbstractBeanDefinition 的 autowireMode 不同属性值可能产生的问题。

对于自动绑定而言, 如果 autowireMode 的值等于 `byName/byType`,那么即使不使用@Autwired 注解,也会将依赖注入进来,这就是所谓的 **"自动绑定"**。

但是如果 autowireMode 使用默认的 `no`,那么就意味着需要手动的绑定依赖,比如说@Inject、@Resource、@Autowired。所以说 **@Autowired 还是属于手动注入**

### 自动绑定/注入的使用场景

| 模式          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| `no`          | 默认值,没有激活自动装配,需要手动指定依赖注入的对象,比如 @Autwired、@Resource、手动设置值...         |
| `byName`      | 根据被注入属性的**名称**作为Bean名称进行依赖查找,并将查找到的对象设置到该属性 |
| `byType`      | 根据被注入属性的**类型**作为依赖类型进行依赖查找,并将查找到的对象设置到该属性 |
| `constructor` | 特殊的 **byType**类型,用于构造器参数 |

参考的枚举 : `org.springframework.beans.factory.annotation.Autowire`

### 自动绑定/注入的不足之处

1. `property`、`constructor-arg` 的配置信息会覆盖掉自动绑定,并且无法对`primitives`(基本类型)、String、Classes 进行自动绑定
2. 自动绑定并不精准,需要自己把控对依赖的定义
    - 比如 IOC 中有一个 name=user 的 Bean,且是 User 类型,如果有一个 Man 类型的,属性名也为 user 的 Bean,在设置 `autowire(no | byType | byName)` 的时候选择byName 的话,就会出错

### 自动绑定与@Autowired 区别

:::danger 区分自动绑定与 @Autowired

- 自动绑定是这个Bean的AbstractBeanDefinition#autowireMode 设置为 byName/byType,然后Spring会自动将容器中满足条件的Bean注入到属性中(**不用@Autowired 注解也会注入到容器中)**
- **@Autowired 则是手动从容器中查找指定的Bean进行注入**
  - 默认是以byType的方式进行查找
  - 如果有多个类型匹配的Bean,就会通过属性名+byName的方式进行依赖查找

:::

## Setter方法注入

**实现方法**

- 手动模式
  - XML资源配置信息
  - java注解配置元信息
  - api配置元信息
- ~~自动模式~~
  - byType
  - byName

### 基于XML资源的 Setter 方法依赖注入

**①、XML资源配置**

```xml
<!--基于 XML 资源的依赖 Setter 方法注入-->
<bean id="xml-dependency-injection"
      class="ioc.overview.Domain.User">
    <property name="id" value="22"/>
    <property name="name" value="xml-dependency-injection"/>
</bean>
```

**②、将Bean注入容器并且进行依赖查找**

```java
/**
 * <b>基于 XML 资源的依赖 Setter 方法注入示例</b>
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class XmlDependencyInjectionDemo {
  public static void main(String[] args) {
    // 创建一个 BeanFactory
    DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();

    // 创建 XmlBeanDefinitionReader,并且读取 XML 资源文件
    XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
    xmlBeanDefinitionReader.loadBeanDefinitions("META-INF/XmlDependencyInjection.xml");

    User bean = beanFactory.getBean("xml-dependency-injection", User.class);
    // out: User{id=22, name='xml-dependency-injection'}
    System.out.println(bean);
  }
}

```

### 基于java注解的依赖注入

```java
/**
 * <b>基于 Java注解</b>
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class AnnotationDependencyInjectionDemo {
  public static void main(String[] args) {
    // 创建注解的 Spring 应用上下文对象
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    // 注册配置类
    ctx.register(UserConfig.class);
    // 刷新应用上下文
    ctx.refresh();

    // 获取 Bean 对象
    User user = ctx.getBean("user", User.class);
    // out: User{id=33, name='annotation-dependency-injection'}
    System.out.println(user);
  }
}

/**
 * 配置类
 */
class UserConfig {
  @Bean
  public User user() {
    User user = new User();
    user.setId(33L);
    user.setName("annotation-dependency-injection");
    return user;
  }
}
```

### 基于api配置元信息

```java
public static void main(String[] args) {
  DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();

  // 创建一个 User 的 BeanDefinition
  RootBeanDefinition userBean = new RootBeanDefinition();
  userBean.setBeanClass(User.class);

  MutablePropertyValues values = new MutablePropertyValues();
  values.add("age",22);
  values.add("name","yoey");
  userBean.setPropertyValues(values);
  // 注册 User 的 BeanDefinition
  beanFactory.registerBeanDefinition("user",userBean);
  System.err.println("注入一个BeanDefinition...");
  // 没有初始化的Bean,在调用getBean方法时会进行初始化
  System.err.println(beanFactory.getBean("user"));
}

/*
  注入一个BeanDefinition...
  User 无参构造器调用...
  初始化 User name 属性...
  User{age=22, name='yoey'}
*/
```

### 自动模式

> 自动模式就是设置 Bean 的 autowire (默认是 no),byName/byType

- 创建一个 XML 的配置文件,在 Bean 的定义信息中设置了 autowire 模式诶 byType

  ```xml
  <!--
      导入 Spring 的配置文件(基于 XML 的 Setter 依赖注入)
      会注入 User 类型的 Bean 组件
  -->
  <import resource="XmlDependencyInjection.xml"/>

  <!--基于 XML 资源的依赖 Setter 方法注入-->
  <bean id="autowiring-dependency-injection"
        class="domain.UserHolder"
        autowire="byType">
  </bean>
  ```

- 测试代码

  ```java
  /**
  * <b>自动注入</b>
  *
  * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
  */
  public class AutoWiringInjectionDemo {
    public static void main(String[] args) {
      // 创建一个 BeanFactory
      DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
  
      // 创建 XmlBeanDefinitionReader,并且读取 XML 资源文件
      XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
      xmlBeanDefinitionReader.loadBeanDefinitions("META-INF/AutowiringDependencyInjection.xml");
  
      UserHolder userHolder = beanFactory.getBean("autowiring-dependency-injection", UserHolder.class);
      // out: UserHolder{user=User{id=22, name='xml-dependency-injection'}}
      System.out.println(userHolder);
    }
  }
  ```

## 构造器注入

**实现方法**

- 手动模式
  - XML资源配置信息
  - java注解配置元信息
  - api配置元信息
- ~~自动模式~~
  - constructor (autowire 模式设置为 constructor)

:::tip 说明

1. **Setter 注入的顺序是不确定的**,因为 java 反射 API 返回的 public 方法顺序并非定义顺序,所以无法控制 Setter 注入的先后顺序
2. 由于 Setter 注入的顺序的不确定性,所以如果字段之间存在依赖关系的话,容易出现问题
3. **构造器注入的顺序是确定的**

:::

### 基于Xml

```xml
<!--  constructor注入  -->
<bean id="constructor-dependency-injection"
      class="ioc.overview.Domain.User">
    <constructor-arg index="0" value="33"/>
    <constructor-arg index="1" value="constructor-dependency-injection"/>
</bean>
```

然后通过 BeanFactory 进行测试:

```java
/**
 * <b>基于 XML 的构造器的依赖注入</b>
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class ConstructorDependencyInjectionDemo {
  static final String CONFIG_PATH = "META-INF/ConstructorDependencyInjection.xml";
  public static void main(String[] args) {
    // 创建一个 BeanFactory
    DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
    // 创建一个 BeanDefinitionReader 读取 BeanDefinition
    XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
    xmlBeanDefinitionReader.loadBeanDefinitions(CONFIG_PATH);

    User user = beanFactory.getBean("constructor-dependency-injection", User.class);
    // out: User{id=33, name='constructor-dependency-injection'}
    System.out.println(user);
  }
}

```

### 基于java注解

下面示例的配置类中, **UserHolder userHolder (User user),容器会自动注入一个 User 类型的Bean组件**

```java
/**
 * 创建一个 User 的 Holder 类
 */
public class UserHolder {
    private User user;
    public UserHolder() {
    }
    public UserHolder(User user) {
        this.user = user;
    }
    // getter、setter、toString...
}

/**
 * <b>基于 Java 注解的构造器注入</b>
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class AnnotationDependencyInjectionDemo {
    static final String CONFIG_PATH = "META-INF/ConstructorDependencyInjection.xml";
    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(UserConfig.class);

        // 通过 XMLBeanDefinitionReader 加载 XML 配置的 User Bean组检
        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(ctx);
        reader.loadBeanDefinitions(CONFIG_PATH);
        // 刷新应用上下文
        ctx.refresh();

        UserHolder userHolder = ctx.getBean("userHolder", UserHolder.class);
        // out: UserHolder{user=User{id=33, name='constructor-dependency-injection'}}
        System.out.println(userHolder);
    }
}

/**
 * 创建一个配置类
 */

class UserConfig {
    @Bean
    public UserHolder userHolder (User user) {
        return new UserHolder(user);
    }
}

```

### 基于api的方式

> 值得注意的是,  beanFactory#getBean 时,如果这个 Bean 没有被初始化,会对这个 Bean 进行初始化

```java
public static void main(String[] args) {
  DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
  // 创建一个 User 的 BeanDefinition
  RootBeanDefinition userBean = new RootBeanDefinition();
  userBean.setBeanClass(User.class);

  ConstructorArgumentValues values = new ConstructorArgumentValues();
  values.addIndexedArgumentValue(0,22);
  values.addIndexedArgumentValue(1,"yoey2");
  userBean.setConstructorArgumentValues(values);
  beanFactory.registerBeanDefinition("user",userBean);
  System.err.println("注入一个BeanDefinition...");
  // 没有初始化化的Bean,在调用getBean方法时会进行初始化
  System.err.println(beanFactory.getBean("user"));
}

/*
  注入一个BeanDefinition...
  User 有参构造器调用...name:yoey2
  User{age=22, name='yoey2'}
*/
```

## 字段注入-> 实例字段/对象字段

**实现方式**

- 手动方式
  - Java 注解配置元信息
    - `@AutoWired`: **@Autowired 会忽略掉静态的字段**
    - `@Resource`
    - `@Inject`【可选,需要jsr330的依赖】

### @Autowired示例

- @Autowired 在非静态的字段上

  ```java
  /**
  * <b>字段注入(@Autowired 在非静态的字段上)</b>
  *
  * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
  */
  public class FieldInjectionDemo {
      @Autowired
      private User user;

      public static void main(String[] args) {
          AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
          // 注册配置类
          ctx.register(FieldInjectionDemo.class);
          ctx.refresh();

          // 注册的配置类也是一个 Bean 组件
          FieldInjectionDemo fieldInjectionDemo = ctx.getBean(FieldInjectionDemo.class);
          // out: User{id=22, name='constructor-annotation-injection'}
          System.out.println(fieldInjectionDemo.user);
      }

      @Bean
      public User user(){
          return new User(22L, "constructor-annotation-injection");
      }
  }
  ```

- @Autowired 在静态的字段上(忽略掉静态的字段)

  ```java
  /**
  * <b>字段注入(@Autowired 在静态的字段上)</b>
  *
  * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
  */
  public class FieldInjectionInStaticDemo {
      @Autowired
      private static User user;
  
      public static void main(String[] args) {
          AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
          // 注册配置类
          ctx.register(FieldInjectionInStaticDemo.class);
          ctx.refresh();
  
          // 注册的配置类也是一个 Bean 组件
          FieldInjectionInStaticDemo fieldInjectionDemo = ctx.getBean(FieldInjectionInStaticDemo.class);
          // out: null
          System.out.println(fieldInjectionDemo.user);
      }
  
      @Bean
      public User user(){
          return new User(22L, "constructor-annotation-injection");
      }
  }
  ```

## 方法注入

方法注入并不是@Autowired 的"专利",实际上有下面的实现方式(手动模式-java 注解):

1. `@Autowired`
2. `@Resource`
3. `@Bean`
4. `@Inject` [可选,需要jsr330的依赖]

:::tip 说明

1. **方法注入时,先把形参名作为 bean 的名称进行查找注入,如果查不到再通过 bean 的类型进行查找注入**

2. @Bean 注解本质上不是一个方法注入的注解手段,而是注册 BeanDefinition 的注解手段

:::

### @Bean的方式

> 在上面的[构造器 java 注解注的示例中有提到](依赖注入#基于java注解)

**①、xml中配置一个Bean**

注入两个User类型的Bean以及一个Address类型的Bean

```xml
<bean id="user"  class="com.geekbang.dependencyInjectionDemo.pojo.User">
  <property name="age" value="22"/>
  <property name="name" value="yoey"/>
</bean>

<bean id="user2"  class="com.geekbang.dependencyInjectionDemo.pojo.User">
  <property name="age" value="22"/>
  <property name="name" value="yoey2"/>
</bean>

<bean id="address" class="com.geekbang.MyDemo1.Pojo.Address">
  <property name="name" value="changzhou"/>
</bean>
```

**②、测试使用 @Bean进行方法注入**

- 由于有两个类型为User 的Bean[user、user2],所以方法注入时,把形参名称作为bean的名称从容器中查找并注入
- Address类型的bean只有一个,所以是通过默认的类型查找

```java
public static void byBeanAnnotation(){
  AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
  ctx.register(MethodInjectionDemo.class);
  // 加载xml中的bean
  String xmlResource = "classpath:/application-dependency-injection.xml";
  XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(ctx);
  reader.loadBeanDefinitions(xmlResource);
  ctx.refresh();
  System.err.println("bean1---->"+ctx.getBean("bean1"));
  /*
  	输出
  	User 无参构造器调用...
    初始化 User name 属性...
    User 无参构造器调用...
    初始化 User name 属性...
    bean1---->yoey:yoey2:changzhou
  */
}

/**
* 在 Xml资源配置中包含两个User类型的Bean[user与user2]以及一个Address类型的Bean[address]
*/
@Bean
public String bean1(User user, User user2, Address address2){
  return user.getName()+":"+user2.getName()+":"+address2.getName();
}
```

### @AutoWired的方式

```java
public static void byBeanAnnotation(){
  AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
  ctx.register(MethodInjectionDemo.class);
  // 加载xml中的bean
  String xmlResource = "classpath:/application-dependency-injection.xml";
  XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(ctx);
  reader.loadBeanDefinitions(xmlResource);
  ctx.refresh();
}

/**
* 通过 {@link Autowired} 进行方法注入
*/
private User user1;
private User user2;
private Address address;

@Autowired
public void byAutowired(User user2, User user, Address address2){
  this.user1 = user;
  this.user2 = user2;
  this.address = address2;
  System.out.println( "byAutowired->"+user1.getName()+":"+user2.getName()+":"+address.getName());
}

/*
	输出:
	User 无参构造器调用...
  初始化 User name 属性...
  User 无参构造器调用...
  初始化 User name 属性...
  byAutowired->yoey:yoey2:changzhou
*/
```

## Aware系列接口回调注入

**可以用于注入一些Spring内建的组件**

**自动模式**

| 内建接口                          | 作用说明                                    |
| ------------------------------- | ------------------------------------------ |
| `BeanFactoryAware`              | 获取IOC容器-BeanFactory                             |
| `ApplicationContextAware`       | 获取Spring应用上下文- ApplicationContext            |
| `EnvironmentAware`              | 获取Environment对象                                 |
| `ResourceLoaderAware`           | 获取资源加载器对象-ResourceLoader                   |
| `BeanClassLoaderAware`          | 获取加载当前Bean Class 的ClassLoader                |
| `BeanNameAware`                 | 获取当前Bean的名称                                  |
| `MessageSourceAware`            | 获取MessageSource对象,用于Spring的国际化           |
| `ApplicationEventPublisherAware`| 获取ApplicationEventPublisher对象,处理Spring的事件 |
| `EmbeddedValueResolverAware`    | 获取StringValueResolver对象,用于占位符处理         |

### 代码示例

```java
public class AwareInterfaceInjectionDemo implements BeanFactoryAware, ApplicationContextAware {
  private static BeanFactory beanFactory;
  private static ApplicationContext applicationContext;

  public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.register(AwareInterfaceInjectionDemo.class);
    ctx.refresh();
    System.err.println("通过ApplicationContextAware 注入的Spring应用上下文ApplicationContext 是否与当前的上下文对象相等:"+(ctx == applicationContext));
    System.err.println("通过BeanFactoryAware 注入的IOC容器 BeanFactory 是否与当前的IOC容器相等:"+(beanFactory == ctx.getBeanFactory()));
    ctx.close();
  }
  @Override
  public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
    AwareInterfaceInjectionDemo.beanFactory = beanFactory;
  }

  @Override
  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
    AwareInterfaceInjectionDemo.applicationContext = applicationContext;
  }
}

/*
	通过ApplicationContextAware 注入的Spring应用上下文ApplicationContext 是否与当前的上下文对象相等:true
	通过BeanFactoryAware 注入的IOC容器 beanFactory 是否与当前的IOC容器相等:true
*/

```

## 依赖注入类型的选择

- **注入选型**
  - 低依赖: 构造器注入
  - 多依赖: Setter注入
  - 便利性: 字段注入
  - 声明类: 方法注入

## 其他类型的注入

:::caution 注意
Spring进行依赖注入的时候,不仅仅可以是常见的对象,还可以有更加复杂的类型注入
:::

### 基础类型的注入

基础类型

1. 原生类型(Primitive): boolean、byte、char、short、int、float、double、long
2. 标量类型(Scalar): Number、Character、Boolean、Enum、Locale、Charset、Currency、Properties、UUID
3. 常规类型(General): Object、String、TimeZone、Calendar、Optional等
4. Spring类型: Resource、InputSource、Formatter等

#### 代码示例

**①、 定义JavaBean对象**

```java
public class Person {
    /**
     * 包含 原生类型:int /标量类型:Enum / 常规类型:String / Spring对象: Resource
     */
    private int age;
    private String name;
    private City city;
    private Resource configPath;
    // getter、setter、toString 方法
}
```

**②、 Xml资源配置**

在进行setter注入时,可以注入上述的类型 -> int、String、Enum、Resoure等等

```xml
<bean id = "basicInjectionBean" class="com.geekbang.dependencyInjectionDemo.pojo.Person">
  <property name="age" value="22"/>
  <property name="name" value="yoey"/>
  <property name="city" value="NanJing"/>
  <property name="configPath" value="classpath:/userConfig.properties"/>
</bean>
```

**③、容器加载XML配置信息并进行依赖查找**

```java
public class BasicInjectionDemo {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext();
        ctx.setConfigLocation("classpath:/application-dependency-injection.xml");
        ctx.refresh();
        Person person = ctx.getBean("basicInjectionBean", Person.class);
        System.err.println(person); 
        ctx.close();
    }
}
/*
  Person{age=22, name='yoey', city=NanJing, configPath=class path resource [userConfig.properties]}
*/
```

## 集合类型注入

- 集合类型
  - 数组类型(Array): 原生类型、标量类型、常规类型、Spring类型
  - 集合类型(Collection)
    - Collection: List、Set
    - Map: Properties

## 限定注入(@Qualifier)

- 使用注解 @Qualifier 限定
  - **通过Bean的名称 / ID 限定**
  - **通过分组限定**
- 基于注解 @Qualifier 拓展限定
  - 自定义 @Qualifier 注解的拓展(比如SpringCloud的 `@LoadBalanced`)

:::danger 注意

1. **默认情况下,一个Bean限定名就是Bean的名称,在进行依赖注入的时候可以通过@Qualifier注解指定注入哪个限定名的Bean【过滤】**
2. **可以手动的通过 @Qualifier 注解指定一个Bean的限定名,并且多个Bean的限定名可以相同**

:::

### Bean 名称限定

- 容器中包含两个User类型的Bean[user1、user2],通过@Qualifier注解,可以指定查找 bean 名称是user1的的Bean

- **操作步骤**
  - 在手动注入Bean的时候,加上 `@Qualifier` 注解,并且设置该注解的value属性为Bean的名称

```java
/**
 * <b>使用 Qualifier 注解来限定 Bean 的名称</b>
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class QualifierAnnotationInjectionDemo {
    @Autowired
    @Qualifier("user1")  // 指定 Bean 的名称或者 ID
    public User user;
    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(QualifierAnnotationInjectionDemo.class);
        ctx.refresh();
        QualifierAnnotationInjectionDemo ctxBean = ctx.getBean(QualifierAnnotationInjectionDemo.class);
        // out: Qualifier限定Bean的名称查找:User{id=22, name='constructor-injection-user'}
        System.err.println("Qualifier限定Bean的名称查找:"+ctxBean.user);
        ctx.close();
    }

    @Bean
    public User user1(){
        return new User(22L,"constructor-injection-user");
    }

    @Bean
    public User user2() {
        User user = new User();
        user.setId(33L);
        user.setName("setter-injection-user");
        return user;
    }
}
```

### Qualifier 分组限定

> 分组限定就是将多个 Bean 组件划分到相同的一个逻辑分组里面

- 操作步骤
  1. 对多个Bean设置相同的限定名称(将 Bean 进行逻辑分组)
  2. 依赖注入的时候,通过 @Qualifier 注解,将符合限定名的一组 Bean 注入进来

**代码示例**

- 注入四个User类型的Bean,其中限定组名为"write"的有[userWriteable1、userWriteable2], [userNormal]的Bean也加上了@Qualifier注解,**没有指定限定名,默认是空**
- 在 @AutoWired 注解手动注入Bean的时候,通过指定 @Qualifier("write") 将限定名为"write"的Bean注入到 writeAbleUsers 集合中

```java
/**
 * <b>使用 @Qualifier 注解进行分组限定</b>
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class QualifierGroupInjectionDemo {

    @Autowired
    public List<User> allUsers;

    @Autowired
    @Qualifier
    public List<User> unGroupedUsers;

    @Autowired
    @Qualifier("write")
    public List<User> writeAbleUsers;

    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(QualifierGroupInjectionDemo.class);
        ctx.refresh();
        QualifierGroupInjectionDemo ctxBean = ctx.getBean(QualifierGroupInjectionDemo.class);
        // out: Qualifier 所有的 User Bean :[
        //      User{id=11, name='userWriteable1'}, 
        //      User{id=22, name='userWriteable2'}, 
        //      User{id=44, name='userNormal'}, 
        //      User{id=44, name='user'}
        //   ]
        System.err.println("Qualifier 所有的 User Bean :"+ctxBean.allUsers);

        // out: Qualifier 分组限定[未分组的]查找:[User{id=44, name='userNormal'}]
        System.err.println("Qualifier 分组限定[未分组的]查找:"+ctxBean.unGroupedUsers);

        // out:Qualifier 分组限定[分组为write]查找:[
        //    User{id=11,name='userWriteable1'}, 
        //    User{id=22, name='userWriteable2'}
        //  ]
        System.err.println("Qualifier 分组限定[分组为write]查找:"+ctxBean.writeAbleUsers);
        ctx.close();
    }

    @Bean
    @Qualifier("write")
    public User userWriteable1() {
        return new User(11L, "userWriteable1");
    }
    @Bean
    @Qualifier("write")
    public User userWriteable2() {
        return new User(22L, "userWriteable2");
    }
    @Bean
    @Qualifier
    public User userNormal() {
        return new User(44L, "userNormal");
    }

    @Bean
    public User user() {
        return new User(55L, "user");
    }
}
```

### Qualifier 拓展

看下 @Qualifier 注解的信息:

```java
@Target({ ElementType.FIELD, 
          ElementType.METHOD,
          ElementType.PARAMETER,
          ElementType.TYPE,
          ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Qualifier {
  String value() default "";
}
```

- 可以看到, @Qualifier 注解可以标记在 *字段、方法、参数、类、注解*上。由于可以标记在注解上,所以我们可以**对 @Qualifier 注解进行拓展**

- 只需要定义一个注解,用 @Qualifier 注解标记即可

```java
/**
 * <b>基于 @Qualifier 注解进行拓展</b>
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
@Target({ElementType.FIELD, ElementType.METHOD,
        ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
@Qualifier
public @interface Write {
  String value() default "";
}

// 测试
/**
 * <b>使用 @Qualifier 拓展注解 @Write 进行分组限定</b>
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class QualifierGroupInjectionDemo2 {

    @Autowired
    @Qualifier
    public List<User> allUsers;

    @Autowired
    @Write
    public List<User> writeAbleUsers;

    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(QualifierGroupInjectionDemo2.class);
        ctx.refresh();
        QualifierGroupInjectionDemo2 ctxBean = ctx.getBean(QualifierGroupInjectionDemo2.class);
        // out: Qualifier 注解限定分组的Bean  :[
        //  User{id=11, name='userWriteable1'},
        //  User{id=22, name='userWriteable2'},
        //  User{id=55, name='user'}]
        System.err.println("Qualifier 注解限定分组的Bean :"+ctxBean.allUsers);

        // out: Qualifier 拓展注解 @Write 的分组限定查找:[User{id=11, name='userWriteable1'}, User{id=22, name='userWriteable2'}]
        System.err.println("Qualifier 拓展注解 @Write 的分组限定查找:"+ctxBean.writeAbleUsers);
        ctx.close();
    }

    @Bean
    @Write
    public User userWriteable1() {
        return new User(11L, "userWriteable1");
    }
    @Bean
    @Write
    public User userWriteable2() {
        return new User(22L, "userWriteable2");
    }

    @Bean
    @Qualifier
    public User user() {
        return new User(55L, "user");
    }
}
```

## 延迟依赖注入

我们知道可以通过 ObjectFactory/ObjectProvider 实现 Bean 的[延迟查找](依赖查找#bean-的延迟查找), 同样的还通过 ObjectFactory/ObjectProvider 的方式,**将容器中的依赖延迟注入进来,在要使用的时候,通过getXXX方法获取即可**

- 使用 api ObjectFactory 延迟注入
  - 单一类型
  - 集合类型
- 使用 api ObjectProvider 延迟注入 ✅
  - 单一类型
  - 集合类型

:::caution 注意
Bean 的延迟注入不等于延迟加载
:::

下面是利用 ObjectProvider 实现 Bean 的延迟注入:

```java
/**
 * <b>使用 ObjectProvider 实现依赖的延迟注入</b>
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class LazyInjectionDemo {

    @Resource
    public Person defaultPerson;

    @Resource
    public ObjectProvider<Person> allPerson;

    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(LazyInjectionDemo.class);
        ctx.refresh();
        LazyInjectionDemo injectionDemo = ctx.getBean(LazyInjectionDemo.class);
        // 获取实时 Bean
        System.out.println("实时注入的 Bean: "+injectionDemo.defaultPerson);

        // 获取延迟注入的 Bean
        injectionDemo.allPerson.stream().forEach((bean) -> {
            System.out.println("延迟注入的 Bean:"+bean);
        });
        ctx.close();
        /*
          out:
          bean被初始化了
          实时注入的 Bean: Person{name='person2'}
          bean被初始化了
          延迟注入的 Bean:Person{name='person1'}
          延迟注入的 Bean:Person{name='person2'}
        */
    }

    @Bean
    @Lazy   // 延迟加载 不等于 延迟注入/延迟查找
    public Person person1() {
        return new Person("person1");
    }

    @Bean
    @Primary // 设置为默认 Bean
    public Person person2() {
        return new Person("person2");
    }
}

class Person implements InitializingBean {
    private String name;

    public Person() {
    }

    public Person(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                '}';
    }

    // 定义 Bean 的初始化方法
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("bean被初始化了");
    }
}
```

---

## 依赖处理过程

1. **入口**:  `DefaultListableBeanFactory#resolveDependency`
2. **依赖描述符**:  `DependencyDescriptor`
3. **自动绑定候选对象处理器**:  `AutowireCandidateResolver`

### resolveDependency

```java title="DefaultListableBeanFactory#resolveDependency"
// DependencyDescriptor : 依赖描述符
// requestingBeanName: 请求的 Bean 名称
public Object resolveDependency(DependencyDescriptor descriptor, 
                                @Nullable String requestingBeanName,
                                @Nullable Set<String> autowiredBeanNames,
                                @Nullable TypeConverter typeConverter){
  descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
  // descriptor.getDependencyType => descriptor.field.getType()
  // 如果处理的依赖是 Option 类型
  if (Optional.class == descriptor.getDependencyType()) {
    return createOptionalDependency(descriptor, requestingBeanName);
  }
    // 如果处理的依赖是 ObjectFactory、ObjectProvider 类型
  else if (ObjectFactory.class == descriptor.getDependencyType() ||
      ObjectProvider.class == descriptor.getDependencyType()) {
    return new DependencyObjectProvider(descriptor, requestingBeanName);
  }
  // ..
  else {
    Object result = getAutowireCandidateResolver()
                    .getLazyResolutionProxyIfNecessary(descriptor,requestingBeanName);
    if (result == null) {
      // 进行依赖处理
      result = doResolveDependency(descriptor, 
                                    requestingBeanName, 
                                    autowiredBeanNames,
                                    typeConverter);
    }
    return result;
  }
}
```

在下面真正处理依赖的时候,会对多个依赖和单个依赖进行处理:

1. resolveMultipleBeans
2. findAutowireCandidates

```java title="DefaultListableBeanFactory#doResolveDependency"
@Nullable
public Object doResolveDependency(DependencyDescriptor descriptor, 
          @Nullable String beanName,
          @Nullable Set<String> autowiredBeanNames,
          @Nullable TypeConverter typeConverter) throws BeansException {

  try {
    // 获取依赖的类型
    Class<?> type = descriptor.getDependencyType();

    // 处理多个依赖的情况,比如上面的 type 是集合类型
    Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
    if (multipleBeans != null) {
      return multipleBeans;
    }

    // 获取自动装配的依赖候选项
    Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);

    // 如果没有,抛出 NoSuchBeanDefinitionException
    if (matchingBeans.isEmpty()) {
      if (isRequired(descriptor)) {
        raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
      }
      return null;
    }

    String autowiredBeanName;
    Object instanceCandidate;
    // 如果有多个依赖候选项 
    if (matchingBeans.size() > 1) {
      // 选择唯一的依赖候选项 通过primary、Order...
      autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
      if (autowiredBeanName == null) {
        // 如果没有唯一的依赖,那么就抛出 NoUniqueBeanDefinitionException
        if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {
          return descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);
        }
        else {
          return null;
        }
      }
      // 通过依赖候选项的名称获取对应的示例对象
      instanceCandidate = matchingBeans.get(autowiredBeanName);
    }
    else {
      Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();
      autowiredBeanName = entry.getKey();
      instanceCandidate = entry.getValue();
    }

    if (autowiredBeanNames != null) {
      autowiredBeanNames.add(autowiredBeanName);
    }
    if (instanceCandidate instanceof Class) {
      // resolveCandidate方法实际是进行依赖查找: beanFactory.getBean
      instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);
    }
    Object result = instanceCandidate;
    if (!ClassUtils.isAssignableValue(type, result)) {
      throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());
    }
    // 返回 bean 对象
    return result;
  }
  finally {
    ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
  }
}
```

:::tip 分析 resolveMultipleBeans

```java
private Object resolveMultipleBeans(DependencyDescriptor descriptor, 
      @Nullable String beanName,
      @Nullable Set<String> autowiredBeanNames,
      @Nullable TypeConverter typeConverter) {

  final Class<?> type = descriptor.getDependencyType();

  if (descriptor instanceof StreamDependencyDescriptor) {
   // 如果依赖类型是 Stream
  }
  else if (type.isArray()) {
    // 如果依赖类型是 Array
  }
  else if (Collection.class.isAssignableFrom(type) && type.isInterface()) {
    // 如果依赖类型是 Collection
  }
  else if (Map.class == type) {
    // 如果依赖类型是 Map
    ResolvableType mapType = descriptor.getResolvableType().asMap();
    // 获取Map key 的类型
    Class<?> keyType = mapType.resolveGeneric(0);
    if (String.class != keyType) {
      return null;
    }
    // 获取Map value 的类型
    Class<?> valueType = mapType.resolveGeneric(1);
    if (valueType == null) {
      return null;
    }
    // 根据 value 的类型获取符合条件的依赖候选项
    Map<String, Object> matchingBeans = findAutowireCandidates(beanName, valueType,
        new MultiElementDescriptor(descriptor));
    if (matchingBeans.isEmpty()) {
      return null;
    }
    if (autowiredBeanNames != null) {
      autowiredBeanNames.addAll(matchingBeans.keySet());
    }
    return matchingBeans;
  }
  else {
    return null;
  }
}
```

:::

### 依赖描述符

> Spring4.3 之后出现了: `InjectionPoint`, 用于**描述方法、构造函数参数或字段的注入点**

```java
public class DependencyDescriptor extends InjectionPoint implements Serializable {
    // 使用依赖注入的类型(不是依赖的类型)
    private final Class<?> declaringClass;
    @Nullable
    private String methodName;
    @Nullable
    private Class<?>[] parameterTypes;
    private int parameterIndex;
    @Nullable
    private String fieldName;
    private final boolean required;
    private final boolean eager;
    private int nestingLevel = 1;
    @Nullable
    private Class<?> containingClass;
    @Nullable
    private transient volatile ResolvableType resolvableType;
    @Nullable
    private transient volatile TypeDescriptor typeDescriptor;

    //...
}
// 注入点
public class InjectionPoint {

  @Nullable
  protected MethodParameter methodParameter;
  @Nullable
  protected Field field;
  @Nullable
  private volatile Annotation[] fieldAnnotations;
}

```

:::info 以下面的代码为示例debug 查看描述符信息:

```java
public class LazyInjectionResolutionDemo {

    @Resource
    public Person defaultPerson;

    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(LazyInjectionResolutionDemo.class);
        ctx.refresh();
        ctx.close();
    }

    @Bean
    @Lazy   // 延迟加载 不等于 延迟注入/延迟查找
    public Person person1() {
        return new Person("person1");
    }

    @Bean
    @Primary // 设置为默认 Bean
    public Person person2() {
        return new Person("person2");
    }
}
```

**下面是 debug 信息:**

![image-20230318154353244](./image/1.4依赖注入/image-20230318154353244.png)

:::

## @Autowired 注入基本过程

@Autowired 注入的过程主要为下面几个过程:

1. **元信息解析**
2. **依赖查找**
3. **依赖注入(字段、方法)**

## @Inject 注入原理

## 通用注解注入原理

## 自定义依赖注入注解
