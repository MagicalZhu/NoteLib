---
id: IOC容器
title: IOC容器
---
## IOC 概述

- <mark>IOC 容器的职责</mark> 

  - 依赖处理
    - 依赖查找
    - 依赖注入
  
  - 生命周期管理
    - 容器的生命周期
    - 托管的资源(JavaBeans 或者其他资源)
  
  - 配置
    - 容器的配置
    - 外部化的配置
    - 托管的资源(JavaBeans 或者其他资源)  

- <mark>主要实现</mark> 

  1. java SE
     - java Beans
     - java ServiceLoader SPI
     - JNDI (java naming and directory interface)
  2. java EE
     - EJB (Enterprise Java Beans)
     - Servlet
  3. 开源
     - Spring
     - Google Guice
     - Apache Avalon
     - PicoContainer
	


### JavaBeans 传统IOC容器

:::tip 注意
主要用于java awt图形化界面设计
:::

- <mark>JavaBean 作为 IOC 容器的特性？</mark>

  1. 依赖查找
  2. 生命周期管理
  3. 配置元信息
  4. 事件
  5. 自定义
  6. 资源管理
  7. 持久化
- <mark>常见类</mark>

  - **Introspector**:  内省, 用于操作Bean
    - `BeanInfo Introspector.getBeanInfo(Class<?> beanClass, Class<?> stopClass)`
  - **BeanInfo**: Java Beans 的API
    - `getBeanDescriptor()`
      - 获取Bean描述符: *BeanDescriptor*
    - `getEventSetDescriptors()`
      - 获取事件描述符: *EventSetDescriptor*
    - `getPropertyDescriptors()`
      - 获取属性描述符: *PropertyDescriptor*
        - 比如可写、可读方法名
      - <mark>PropertyDescriptor 允许添加属性编辑器: <strong>PropertyEditor</strong>,利用PropertyEditor 可以实现属性类型的转换 等属性的编辑操作</mark> 
    - `getMethodDescriptors()`
      - 获取方法描述符: *MethodDescriptor*

```java
// 一个简单的POJO,也叫做贫血模型(对象只有简单的get/set,没有复杂的业务操作)
public class Person {
    String name;
    Integer age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}


public class BeanInfoDemo {
    public static void main(String[] args) throws IntrospectionException {
        Person person = new Person();
        person.setAge(22);
        person.setName("atu");

        // Introspector :Bean的自省
        BeanInfo info = Introspector.getBeanInfo(person.getClass(), Object.class);

        Stream.of(info.getPropertyDescriptors())
              .forEach(propertyDescriptor -> {
                  System.out.println(propertyDescriptor);
              });

        // 利用 PropertyEditor 对属性进行编辑
        Stream.of(info.getPropertyDescriptors())
                .forEach(propertyDescriptor -> {

                    // 获取属性的类型,比如这里就是 java.lang.Integer、java.lang.String
                    Class<?> propertyType = propertyDescriptor.getPropertyType();
                    System.out.println(propertyType);

                    // 获取属性名
                    String name = propertyDescriptor.getName();
                    // 这里进行类型转换
                    if (name.equals("age")) {
                        propertyDescriptor.setPropertyEditorClass(StringToIntegerPropertyEditor.class);
                    }
                });

    }
    static class StringToIntegerPropertyEditor extends PropertyEditorSupport {
        @Override
        public void setAsText(String text) throws IllegalArgumentException {
           Integer val = Integer.valueOf(text);
           setValue(val);
        }
    }
}


/**

java.beans.PropertyDescriptor[name=age; propertyType=class java.lang.Integer; readMethod=public java.lang.Integer ioc.java.beans.Person.getAge(); writeMethod=public void ioc.java.beans.Person.setAge(java.lang.Integer)]

java.beans.PropertyDescriptor[name=name; propertyType=class java.lang.String; readMethod=public java.lang.String ioc.java.beans.Person.getName(); writeMethod=public void ioc.java.beans.Person.setName(java.lang.String)]

class java.lang.Integer
class java.lang.String
*/
```



## Spring IOC

**依赖查找与依赖注入**

| 类型     | 依赖处理 | 便利性   | 代码侵入性   | API 依赖性     | 可读性 |
| -------- | -------- | -------- | ------------ | -------------- | ------ |
| 依赖查找 | 主动获取 | 相对繁琐 | 侵入业务逻辑 | 依赖容器 API   | 良好   |
| 依赖注入 | 被动提供 | 相对便利 | 低侵入性     | 不依赖容器 API | 一般   |



### 依赖查找

> 查找Bean对象

1. 根据 Bean 名称查找
   - 实时查找
   - 延迟查找
2. 根据 Bean 类型查找
   - 单个Bean对象
   - 集合Bean对象
3. 根据 Bean 名称+类型查找
4. 根据 Java 注解查找
   - 单个Bean对象
   - 集合Bean对象

#### 实时&延迟

进行依赖查找的时候,可以选择**实时查找和延迟查找(给 Bean 包上一层)**

**1. 定义 XML**

> 这里的 **org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean** 实现了**ObjectFactory**接口
>
> ObjectFactory  定义一个工厂，该工厂在调用时可以返回 Object 实例(可能是共享的或独立的)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean class="ioc.overview.Dependency.Domain.User" id="user">
        <property name="name" value="atu"/>
        <property name="id" value="10000"/>
    </bean>

    <!--通过 ObjectFactory 实现延迟查找-->
    <bean class="org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean"
          id="objectFactory">
        <property name="targetBeanName" value="user"/>
    </bean>
</beans>
```

#### 单个&集合

```java
private static void lookUpByCollectionType(BeanFactory beanFactory) {
  if(beanFactory instanceof ListableBeanFactory) {
    ListableBeanFactory factory = (ListableBeanFactory)beanFactory;
    Map<String, User> users = factory.getBeansOfType(User.class);
    // out: 按类型实时查询集合 Bean 对象:{user=User{id=10000, name='atu'}}
    System.out.println("按类型实时查询集合 Bean 对象:"+users);
  }
}

private static void lookUpByType(BeanFactory beanFactory) {
  User user = beanFactory.getBean(User.class);
  // out: 按类型实时查询:User{id=10000, name='atu'}
  System.out.println("按类型实时查询:"+user);
}
```

#### 注解

**1. 定义一个注解**

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Super {
	// ...
}
```

**2. 新建一个 Pojo 类以便区分**

```java
@Super
public class SuperUser extends User{
    private String address;

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "SuperUser{" +
                "address='" + address + '\'' +
                "} " + super.toString();
    }
}
```

**3.在Spring 的 XML 配置文件中配置 Bean 组件**

```xml
<bean class="ioc.overview.Dependency.Domain.User"
      id="user">
  <property name="name" value="atu"/>
  <property name="id" value="10000"/>
</bean>

<!--super user,这里的 parent 属性表示该Bean继承自 user-->
<bean class="ioc.overview.Dependency.Domain.SuperUser"
      id="superUser"
      parent="user"
      primary="true">
  <property name="address" value="常州"/>
</bean>
```

**4. 测试用注解查询 Bean**

```java
private static void lookUpByAnnotationType(BeanFactory beanFactory) {
  if(beanFactory instanceof ListableBeanFactory) {
    ListableBeanFactory factory = (ListableBeanFactory)beanFactory;
    Map<String, Object> beans = factory.getBeansWithAnnotation(Super.class);
    // out: 按注解实时查询包含@Supper 注解的 Bean:{superUser=SuperUser{address='常州'} User{id=10000, name='atu'}}
    System.out.println("按注解实时查询包含@Supper 注解的 Bean:"+ beans);
  }
}
```



### 依赖注入

> 注入Bean以及非Bean对象

1. 根据Bean的名称注入
2. 根据Bean的类型注入
   - 单个Bean对象
   - 集合Bean对象
3. 注入容器内建 Bean对象
   - 比如: `environment、systemProperties、messageSource、applicationEventMulticaster...`
4. 注入内建 非Bean对象
   - 比如: `BeanFactory、ResourceLoader、ApplicationEventPublisher`
5. 注入类型
   - 实时注入
   - 延迟注入

**方式1. 手动注入**

> 这里依据 Bean 的类型进行注入,并且注入了集合对象

```xml
<!-- XML配置 1 (dependency-look-up)-->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean class="ioc.overview.Dependency.Domain.User"
          id="user">
        <property name="name" value="atu"/>
        <property name="id" value="10000"/>
    </bean>

    <!--通过 ObjectFactory 实现延迟查找-->
    <bean class="org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean"
          id="objectFactory">
        <property name="targetBeanName" value="user"/>
    </bean>

    <!--super user-->
    <bean class="ioc.overview.Dependency.Domain.SuperUser"
          id="superUser"
          parent="user"
          primary="true">
        <property name="address" value="常州"/>
    </bean>
</beans>

<!-- XML配置 2 (dependency-injection)-->
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd">

    <!--导入 dependency-look-up.xml 配置文件-->
    <import resource="dependency-look-up.xml"/>

  	 <!--手动配置-->
    <bean class="ioc.overview.Dependency.repository.UserRepository"
            id="userRepository">
        <property name="users">
            <util:list>
                <ref bean="superUser"/>
                <ref bean="user"/>
            </util:list>
        </property>
    </bean>
</beans>
```



**方式2. 自动注入 autowire**

> 依旧采用的是通过类型进行注入,但是用的是自动注入

```xml
<!-- XML配置 1 (dependency-look-up)-->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean class="ioc.overview.Dependency.Domain.User"
          id="user">
        <property name="name" value="atu"/>
        <property name="id" value="10000"/>
    </bean>

    <!--通过 ObjectFactory 实现延迟查找-->
    <bean class="org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean"
          id="objectFactory">
        <property name="targetBeanName" value="user"/>
    </bean>

    <!--super user-->
    <bean class="ioc.overview.Dependency.Domain.SuperUser"
          id="superUser"
          parent="user"
          primary="true">
        <property name="address" value="常州"/>
    </bean>
</beans>

<!-- XML配置 2 (dependency-injection)-->
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd">

    <!--导入 dependency-look-up.xml 配置文件-->
    <import resource="dependency-look-up.xml"/>

  	<!-- 自动注入（通过类型） -->
    <!--Auto-Wiring, 支持 byType 和 byName -->
    <bean id="userRepository"
          class="ioc.overview.Dependency.repository.UserRepository"
          autowire="byType">
    </bean>
</beans>
```

**方式3. 注入容器内建Bean对象与 非Bean对象**

```java
public class UserRepository {
    /**
     * 集合
     */
    private List<Person>   users;
    private String name;
    private School school;

    /**
     * 非Bean 对象 
     *  其中 ResourceLoader、ApplicationEventPublisher、ApplicationContext 都是Spring应用上下文本身
     *  beanFactory = ApplicationContext.getBeanFactory()
     */
    private BeanFactory beanFactory;
    private ResourceLoader resourceLoader; 
    private ApplicationEventPublisher applicationEventPublisher;
    private ApplicationContext applicationContext;
    private ObjectFactory<ApplicationContext> objectFactory;

    /**
     * 内建Bean
     */
    private Environment environment;

	 // getter、setter...
}
```

:::caution 依赖注入和依赖查找不一样?

**注入一个 BeanFactory 类型的 Bean**

```java
public class UserRepository {
    private Collection<User> users;

  
  	// 这里定义了 BeanFactory 类型的变量,IOC 容器会注入一个 BeanFactory类型的 Bean
    private BeanFactory beanFactory;

    public BeanFactory getBeanFactory() {
        return beanFactory;
    }

    public void setBeanFactory(BeanFactory beanFactory) {
        this.beanFactory = beanFactory;
    }

    public Collection<User> getUsers() {
        return users;
    }

    public void setUsers(Collection<User> users) {
        this.users = users;
    }
}
```

**实际测试查询**

> 我们看到依赖注入的 BeanFactory 类型的 Bean 是可以获取到的,但是依赖查询的 BeanFactory 类型的 Bean 则是抛出异常
>
> 所以可以推断出<mark>依赖查找 与 依赖注入的来源并不相同</mark> 

```java
public class DependencyInjectionDemo {
    public static void main(String[] args) {
        // 1.配置 XML 配置文件
        // 2.启动 Spring 应用上下文
        BeanFactory beanFactory = new ClassPathXmlApplicationContext("META-INF/dependency-injection.xml");

        UserRepository userRepository = beanFactory.getBean("userRepository", UserRepository.class);
        // 依赖注入的: org.springframework.beans.factory.support.DefaultListableBeanFactory@3f2a3a5
        System.out.println(userRepository.getBeanFactory());

        // 依赖查找的 : No qualifying bean of type 'org.springframework.beans.factory.BeanFactory
        System.out.println(beanFactory.getBean(BeanFactory.class));
    }
}
```

:::

### 依赖的来源

- `自定义的Bean`
- `容器内建 Bean对象`
- 比如 Environment
- `容器内建依赖(非 Bean 对象)`
- 比如 BeanFactory

### Spring IOC 配置元信息

- Bean定义信息
  - 基于XMl
  - 基于Properties 文件
  - 基于 Java注解
  - 基于 Java Api
- IOC 配置信息
  - 基于XMl
  - 基于 Java注解
  - 基于 Java Api
- 外部化配置文件
  - 基于 Java注解

### 谁是IOC容器？

- 问题: <font color='red'>BeanFactory 和 ApplicationContext 谁是IOC容器？</font> 

  1. BeanFactory 包含IOC的底层实现
  2. ApplicationContext 是 BeanFactory的一个实现 (是BeanFactory的超集，实现一些企业化功能)
     - <font color='red'>实现的方式采用了组合模式，传入一个 <code>DefaultListableBeanFactory</code>,获取容器中的对象实际通过 这个传入的对象实现的</font> 
  3. <font color='blue'>获取了ApplicationContext 后，需要通过<code>getBeanFactory()</code> 方法才能得到最底层的实现，而不是直接强转为BeanFactory</font> 

注意: <mark>BeanFactory 是底层的 IOC容器, 而 ApplicationContext也是IOC容器，并且基于BeanFactory进行了拓展</mark>

```java
public abstract class AbstractRefreshableApplicationContext extends AbstractApplicationContext {

	@Nullable
	private Boolean allowBeanDefinitionOverriding;

	@Nullable
	private Boolean allowCircularReferences;

	/** Bean factory for this context. */
	@Nullable
	private DefaultListableBeanFactory beanFactory;

	// ...
}
```



#### Spring应用上下文特性

- ApplicationContext 除了提供 IOC容器的功能，还有提供以下功能：
  1. 面向切面 -> AOP
  2. 配置元信息 -> Configuration MetaData
  3. 资源管理 -> Resource
  4. 事件 -> Events
  5. 国际化 -> i18n
  6. 注解 -> Annotations
  7. Environment 抽象 

#### IOC容器的选择

- 问题: <font color='red'>BeanFactory 和 ApplicationContext 应该选择哪一个使用？</font> 

**方式1：使用底层的IOC容器 - BeanFactory**

```java
public class IOCContainerDemo {
    public static void main(String[] args) {
        // 1. 创建BeanFactory
        DefaultListableBeanFactory listableBeanFactory = new DefaultListableBeanFactory();
        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(listableBeanFactory);

        // 2. 加载配置
        int beanDefinitions = reader.loadBeanDefinitions("classpath:/META-INF/application.xml");
        System.out.println("Bean 加载的数量"+ beanDefinitions);

        // 3.获取Bean
        UserRepository userRepository = (UserRepository) listableBeanFactory.getBean("userRepo");
        System.out.println(userRepository);
    }
}
```



**方式2：使用 ApplicationContext**

```java
public class ApplicationContextContainer {
    public static void main(String[] args) {
        // 1. 创建pring应用上下文
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();

        // 2. 将当前类作为配置类
        applicationContext.register(ApplicationContextContainer.class);

        // 3. 启动Spring应用上下文
        applicationContext.refresh();

        // 4.获取Bean
        Person person = (Person) applicationContext.getBean("person");
        System.out.println(person);
    }

    @Bean
    public Person person(){
        Person person = new Person();
        person.setName("11");
        person.setAge(22);
        return person;
    }
}
```



### Spring应用上下文容器生命周期

- 包含以下生命周期
  1. 启动 -> refresh()
  2. 运行
  3. 停止 -> close()

### BeanFactory 依赖图

![image-20210203210536682](./image/1.IOC/image-20210203210536682.png)

