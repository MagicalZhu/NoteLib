---
id: 数据绑定
title: 数据绑定
---

## 使用场景

1. BeanDefinition 到 Bean 实例创建
2. 数据绑定(DataBinder)
3. Web 参数绑定(WebDataBinder)

## DataBinder组件

### 相关组件

- 标准组件
  - `DataBinder`
- Web 组件
  - `WebDataBinder`
  - `ServletRequestDataBinder`
  - `WebRequestDataBinder`
  - `WebExchangeDataBinder` [@since 5.0]

### DataBinder

DataBinder 有下面的核心属性:

1. `target`: 关联目标 Bean
2. `objectName`: 目标 Bean 名称
3. `bindingResult`: 属性绑定结果
4. `typeConverter`: 类型转换器
5. `conversionService`: 类型转换服务
6. `messageCodeResolver` : 校验错误文案 code 处理器
7. `validators`: 关联的 Bean Validator 集合

DataBinder 绑定常见方法

1. `bind(PropertyValues)`
    - **将 PropertyValue 的 K-V 内容映射到关联的 Bean(*target*) 中的属性上**
    - 假设 PropertyValues 中包含 "name=pacos" 键值对,同时 bean 对象 User 中存在 name 属性,那么bind 方法执行时,会将 User.name 设置为 pacos
2. `BindingResult getBindingResult()`
    - 获取绑定的结果
    - 这里的 `BindingResult` 是 [**Errors 接口**](数据校验#errors-接口设计)的子接口,并且还有一个实现类 [**BeanPropertyBindingResult**](数据校验#errors-文案的来源), 用于数据校验

## DataBinder元数据(PropertyValues)

> PropertyValues 不是 Bean 的属性元信息么?

DataBinder 元数据 : `PropertyValues`

| 特征 | 说明 |
|:---:|:---:|
| 数据来源 | BeanDefinition, 主要来源于 XML 资源配置 BeanDefinition |
| 数据结构 | 由一个或多个 `PropertyValue` 组成 |
| 成员结构 | PropertyValues 包含 `属性名、属性值(包含原始值、类型转换后的值)` |
| 常见实现 | `MutablePropertyValues` |
| Web拓展实现 | `ServletConfigPropertyValues`、`ServletRequestParameterPropertyValues` |
| **相关生命周期** | `InstantiationAwareBeanPostProcessor#postProcessProperties` |

## DataBinder控制参数

### 控制相关属性

|       参数名称        | 说明                            |
| :-------------------: | ------------------------------- |
| `ignoreUnknownFields` | 是否忽略位置的字段,默认 true    |
| `ignoreInvalidFields` | 是否忽略非法的字段,默认 false   |
| `autoGrowNestedPaths` | 是否自动增加嵌套路径, 默认 true |
|    `allowedFields`    | 绑定字段白名单                  |
|  `disallowedFields`   | 绑定字段黑名单                  |
|   `requiredFields`    | 必须绑定的字段                  |

### 基础使用

下面是利用 DataBinder 和 PropertyValues 为对象属性进行赋值的:

```java
/**
 *  使用{@link DataBinder} 和 {@link PropertyValues} 为对象属性赋值
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see DataBinder
 * @see PropertyValues
 */
public class DataBinderDemo {
    @Data
    static class User {
        private int id;
        private String name;
    }

    public static void main(String[] args) {
        // 1. 创建一个空白的对象
        User user = new User();
        // 2. 创建 DataBinder 对象,并且绑定目标对象(target)
        DataBinder dataBinder = new DataBinder(user, "user");

        // 3. 创建 MutablePropertyValues
        MutablePropertyValues pvs = new MutablePropertyValues();
        pvs.add("id", 22)
           .addPropertyValue("name", "pacos");

        // 4. 通过 DataBinder 的 bind 方法进行数据绑定
        dataBinder.bind(pvs);

        // 5. 输出绑定后的对象信息
        // out: DataBinderDemo.User(id=22, name=pacos)
        System.out.println(user);
    }
}
```

### 特殊场景问题

考虑下面几个特殊场景

1. 当 PropertyValues 中包含 "x" 的 PropertyValue,目标对象 B 不存在 x 属性,当 bind 方法执行时会发生什么?
2. 当 PropertyValues 中包含 "x.y" 的PropertyValue,目标对象 B 存在 x.y 属性,当 bind 方法执行时会发生什么?
3. 当 PropertyValues 中包含 "x" 的 PropertyValue,目标对象 B 存在 x 属性,当 bind 方法执行是如何避免 B 属性 x 被绑定?

#### 问题 1

- 结论: `DataBinder 会忽略未知的属性`
- 通过设置 <mark>ignoreUnknownFields = false</mark> ,可以禁止 DataBinder 忽略位置的属性

下面是测试示例:

```java
/**
 *  使用{@link DataBinder} 和 {@link PropertyValues} 为对象属性赋值
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see DataBinder
 * @see PropertyValues
 */
public class DataBinderDemo {
    @Data
    static class User {
        private int id;
        private String name;
    }

    public static void main(String[] args) {
        // 1. 创建一个空白的对象
        User user = new User();
        // 2. 创建 DataBinder 对象,并且绑定目标对象(target)
        DataBinder dataBinder = new DataBinder(user, "user");

        // 3. 创建 MutablePropertyValues
        MutablePropertyValues pvs = new MutablePropertyValues();
        pvs.add("id", 22).add("name", "pacos")
        // highlight-start
           .add("age", 33);
        // highlight-end

        // 4. 通过 DataBinder 的 bind 方法进行数据绑定
        dataBinder.bind(pvs);

        // 5. 输出绑定后的对象信息
        // out: DataBinderDemo.User(id=22, name=pacos)
        System.out.println(user);
    }
}
```

可以看到: <mark>虽然在 PropertyValues 中定义了不存在于目标对象的属性,但是 DataBinder 在绑定的时候会忽略这个不存在的属性</mark>

#### 问题 2

- 结论: `DataBinder 支持通过嵌套路径(*prop1.prop2.xxx*) 对嵌套属性进行绑定`
- 通过设置 <mark>autoGrowNestedPaths = false 和 ignoreInvalidFields = true</mark> 来禁止支持嵌套路径

```java
/**
 *  使用{@link DataBinder} 和 {@link PropertyValues} 为对象属性赋值
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see DataBinder
 * @see PropertyValues
 */
public class DataBinderDemo {
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    static class Address {
        private String city;
    }
    @Data
    static class User {
        private int id;
        private String name;
        private Address address;
    }
    public static void main(String[] args) {
        // 1. 创建一个空白的对象
        User user = new User();
        // 2. 创建 DataBinder 对象,并且绑定目标对象(target)
        DataBinder dataBinder = new DataBinder(user, "user");

        // 3. 创建 MutablePropertyValues
        MutablePropertyValues pvs = new MutablePropertyValues();

        pvs.add("id", 22).add("name", "pacos")
           // highlight-start
           .add("address.city","常州");
          // highlight-end

        // 4. 通过 DataBinder 的 bind 方法进行数据绑定
        dataBinder.bind(pvs);

        // 5. 输出绑定后的对象信息
        // out: DataBinderDemo.User(id=22, name=pacos, address=DataBinderDemo.Address(city=常州))
        System.out.println(user);
    }
}
```

#### 问题 3

- 解决方案: `通过 disallowedFields 属性来控制哪些字段不被绑定`

```java
/**
 *  使用{@link DataBinder} 和 {@link PropertyValues} 为对象属性赋值
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see DataBinder
 * @see PropertyValues
 */
public class DataBinderDemo {
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    static class Address {
        private String city;
    }
    @Data
    static class User {
        private int id;
        private String name;
        private Address address;
    }

    public static void main(String[] args) {
        // 1. 创建一个空白的对象
        User user = new User();
        // 2. 创建 DataBinder 对象,并且绑定目标对象(target)
        DataBinder dataBinder = new DataBinder(user, "user");

        // 3. 创建 MutablePropertyValues
        MutablePropertyValues pvs = new MutablePropertyValues();
        //highlight-start
        dataBinder.setDisallowedFields("address.city", "id");
        //highlight-end
        pvs.add("id", 22).add("name", "pacos").add("address.city","常州");

        // 4. 通过 DataBinder 的 bind 方法进行数据绑定
        dataBinder.bind(pvs);

        // 5. 输出绑定后的对象信息
        // out: DataBinderDemo.User(id=0, name=pacos, address=null)
        System.out.println(user);
    }
}
```

## JavaBeans 和 BeanWrapper

1. JavaBeans 核心实现: `BeanInfo`,支持如下的操作:
    - 属性(Property)
      - java.beans.PropertyEditor
    - 方法(Method)
    - 事件(Event)
    - 表达式(Expression)
2. Spring 替代实现: `BeanWrapper`,支持如下的操作:
    - 属性(Property)
      - java.beans.PropertyEditor
    - 嵌套属性路径(nested path)

### JavaBeans 基本操作

|         API          | 说明           |
| :------------------: | -------------- |
|    `Introspector`    | JavaBeans 内省 API       |
|      `BeanInfo`      | JavaBeans 元信息 API     |
|   `BeanDescriptor`   | JavaBeans 信息描述符     |
| `PropertyDescriptor` | JavaBeans 属性描述符     |
|  `MethodDescriptor`  | JavaBeans 方法描述符     |
| `EventSetDescriptor` | JavaBeans 事件集合描述符 |

所谓的内省就是可以获取 Bean 的详细结构信息。可以通过 `BeanInfo` 获取各种 JavaBeans 描述信息,拿 PropertyDescriptor 来说,有下面几种面常见的属性:

- `name`: 属性名称
- `propertyType`: 属性类型
- `readMethod`: 可读方法,一般就是 JavaBeans 的 Getter 方法
- `writeMethod`: 可写方法,一般就是 JavaBeans 的 Setter 方法

```java
public class JavaBeansDemo {
  @Getter
  @Setter
  static class User {
    private String name;
  }
  public static void main(String[] args) throws IntrospectionException {
      BeanInfo beanInfo = Introspector.getBeanInfo(User.class);
      // 属性描述符 PropertyDescriptor
      PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();
      Stream.of(propertyDescriptors).forEach(propertyDescriptor -> {
          System.out.println(propertyDescriptor);
      });

      MethodDescriptor[] methodDescriptors = beanInfo.getMethodDescriptors();
      Stream.of(methodDescriptors).forEach(propertyDescriptor -> {
          System.out.println(propertyDescriptor);
      });
  }
}
```

### BeanWrapper

- `BeanWrapper 是基于 JavaBeans 的二次封装`,它有如下的继承关系:

  ```ini title="BeanWrapper 层次结构"
  |--PropertyAccessor
  |--PropertyEditorRegistry
  |--TypeConverter
    |--ConfigurablePropertyAccessor
      # highlight-start
      |--BeanWrapper
      # highlight-end
        |--BeanWrapperImpl
  ```

- BeanWrapper 有几个注意点:
  1. 是 Spring 底层操作 JavaBeans 的中心化接口,是一种二次封装,所以也可以称 BeanWrapper 是 JavaBeans 的 Wrapper
  2. 提供标准的 JavaBeans 分析和操作,可以单独或批量存储 Java Bean 的属性(property)
  3. 通常不会被直接使用,`间接用于 BeanFactory 和 DataBinder`
      - 通过 `getPropertyDescriptors` 获取 Java Bean 属性描述信息
      - 通过 `setPropertyValues` 批量存储 Java Bean 属性
  4. 支持嵌套属性路径(nested path)
  5. 实现类 BeanWrapperImpl 是 `TypeConverterSupport` 的子类,可以实现数据的类型转换

### DataBinder 中的数据校验

DataBinder 和 BeanWrapper 有下面的关联:

- DataBinder#bind 方法生成 BeanPropertyBindingResult
- BeanPropertyBindingResult 关联 BeanWrapper

我们观察 DataBinder#bind 方法,实际是调用 `doBind(MutablePropertyValues)` 的

```java title="DataBinder"
// DataBinder#bind
public void bind(PropertyValues pvs) {
  MutablePropertyValues mpvs = (pvs instanceof MutablePropertyValues ? (MutablePropertyValues) pvs : new MutablePropertyValues(pvs));
  doBind(mpvs);
}

// DataBinder#doBind
protected void doBind(MutablePropertyValues mpvs) {
  checkAllowedFields(mpvs);
  checkRequiredFields(mpvs);
  applyPropertyValues(mpvs);
}
```

在 doBind 方法中,实际进行属性绑定操作的是: `applyPropertyValues(MutablePropertyValues)`,有下面的注意点:

```java title="DataBinder#applyPropertyValues"
protected void applyPropertyValues(MutablePropertyValues mpvs) {
  try {
    // highlight-start
    // 进行数据绑定
    getInternalBindingResult().getPropertyAccessor();.setPropertyValues(mpvs, isIgnoreUnknownFields(), isIgnoreInvalidFields());
    // highlight-end
  }
  catch (PropertyBatchUpdateException ex) {
    for (PropertyAccessException pae : ex.getPropertyAccessExceptions()) {
      // highlight-start
      // 数据绑定发生异常
      getBindingErrorProcessor().processPropertyAccessException(pae, getInternalBindingResult());
      // highlight-end
    }
  }
}
```

对于上述的 applyPropertyValues 方法有下面的注意点:

1. 在 DataBinder 中通过 `getInternalBindingResult` 方法会返回一个 BeanPropertyBindingResult,这个说明**数据绑定和数据校验也是校验也是密不可分的**

    ```java title="DataBinder"
    // DataBinder#getInternalBindingResult
    protected AbstractPropertyBindingResult getInternalBindingResult() {
      if (this.bindingResult == null) {
        initBeanPropertyAccess();
      }
      return this.bindingResult;
    }
    public void initBeanPropertyAccess() {
      this.bindingResult = createBeanPropertyBindingResult();
    }

    // DataBinder#createBeanPropertyBindingResult
    protected AbstractPropertyBindingResult createBeanPropertyBindingResult() {
      // highlight-start
      BeanPropertyBindingResult result = new BeanPropertyBindingResult(getTarget(),
          getObjectName(), isAutoGrowNestedPaths(), getAutoGrowCollectionLimit());
      // highlight-end
      if (this.conversionService != null) {
        // 初始化 ConversionService
        result.initConversion(this.conversionService);
      }
      if (this.messageCodesResolver != null) {
        result.setMessageCodesResolver(this.messageCodesResolver);
      }
      return result;
    }
    ```


2. getPropertyAccessor() 会通过 `BeanPropertyBindingResult#getPropertyAccessor` 返回并设置 ConfigurablePropertyAccessor 相关属性(`BeanWrapper` 是其子接口)

    ```java title="BeanPropertyBindingResult#getPropertyAccessor"
    public final ConfigurablePropertyAccessor getPropertyAccessor() {
      if (this.beanWrapper == null) {
        this.beanWrapper = createBeanWrapper();
        this.beanWrapper.setExtractOldValueForEditor(true);
        this.beanWrapper.setAutoGrowNestedPaths(this.autoGrowNestedPaths);
        this.beanWrapper.setAutoGrowCollectionLimit(this.autoGrowCollectionLimit);
      }
      return this.beanWrapper;
    }
    ```


3. 数据绑定异常的时候,也会将错误信息放在 `BeanPropertyBindingResult` 中,通过 `processPropertyAccessException()` 进行操作

    ```java
    public void processPropertyAccessException(PropertyAccessException ex, BindingResult bindingResult) {
      String field = ex.getPropertyName();
      String[] codes = bindingResult.resolveMessageCodes(ex.getErrorCode(), field);
      Object[] arguments = getArgumentsForBindError(bindingResult.getObjectName(), field);
      Object rejectedValue = ex.getValue();
      if (ObjectUtils.isArray(rejectedValue)) {
        rejectedValue = StringUtils.arrayToCommaDelimitedString(ObjectUtils.toObjectArray(rejectedValue));
      }
      // highlight-start
      FieldError error = new FieldError(bindingResult.getObjectName(), field, rejectedValue, true,codes, arguments, ex.getLocalizedMessage());
      error.wrap(ex);
      // 向 BeanPropertyBindingResult 中添加Error
      bindingResult.addError(error);
      // highlight-end
    }
    ```

## 数据校验、数据绑定和类型转换

- 数据校验的 Errors 接口的常规实现类 *BeanPropertyBindingResult* 中组合了数据绑定的 BeanWrapper
- 数据绑定的 BeanWrapper 的实现类是 *BeanWrapperImpl* 是 [TypeConverterSupport](类型转换#typeconvertersupport) 的子类,并且类型转换操作依赖于 TypeConverterSupport
- 数据绑定的 DataBinder 中组合了 数据校验的 *AbstractPropertyBindingResult* 和 *Validator*,并且通过 AbstractPropertyBindingResult 获取 *BeanWrapperImpl*

在数据绑定中需要类型转换,因为数据绑定的"元数据" PropertyValues 是字符串,需要利用类型转换将其变为指定类型。同时也需要有数据校验,在绑定失败的时候进行错误的处理。 
