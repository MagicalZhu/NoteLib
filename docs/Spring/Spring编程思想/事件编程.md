---
id: 事件编程
title: 事件编程
---

## Java 事件/监听器编程模型

> java 底层并没有成型的关于事件监听的模型,只有类似的"观察者模型"。"事件监听模型"也可以认为是观察者模型的拓展

- 设计模式: **观察者模式扩展**
  - 可观察对象(事件发送者): `Observable`
  - 观察者(监听器): `Observer`

- 事件相关的标准化接口
  - 事件对象: `EventObject`
  - 事件监听器: `EventListener`

:::tip 说明

1. 一个观察者可以绑定多个事件
2. 在 java 中,一般事件都会实现 *EventObject* 接口,而监听器一般都会实现 *EventListener* 接口。Listener 内部对事件进行相应的处理
:::

### 观察者模式相关 API

1. Observable
    - `addObserver(Observer o)` : 观察者链中添加观察者
    - `deleteObserver(Observer o)` : 观察者链中删除观察者
    - `notifyObservers(Object arg)`: 发送通知事件,通知相关的观察者
    - `setChanged` : 表示有事件发生修改,建议每次发送前都执行(该方法是protected,需要再拓展类中实现)
2. Observer
    - `update(Observable obs, Object arg)`: 发布事件后,观察者会监听到,并且做出对应的处理
      - obs: 事件发布者
      - arg: 发布的数据

```java
/**
 * {@link Observer} 示例
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see Observer
 * @see Observable
 */
public class ObserverDemo {
    public static void main(String[] args) {
        EventObservable observable = new EventObservable();
        observable.addObserver(new EventObserver());
        // 设置事件源发生变更
        observable.setChange();
        // 发送事件(通知观察者进行事件处理)
        observable.notifyObservers(new EventObject("Hello,World"));
        // 重置状态
        observable.clearChange();
    }

    static class EventObservable extends Observable {
        // 因为 Observable#setChanged 方法是 protected,所以需要拓展 Observable 才可以调用
        public void setChange() {
            super.setChanged();
        }

        public void clearChange() {
            super.clearChanged();
        }
    }
    // 实现 Observer 接口
    static class EventObserver implements Observer, EventListener {

        // 当 Observable 发送事件的时候,
        @Override
        public void update(Observable observable, Object content) {
            // out: 收到事件: java.util.EventObject[source=Hello,World]
            System.out.println("收到事件: "+ content);
        }
    }
}
```

### 面向接口的事件/监听器设计模式

> 单时间监听和多事件监听如何选择?

场景举例:

|   Java 技术规范   |               事件接口                |        监听器接口        |
| :---------------: | :-----------------------------------: | :----------------------: |
|    `JavaBean`     |          PropertyChangeEvent          |  PropertyChangeListener  |
|    `Java AWT`     |          java.awt.MouseEvent          |      MouseListener       |
|   `Java Swing`    |      javax.swing.event.MenuEvent      |       MenuListener       |
| `Java Perference` | java.util.prefs.PreferenceChangeEvent | PreferenceChangeListener |

- **单事件监听**
  - 在监听器中,只能处理一个事件
  - 比如: *PropertyChangeListener、PreferenceChangeListener ...*
- **多事件监听**
  - 在监听器中,可以处理多个事件
  - 比如: *MouseListener、MenuListener ...*

### 面向注解的事件/监听器设计模式

场景举例:

|  Java 技术规范  |               事件注解               |                 监听器注解                  |
| :-------------: | :----------------------------------: | :-----------------------------------------: |
| **Servlet3.0+** |                                      | `@javax.servlet.annotation.WebListener ...` |
|   **JPA1.0+**   | `@javax.persistence.PostPersist ...` |                                             |
| **Java Common** |  `@PostConstruct、@PreDestroy ...`   |                                             |
|  **EJB  3.0+**  |    `@javax.ejb.PrePassivate ...`     |                                             |
|  **JSF 2.0+**   | `@javax.faces.event.ListenerFor ...` |                                             |

## Spring 标准事件(ApplicationEvent)

> 为什么不用 EventObject?

- `ApplicationEvent` 是 Java 标准事件对象(*EventObject*) 的抽象实现类,增加了 `事件发生时间戳` 属性

  ```java
  public abstract class ApplicationEvent extends EventObject {
    private final long timestamp;
    public ApplicationEvent(Object source) {
      super(source);
      this.timestamp = System.currentTimeMillis();
    }
    public final long getTimestamp() {
      return this.timestamp;
    }
  }
  ```

- ApplicationEvent 有一个抽象实现类: `ApplicationContextEvent`:
  - 它是 **Spring 应用上下文事件**,将 Spring 应用上下文 (*ApplicationContext*) 作为事件源
  - 有如下几个常见的具体实现:
    - `ContextClosedEvent`
    - `ContextRefreshedEvent`
    - `ContextStartedEvent`
    - `ContextStoppedEvent`

  ```java
  public abstract class ApplicationContextEvent extends ApplicationEvent {
  
    /**
    * 创建一个新的 上下文启动事件(ContextStartedEvent)
    */
    public ApplicationContextEvent(ApplicationContext source) {
      super(source);
    }
    /**
    * 获取引发事件的应用上下文
    */
    public final ApplicationContext getApplicationContext() {
      return (ApplicationContext) getSource();
    }
  }
  ```

### 基于接口的事件监听器(ApplicationListener)

> Spring 为什么选择单事件监听模式?

`ApplicationListener` 是基于 Java 标准事件监听器 (*EventListener*) 的子接口,它有如下的几个特点:

1. 设计特点: 单一类型事件处理
2. 处理方法: `onApplicationEvent(ApplicationEvent)`
3. 事件类型: [ApplicationEvent](事件编程#spring-标准事件applicationevent)

下面是基本的示例:

```java
/**
 * {@link ApplicationListener} 示例
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see ApplicationListener
 * @see ApplicationEvent
 */
public class ApplicationListenerDemo {
  public static void main(String[] args) {
      GenericApplicationContext ctx = new GenericApplicationContext();
      ctx.addApplicationListener(new  MyEventListener());

      // 启动 Spring 应用上下文 -> 触发 ContextRefreshedEvent
      ctx.refresh();

      // 关闭 Spring 应用上下文 -> 触发 ContextStoppedEvent
      ctx.close();
  }
  static class MyEventListener implements ApplicationListener {
      @Override
      public void onApplicationEvent(ApplicationEvent event) {
          /**
           * out:
           *  接收到 Spring 事件,ContextRefreshedEvent,source[org.springframework.context.support.GenericApplicationContext@20ad9418, started on Sat Jul 29 20:02:27 CST 2023]
           * 接收到 Spring 事件,ContextClosedEvent,source[org.springframework.context.support.GenericApplicationContext@20ad9418, started on Sat Jul 29 20:02:27 CST 2023]
           */
          System.out.printf("接收到 Spring 事件,%s,source[%s]\r\n",event.getClass().getSimpleName(),event.getSource() );
      }
  }
}
```

### 基于注解的事件监听器(@EventListener)

> 起始于 Spring4.2

Spring 支持用`@EventListener` 标记事件监听器,它有以下的特点:

1. 设计特点: `支持多 ApplicantEvent 类型`,无需接口约束
    - **Spring 事件发布器会根据事件类型去匹配具体的 ApplicationListener,并发送事件**
2. 注解目标: `方法` 和 `注解`
3. **支持异步执行**
4. **支持泛型事件类型**
5. **支持顺序控制,配合`@Order` 注解控制**

```java
/**
 * {@link EventListener} 示例
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see EventListener
 */
public class AnnotationEventListenerDemo {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        context.register(AnnotationEventListenerDemo.class);
        context.refresh();
        context.close();
        /**
         * out:
         *      触发 ContextRefreshedEvent 事件(2)...
         *      触发 ContextRefreshedEvent 事件(1)...
         *      触发 ContextClosedEvent 事件...
         */
    }

    /**
     * 1. 支持多 ApplicantEvent 类型
     * 2. 支持 @Order 控制顺序
     */

    @EventListener
    @Order(2)
    public void refreshOne(ContextRefreshedEvent event) {
        System.out.println("触发 ContextRefreshedEvent 事件(1)...");
    }

    @EventListener
    @Order(1)
    public void refreshTwo(ContextRefreshedEvent event) {
        System.out.println("触发 ContextRefreshedEvent 事件(2)...");
    }

    @EventListener
    public void close(ContextClosedEvent event) {
        System.out.println("触发 ContextClosedEvent 事件...");
    }
}
```

## 注册 ApplicantionListener

> 直接注册与间接注册有啥区别?

注册 ApplicationListener 有两种方式:

1. **ApplicationListener 作为 Spring Bean 注册**
2. **通过 `ConfigurableApplicationContext` 的 API 进行注册**
    - 注册方法: `addApplicationListener`
    - [详细示例](事件编程#基于接口的事件监听器applicationlistener)

```java
/**
 * 将 {@link ApplicationListener} 注册为 Spring Bean
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class RegistryApplicationListener {

    @Bean
    public ApplicationListener cusApplicationListener() {
        return new CusApplicationListener();
    }

    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(RegistryApplicationListener.class);
        ctx.refresh();
        ctx.close();
        /**
         * out: 触发 ContextRefreshedEvent 事件...
         */
    }

    // 使用泛型具体化接收的事件类型
    static class CusApplicationListener implements ApplicationListener<ContextRefreshedEvent> {
        @Override
        public void onApplicationEvent(ContextRefreshedEvent event) {
            System.out.println("触发 ContextRefreshedEvent 事件...");
        }
    }
}
```

## 事件发布器

### 基本使用

Spring 通过 **事件发布器**来发布事件,有两种方法:

1. 通过 `ApplicationEventPublisher` 发布
    - 通过 **依赖注入** 的方式获取
      - 实现 `ApplicationEventPublisherAware` 接口
      - 实现 `ApplicationContextAware` 接口
    - 核心方法:
      - `publishEvent(ApplicationEvent event)`
2. 通过 `ApplicationEventMulticaster` 发布
    - 可以通过 **依赖查找 或 依赖注入** 的方式获取
      - 查找条件
        - Bean 名称: `applicationEventMulticaster`
        - Bean 类型: `ApplicationEventMulticaster`
    - 具有一定的管理能力,可以添加删除 ApplicationListener
    - 接口的两大实现:
      - 抽象类: `AbstractApplicationEventMulticaster`
      - 具体实现类: `SimpleApplicationEventMulticaster` (非常常用)
    - 核心方法
      - `addApplicationListener(ApplicationListener<?> listener)`
      - `addApplicationListenerBean(String listenerBeanName)`
        - 添加事件监听器
      - `multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType)`
        - eventType: 事件类型,与泛型处理有关联

```java
/**
 * {@link ApplicationEventPublisher} 示例
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see ApplicationEventPublisher
 */
public class ApplicationEventPublisherDemo  implements ApplicationEventPublisherAware {
    private static ApplicationEventPublisher applicationEventPublisher;
    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(ApplicationEventPublisherDemo.class);
        // api 的方式 注册事件监听器
        ctx.addApplicationListener(new CusApplicationListener());
        ctx.refresh();
        applicationEventPublisher.publishEvent(new CusEvent(ctx));
        ctx.close();

        /**
         * out:
         *  收到事件:CusEvent{
         *      source=org.springframework.context.annotation.AnnotationConfigApplicationContext@685f4c2e,
         *      started on Sat Jul 29 22:06:02 CST 2023
         * }
         */
    }

    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
        this.applicationEventPublisher = applicationEventPublisher;
    }

    static class CusEvent extends ApplicationContextEvent {
        public CusEvent(ApplicationContext source) {
            super(source);
        }

        @Override
        public String toString() {
            return "CusEvent{" +
                    "source=" + source +
                    "} ";
        }
    }

    static class CusApplicationListener implements ApplicationListener<CusEvent> {

        @Override
        public void onApplicationEvent(CusEvent event) {
            System.out.println("收到事件:" + event);
        }
    }
}
```

### 层次性上下文事件传播

- 问题说明:
  - 当 Spring 应用上下文出现多层次 Spring 应用上下文(ApplicationContext) 的时候,比如 SpringMvc、SpringBoot 或 SpringCloud场景下,由**子 ApplicationContext 发起的 Spring 事件可能会传递到其 parent ApplicationContext(直到 Root) 的过程**

- 如何避免?
  - `定位 Spring 事件源(ApplicationContext) 进行过滤处理`

#### 问题示例

下面展示层次性上下文事件传播的问题:

```java
/**
 * 层次性 Spring 应用上下文事件传播
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class HierarchicalApplicationEventDemo {
  public static void main(String[] args) {
      // 创建 parent Spring 应用上下文
      AnnotationConfigApplicationContext parentCtx = new AnnotationConfigApplicationContext();
      parentCtx.setId("parent-ctx");
      // 注册事件到 parent Spring 应用上下文
      parentCtx.addApplicationListener(new MyEventListener());

      // 创建 current Spring 应用上下文
      AnnotationConfigApplicationContext currentCtx = new AnnotationConfigApplicationContext();
      currentCtx.setId("current-ctx");
      currentCtx.addApplicationListener(new MyEventListener());

      // 设置 层次性
      currentCtx.setParent(parentCtx);

      // 启动 parent Spring 应用上下文
      parentCtx.refresh();
      // 启动 current Spring 应用上下文
      currentCtx.refresh();

      /***
       * out:
       *      接收到[parent-ctx]的 ContextRefreshedEvent...
       *      接收到[current-ctx]的 ContextRefreshedEvent...
       *      接收到[current-ctx]的 ContextRefreshedEvent...
       */

  }

  static class MyEventListener implements ApplicationListener<ContextRefreshedEvent> {
      @Override
      public void onApplicationEvent(ContextRefreshedEvent event) {
          System.out.printf("接收到[%s]的 ContextRefreshedEvent...\r\n",event.getApplicationContext().getId());
      }
  }
}
```

可以看出来,当前 Spring 应用上下文重复执行了两次  ContextRefreshedEvent

#### 问题分析

我们查看发布事件的源码:

1. 首先 `getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);` 会发布一次事件
2. 然后,如果当前 Spring 应用上下文有 parent,那么还再利用 parent 发布一次事件
    - 虽然是利用 parent 再次发布事件,但是事件中的 event 参数对象还是当前 Spring 应用上下文

```java
protected void publishEvent(Object event, @Nullable ResolvableType eventType) {

  // ...
  if (this.earlyApplicationEvents != null) {
    this.earlyApplicationEvents.add(applicationEvent);
  }
  else {
    // highlight-start
    // 正常首先在这里发布事件,然后事件监听器做出处理
    getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);
    // highlight-end
  }

  // 如果当前 Spring 应用上下文有 parent,那么还会发布一次事件
  if (this.parent != null) {
    // highlight-start
    if (this.parent instanceof AbstractApplicationContext) {
      ((AbstractApplicationContext) this.parent).publishEvent(event, eventType);
    }
    // highlight-end
    else {
      this.parent.publishEvent(event);
    }
  }
}
```

#### 处理方案

可以通过过滤的方式处理重复的事件处理:

```java
/**
 * 层次性 Spring 应用上下文事件传播
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class HierarchicalApplicationEventDemo {
    public static void main(String[] args) {
        // 创建 parent Spring 应用上下文
        AnnotationConfigApplicationContext parentCtx = new AnnotationConfigApplicationContext();
        parentCtx.setId("parent-ctx");
        // 注册事件到 parent Spring 应用上下文
        parentCtx.addApplicationListener(new MyEventListener());

        // 创建 current Spring 应用上下文
        AnnotationConfigApplicationContext currentCtx = new AnnotationConfigApplicationContext();
        currentCtx.setId("current-ctx");
        currentCtx.addApplicationListener(new MyEventListener());

        // 设置 层次性
        currentCtx.setParent(parentCtx);

        // 启动 parent Spring 应用上下文
        parentCtx.refresh();
        // 启动 current Spring 应用上下文
        currentCtx.refresh();

        /***
         * out:
         *      接收到[parent-ctx]的 ContextRefreshedEvent...
         *      接收到[current-ctx]的 ContextRefreshedEvent...
         */
    }

    static class MyEventListener implements ApplicationListener<ContextRefreshedEvent> {
        // highlight-start
        // 重复的过滤
        private static Set<String> processed = new LinkedHashSet<>();
        // highlight-start
        @Override
        public void onApplicationEvent(ContextRefreshedEvent event) {
            if (processed.add(event.getApplicationContext().getId())) {
                System.out.printf("接收到[%s]的 ContextRefreshedEvent...\r\n",event.getApplicationContext().getId());
            }
        }
    }
}
```

## Spring 内建事件

ApplicationContextEvent 有如下的派生事件:

1. `ContextRefreshedEvent`
    - Spring 应用上下文就绪事件
    - 调用 refresh() 方法时触发
2. `ContextStartedEvent`
    - Spring 应用上下文启动事件
    - 调用 start() 方法时触发
3. `ContextStoppedEvent`
    - Spring 应用上下文停止事件
    - 调用 stop() 方法时触发
4. `ContextClosedEvent`
    - Spring 应用上下文关闭事件
    - 调用 close() 方法时触发

### PayloadApplicationEvent

- `PayloadApplicationEvent` 主要用于: **简化 Spring 事件发送,关注于事件源主体**
- 发送方法:  `ApplicationEventPublisher#publishEvent(Object)`

:::tip 提示
一般使用不到该 Event,了解即可.
:::

## 自定义 Spring 事件

如果需要自定义 Spring 事件的话,一般需要下面 3 步骤:

1. **拓展 ApplicationEvent**
2. **实现 ApplicationListener,通过泛型参数指定自定义的 ApplicationEvent 类型**
3. **注册 ApplicationListener**

在[这里](事件编程#事件发布器) 已经给出基本的示例,这里再给出一个示例(*不过重写了 EventObject 的 getSource 方法*):

```java
/**
 * 自定义 Spring 事件
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class CusApplicationEventDemo implements ApplicationEventPublisherAware {

    private static ApplicationEventPublisher applicationEventPublisher;

    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(CusApplicationEventDemo.class);
        // 3. 注册自定义的 ApplicationListener
        ctx.addApplicationListener(new CusApplicationListener());
        ctx.refresh();
        // 发布事件
        applicationEventPublisher.publishEvent(new CusApplicationEvent("Hello,World"));
        ctx.close();
        /**
         * out: 收到来自 CusApplicationEvent 的消息:Hello,World
         */
    }

    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
        this.applicationEventPublisher = applicationEventPublisher;
    }


    // 1. 拓展 ApplicationEvent
    static class CusApplicationEvent extends ApplicationEvent {
        public CusApplicationEvent(String message) {
            super(message);
        }
        @Override
        public String getSource() {
            return (String)super.getSource();
        }
    }

    // 2. 实现 ApplicationListener,通过泛型参数指定自定义的 ApplicationEvent 类型
    static class CusApplicationListener implements ApplicationListener<CusApplicationEvent> {

        @Override
        public void onApplicationEvent(CusApplicationEvent event) {
            System.out.println("收到来自 CusApplicationEvent 的消息:" + event.getSource());
        }
    }
}
```

## 依赖注入 ApplicantEventPublisher

> 多种依赖注入方式获取的 ApplicantEventPublisher,哪个先执行?

一般有两种方式注入 **ApplicationEventPublisher**:

1. 实现 ApplicationEventListenerAware 的接口
2. 实现 ApplicationContextAware 的接口
3. 使用 @Autowired 等注解

```java
/**
 * 依赖注入 {@link ApplicationEventPublisher} 示例
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 * @see ApplicationEventPublisher
 * @see ApplicationEventPublisherAware
 * @see ApplicationContextAware
 * @see ApplicationContext
 */
public class InjectingApplicationEventPublisherDemo implements ApplicationContextAware, ApplicationEventPublisherAware {
    /**
     * 依赖注入的方式
     */
    @Resource
    private ApplicationContext applicationContext;

    @Resource
    private ApplicationEventPublisher applicationEventPublisher;

    @PostConstruct
    public void init() {
        applicationContext.publishEvent(new CusApplicationEvent("@Resource ApplicationContext send msg..."));
        applicationEventPublisher.publishEvent(new CusApplicationEvent("@Resource ApplicationEventPublisher send msg..."));
    }

    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(InjectingApplicationEventPublisherDemo.class);
        // 注册自定义的 ApplicationListener
        ctx.addApplicationListener(new CusApplicationListener());
        ctx.refresh();
        ctx.close();
        /**
         * out:
         *  收到来自 CusApplicationEvent 的消息:ApplicationEventPublisherAware send msg...
         *  收到来自 CusApplicationEvent 的消息:ApplicationContextAware send msg...
         *  收到来自 CusApplicationEvent 的消息:@Resource ApplicationContext send msg...
         *  收到来自 CusApplicationEvent 的消息:@Resource ApplicationEventPublisher send msg...
         * */
    }
    /**
     * 实现 Aware 接口,在
     */
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        applicationContext.publishEvent(new CusApplicationEvent("ApplicationContextAware send msg..."));
    }

    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
        applicationEventPublisher.publishEvent(new CusApplicationEvent("ApplicationEventPublisherAware send msg..."));
    }

    static class CusApplicationEvent extends ApplicationEvent {
        public CusApplicationEvent(String message) {
            super(message);
        }
        @Override
        public String getSource() {
            return (String)super.getSource();
        }
    }
    static class CusApplicationListener implements ApplicationListener<CusApplicationEvent> {
        @Override
        public void onApplicationEvent(CusApplicationEvent event) {
            System.out.println("收到来自 CusApplicationEvent 的消息:" + event.getSource());
        }
    }
}
```

:::caution 提示

1. Aware 接口中, ApplicationContextAware 和 ApplicationEventPublisherAware 执行的顺序在[这里说明过](Bean生命周期#依赖applicationcontext)
2. @PostConstruct 注解 和 两个 Aware 接口,分别由 CommonAnnotationBeanPostProcessor 和 ApplicationContextAwareProcessor 处理,而 CommonAnnotationBeanPostProcessor 后置处理器的执行顺序比 ApplicationContextAwareProcessor 低,所以先执行 Aware 接口
    - **在编写事件代码时候,需要考虑不同方式执行 publishEvent 的处理顺序,这个与 Bean 的生命周期以及 Order 都有关系**
3. 由于 ApplicationEventPublisher 属于 *游离对象(ResolvableDependency)*, 所以无法通过依赖查找的方式获取
:::

## 依赖查找 ApplicationEventMulticaster

在 Spring 应用上下文中是如何初始化 applicationEventMulticaster 的呢?

```java title="AbstractApplicationContext#initApplicationEventMulticaster"
protected void initApplicationEventMulticaster() {
  ConfigurableListableBeanFactory beanFactory = getBeanFactory();
  // highlight-start
  if (beanFactory.containsLocalBean("applicationEventMulticaster")) {
    this.applicationEventMulticaster = beanFactory.getBean("applicationEventMulticaster", ApplicationEventMulticaster.class);
  }
  else {
    this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
    beanFactory.registerSingleton("applicationEventMulticaster", this.applicationEventMulticaster);
  }
  // highlight-end
}
```

可以看到:

- 首先会判断当前 Spring 应用上下文容器中是否有 "beanName = applicationEventMulticaster" 的 Bean,然后将 "beanName = applicationEventMulticaster && beanClass=ApplicationEventMulticaster" 赋给 Spring 应用上下文容器
  - 这个说明, 在层次性容器中可以存在多个 *applicationEventMulticaster*
- 如果当前容器中没有的话,就创建一个 *SimpleApplicationEventMulticaster*,并且注册"外部单例对象"

## ApplicationEventPublisher 底层实现

- *ApplicationEventPublisher* 的底层基于接口 `ApplicationEventMulticaster` 实现

我们观察源码:

```java title="AbstractApplicationContext#publishEvent"
protected void publishEvent(Object event, @Nullable ResolvableType eventType) {
  // ...
  // 底层通过  ApplicationEventMulticaster 去发布事件
  getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);
  // ...
}
```

## 同步和异步 Spring 事件广播

### 基于 API

Spring 事件的同步和异步是基于: `SimpleApplicationEventMulticaster` 实现的,它有以下特点:

- **模式切换**: `setTaskExecutor(Executor)`
  - 默认模式: **同步**
  - 异步模式: **ThreadPoolExecutor**
- 设计问题: 非基于接口契约编程
- 需要注意的是,这种方式下切换同步、异步,是**全局的**!

```java
/**
 * Spring 异步事件
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class AsyncEventHandlerDemo {
    public static void main(String[] args) {
        GenericApplicationContext ctx = new GenericApplicationContext();
        ctx.addApplicationListener(new  AsyncCustomListener());

        // 会初始化 ApplicationEventMulticaster
        ctx.refresh();

        // 查找 ApplicationEventMulticaster
        SimpleApplicationEventMulticaster multicaster =
                (SimpleApplicationEventMulticaster)ctx.getBean("applicationEventMulticaster", ApplicationEventMulticaster.class);
        ctx.publishEvent(new AsyncCustomEvent("此时是同步的消息..."));

        // 将同步切换为异步,发送异步消息
        multicaster.setTaskExecutor(Executors.newSingleThreadExecutor());
        ctx.publishEvent(new AsyncCustomEvent("此时是异步的消息..."));
        ctx.close();

        /**
         * out:
         *      [线程: main]监听到事件:class AsyncEventHandlerDemo$AsyncCustomEvent ==> 此时是同步的消息...
         *      [线程: pool-1-thread-1]监听到事件:class AsyncEventHandlerDemo$AsyncCustomEvent ==> 此时是异步的消息...
         */
    }

    static class AsyncCustomEvent extends ApplicationEvent {
        public AsyncCustomEvent(String msg) {
            super(msg);
        }
    }

    static class AsyncCustomListener implements ApplicationListener<AsyncCustomEvent> {
        @Override
        public void onApplicationEvent(AsyncCustomEvent event) {
            System.out.printf("[线程: %s]监听到事件:%s ==> %s\n", Thread.currentThread().getName(), event.getClass(), event.getSource());
        }
    }
}
```

### 基于注解

通过注解 `@EventListener` 可以将一个方法标记为**监听方法**,并且支持同步、 异步的切换

- 默认模式: 同步
- 异步模式
  - 首先, 在监听方法上标注: `@Async` 注解,表示该监听方法是异步的
  - 然后, 通过 `@EnableAsync` 启用异步注解的支持

但是基于注解的方式,**无法在同步和异步之间进行切换**,监听方法要么是同步,要么是异步.

## 事件异常处理(ErrorHandler)

`ErrorHandler` 主要用于错误处理,它只有一个方法: `handleError(Throwable t)`, 有以下的使用场景:

- Spring 事件(Events): `SimpleApplicationEventMulticaster`
- Spring 本地调度(Scheduling)
  - `ConcurrentTaskScheduler`
  - `ThreadPoolTaskScheduler`

同样在 *SimpleApplicationEventMulticaster* 中,还定义了 `ErrorHandler`,当发布事件出现异常的时候会执行 **handleError** 方法。和[基于 api 的同步异步](事件编程#基于-api)类似,只需要 `setErrorHandler` 即可

下面是源码中的处理:

```java
protected void invokeListener(ApplicationListener<?> listener, ApplicationEvent event) {
  ErrorHandler errorHandler = getErrorHandler();
  if (errorHandler != null) {
    try {
      doInvokeListener(listener, event);
    }
    catch (Throwable err) {
      // highlight-start
      // 发生异常后进行错误处理
      errorHandler.handleError(err);
      // highlight-end
    }
  }
  else {
    doInvokeListener(listener, event);
  }
}
```

## Spring 事件/监听器实现原理

- 核心类: `SimpleApplicationEventMulticaster`
  - 设计模式: 观察者模式拓展
    - 被观察者(监听器): `ApplicationListener`
      - 通过 Api 添加
      - 通过 依赖查找/注入的方式获取
    - 通知对象(消息对象): `ApplicationEvent`
  - 执行模式: 同步/ 异步
  - 异常处理: `ErrorHandler`
  - 泛型处理: [ResolvableType](泛型处理#泛型优化实现-resolvabletype)

:::caution 注意
Listener 在监听事件的时候,不仅仅会监听当前事件类型,还会监听当前事件的子孙类事件,比如直接监听 ApplicationEvent,那么会处理所有的 Spring 事件.
:::

## 拓展

例举一些 SpringBoot 事件:

|               事件类型                |                说明                 |
| :-----------------------------------: | :---------------------------------: |
|      `ApplicationStartingEvent`       |        SpringBoot 应用启动中        |
|       `ApplicationStartedEvent`       |       SpringBoot 应用已经启动       |
| `ApplicationEnvironmentPreparedEvent` | SpringBoot Environment 实例已准备时 |
|      `ApplicationPreparedEvent`       |        SpringBoot 应用预备时        |
|        `ApplicationReadyEvent`        |      SpringBoot 应用完全可用时      |
|       `ApplicationFailedEvent`        |      SpringBoot 应用启动失败时      |

例举一些 SpringCloud 事件

|               事件类型                |                说明                 |
| :-----------------------------------: | :---------------------------------: |
|      `EnvironmentChangeEvent`       |        当 Environment 实例配置属性发生变化时        |
|      `HeartbeatEvent`               |        当 Discovery 客户端发送心跳时        |
|      `InstancePreRegisteredEvent`   |        当服务实例注册前       |
|      `InstanceRegisteredEvent`      |        当服务实例注册后       |
|      `RefreshEvent`                 |        当 RefreshEndpoint  被调用后       |
|      `RefreshScopeRefreshedEvent`   |        当Refresh Scope Bean 刷新后       |
