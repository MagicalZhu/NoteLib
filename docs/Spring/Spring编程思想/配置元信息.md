---
id: 配置元信息
title: 配置元信息
---

## 配置元信息

配置元信息基本有下面几类:

1. Spring Bean 配置元信息: `BeanDefinition`
2. Spring Bean 属性元信息: `PropertyValues`
3. Spring 容器配置元信息
4. Spring 外部化配置元信息: `PropertySource`
5. Spring Profile 元信息: `@Profile`

## Bean 配置元信息

> 关于 BeanDefinition 的详细可以参看 [元信息接口](Bean#元信息接口beandefinition)

- Bean 配置元信息(BeanDefinition)
  - `GenericBeanDefinition`: 通用型 BeanDefinition
  - `RootBeanDefinition`: 无 Parent 的 BeanDefinition 或者合并后的 BeanDefinition
  - `AnnotatedBeanDefinition`: 注解标注的 BeanDefinition

- GenericBeanDefinition 和 RootBeanDefinition 都继承自 `AbstractBeanDefinition`,两者最大的区别就是:前者可以设置 parent,而后者是顶层元信息,无法设置 parent。

- **AnnotatedBeanDefinition** 是面向注解的,本身它是一个接口,并且它是在 `BeanDefinition` 接口上进行拓展的,它暴露了 Bean Class 上的注解元信息(`AnnotationMetadata`)
  - 关于这个 *AnnotationMetadata* 一般采用 反射或者 `ASM 字节码` 的方式

```java
/**
 * 拓展了 BeanDefinition 接口,然后暴露了 Bean Class 上的注解元信息(AnnotationMetadata)
 *
 */
public interface AnnotatedBeanDefinition extends BeanDefinition {

    /**
     * 返回注解元信息
     */
    AnnotationMetadata getMetadata();

    @Nullable
    MethodMetadata getFactoryMethodMetadata();
}
```

## Bean 属性元信息

- Bean 属性元信息(PropertyValues)
  - 可修改的实现: `MutablePropertyValues`
  - 元素成员: `PropertyValue`
- Bean 属性上下文存储: `AttributeAccessor`
- Bean 元信息元素: `BeanMetadataElement`

注意: **BeanDefinition 继承了 AttributeAccessor 和 BeanMetadataElement**

```java title=BeanDefinition.java
public interface BeanDefinition extends 
                AttributeAccessor, BeanMetadataElement {
  //....
}
```

### AttributeAccessor

这个接口的操作很简单,就是对*attribute(属性)* 进行添加、删除、查询:

```java
public interface AttributeAccessor {
  // 设置属性
  void setAttribute(String name, @Nullable Object value);

  // 通过属性名获取属性值
  @Nullable
  Object getAttribute(String name);

  // 通过属性名删除属性,并返回删除的属性值
  @Nullable
  Object removeAttribute(String name);

  // 判断是否包含某个属性名
  boolean hasAttribute(String name);

  // 获取属性名称
  String[] attributeNames();
}
```

1. 虽然 BeanDefinition 继承自 AttributeAccessor,但是它对 BeanDefinition 的影响几乎为 0,不影响 Bean 的生成

2. 虽然它也是设置属性的,但是一般来说 Bean 的配置元信息都存储在 `PropertyValues` 中,并且通过 `getPropertyValues()` 方法可以返回一个 ***可修改的 PropertyValues***。

3. AttributeAccessor 可以用来 **存储一些中间状态,为 BeanDefinition 添加一些附加属性**

一个简单的示例,将 attribute 中的特定属性值设置到 BeanDefinition 的配置元信息中:

```java
/**
 * Bean 配置元信息
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class BeanConfigurationMetadataDemo {
  public static void main(String[] args) {
      // 创建 BeanDefinition
      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(User.class);
      builder.addPropertyValue("name", "athu");
      AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();
      //highlight-start
      // 附加属性(不会影响 Bean 的实例化、属性赋值、初始化)
      beanDefinition.setAttribute("id", 22L);
      //highlight-end
      // 注册 BeanDefinition
      DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
      beanFactory.registerBeanDefinition("user",beanDefinition);

      // 利用 BeanPostProcessor + attribute 设置属性值
      beanFactory.addBeanPostProcessor(new BeanPostProcessor() {
          @Override
          public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
              if (beanName.equals("user")) {
                  //highlight-start
                  // 获取 BeanDefinition(合并后的 BeanDefinition)
                  BeanDefinition bd = beanFactory.getBeanDefinition(beanName);
                  // 获取 设置的 attribute 属性(属性上下文)
                  Long id = (Long)bd.getAttribute("id");
                  ((User)bean).setId(id);
                  //highlight-end
              }
              return bean;
          }
      });

      User bean = beanFactory.getBean("user", User.class);
      // out: User{id=22, name='athu'}
      System.out.println(bean);
  }
}
```

### BeanMetadataElement

它只有一个方法 `getSource()`,用于表示**该 BeanDefinition 的来源是哪**?

```java
public interface BeanMetadataElement {
  @Nullable
  default Object getSource() {
    return null;
  }
}
```

比如上面的示例中,我将 BeanDefinition 的来源设置为当前测试类:

```java
/**
 * Bean 配置元信息
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class BeanConfigurationMetadataDemo {
  public static void main(String[] args) {
      // 创建 BeanDefinition
      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(User.class);
      builder.addPropertyValue("name", "athu");
      AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();
      // 附加属性(不会影响 Bean 的实例化、属性赋值、初始化)
      beanDefinition.setAttribute("id", 22L);
      //highlight-start
      // 设置 BeanDefinition 的来源
      beanDefinition.setSource(BeanConfigurationMetadataDemo.class)
      //highlight-end
      // ...
  }
}
```

## 容器配置元信息

### 容器元信息

#### beans 元素

在 Spring XML 配置元信息文件中,我们可以通过对 `beans` 元素进行配置,来设置多个 bean 或者导入的 beans 的默认属性

| bean 元素属性               | 默认值  | 使用场景                                                     |
| :---------------------------: | :-------: | :------------------------------------------------------------: |
| **profile**                 | null    | Spring Profiles 配置值                                       |
| **default-lazy-init**           | default | 当 outer beans “default-lazy-init” 属性存在时,继承该值,否则为 false |
| **default-merge**               | default | 当 outer beans “default-merge” 属性存在时,继承该值,否则为 false |
| **default-autowire**            | default | 当 outer beans “default-autowire” 属性存在时,继承该值,否则为 no |
| **default-autowire-candidates** | null    | 默认 Spring Beans 名称 pattern(通过通配符等方式模糊匹配一些 bean) |
| **default-init-method**         | null    | 默认 Spring Beans 自定义初始化方法                           |
| **default-destory-method**      | null    | 默认 Spring Beans 自定义销毁方法                             |

:::info 关于 outer beans
比如在一个 XML 配置文件 A 中导入另一个 XML 配置元信息文件 B,那么这个 XML 文件 A 中的 beans 就是 outer beans
:::

#### 应用上下文(context 元素)

在 Spring XML 配置元信息文件中,我们可以对通过 `context` 属性对应用上下文进行一些配置:

| bean 元素属性               | 使用场景                                                     |
| :---------------------------: | :------------------------------------------------------------: |
| **<context:annotation-config/>**  | 激活 Spring 注解驱动                                       |
| **<context:component-scan/>**     | Spring @Component 以及自定义注解扫描 |
| **<context:load-time-weaver/>**   | 激活 Spring LoadTimeWeaver |
| **<context:mbean-export/>**       | 暴露 Spring Beans 作为 JMX Beans |
| **<context:mbean-server/>**       | 将当前平台作为 MBeanServer |
| **<context:property-placeholder/>**  | 加载外部化配置资源作为 Spring 属性配置                           |
| **<context:property-override/>**     | 利用外部化配置资源覆盖 Spring 属性值                             |

### 源码分析

#### BeanDefinitionParserDelegate

我们知道 Bean 的配置元信息会被 BeanDefinitionParser [解析](Bean生命周期#元信息解析),实际上,Spring 通过一个委托(代理) `BeanDefinitionParserDelegate` 来解析 XML 配置文件

我们简单的看下这个类,可以看到里面定义了 bean 元素标签和属性名,并且有常见的方法:

1. `populateDefaults()` : 填充 beans 的几个默认属性值
2. `parseConstructorArgElements()`: 解析 constructor-arg 元素
3. `parseBeanDefinitionElement()` : 将元素解析成 BeanDefinition
4. `parseCustomElement()` : 将个性化元素标签解析到 BeanDefinition 中

```java
public class BeanDefinitionParserDelegate {
  // beans 属性的 namespace
  public static final String BEANS_NAMESPACE_URI = "http://www.springframework.org/schema/beans";
  // 多值属性的分隔符
  public static final String MULTI_VALUE_ATTRIBUTE_DELIMITERS = ",; ";
  // ...
  // name 属性
  public static final String NAME_ATTRIBUTE = "name";
  // <bean> 元素标签名称
  public static final String BEAN_ELEMENT = "bean";
  // <meta> 元素标签名称
  public static final String META_ELEMENT = "meta";
  // id 属性
  public static final String ID_ATTRIBUTE = "id";
  // class 属性
  public static final String CLASS_ATTRIBUTE = "class";
  // ...
  // default-lazy-init 属性
  public static final String DEFAULT_LAZY_INIT_ATTRIBUTE = "default-lazy-init";
  // default-merge 属性
  public static final String DEFAULT_MERGE_ATTRIBUTE = "default-merge";
  // default-autowire  属性
  public static final String DEFAULT_AUTOWIRE_ATTRIBUTE = "default-autowire";
  // default-autowire-candidates 属性
  public static final String DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE = "default-autowire-candidates";
  // default-init-method 属性
  public static final String DEFAULT_INIT_METHOD_ATTRIBUTE = "default-init-method";
  // default-destroy-method 属性
  public static final String DEFAULT_DESTROY_METHOD_ATTRIBUTE = "default-destroy-method";

  // 对 beans 填充默认值
  protected void populateDefaults(DocumentDefaultsDefinition defaults, 
                        @Nullable DocumentDefaultsDefinition parentDefaults, 
                        Element root) {
    String lazyInit = root.getAttribute(DEFAULT_LAZY_INIT_ATTRIBUTE);
    if (isDefaultValue(lazyInit)) {
      lazyInit = (parentDefaults != null ? parentDefaults.getLazyInit() : FALSE_VALUE);
    }
    defaults.setLazyInit(lazyInit);
    // ...
    if (root.hasAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE)) {
      defaults.setDestroyMethod(root.getAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE));
    }
    else if (parentDefaults != null) {
      defaults.setDestroyMethod(parentDefaults.getDestroyMethod());
    }
    defaults.setSource(this.readerContext.extractSource(root));
  }

  // 将元素解析成 BeanDefinition
  public AbstractBeanDefinition parseBeanDefinitionElement(
                      Element ele, 
                      String beanName,
                      @Nullable BeanDefinition containingBean) {
    // ...
    try {
      AbstractBeanDefinition bd = createBeanDefinition(className, parent);
      // 解析 bean 元素中的属性
      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
      // 解析 bean 元素的子元素标签
      parseMetaElements(ele, bd);
      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());
      parseConstructorArgElements(ele, bd);
      parsePropertyElements(ele, bd);
      parseQualifierElements(ele, bd);
      bd.setResource(this.readerContext.getResource());
      bd.setSource(extractSource(ele));
      return bd;
    }
    // ...
  }

  // 将个性化元素标签解析到 BeanDefinition 中
  public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) {
    String namespaceUri = getNamespaceURI(ele);
    if (namespaceUri == null) {
      return null;
    }
    // highlight-start
    // 执行 NamespaceHandler#resolve
    NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
    // highlight-end
    if (handler == null) {
      error("Unable to locate Spring NamespaceHandler for XML schema namespace [" + namespaceUri + "]", ele);
      return null;
    }
    return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));
  }

}
```

#### XML schema

通过 `BeanDefinitionParser` 可以将 XML 解析得到配置元信息(Bean 配置元信息、容器配置元信息....),为此 Spring 定义了一套 XML Schema。这个 Schema 文件定义了 XML 种各个元素属性信息。

下面给出一段 XML 配置元信息文件:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/beans/spring-context.dtd"
        default-autowire="default"
       default-lazy-init="false">
    <!--激活注解驱动-->
    <context:annotation-config/>

    <!--定义一个 Bean 的配置元信息-->
    <bean id="user" class="ioc.overview.Domain.User"/>
</beans>
```

可以看到 XML 会引入 `dtd` 以及 `schema` 文件,以 *beans* 元素为例,简单的看下 schema 文件,以简单的 bean 元素为例

```xml
<xsd:element name="bean">
  <!-- 这里不是注解的意思,而是注释 -->
  <xsd:annotation>
    <xsd:documentation source="java:org.springframework.beans.factory.config.BeanDefinition"><![CDATA[
    Defines a single (usually named) bean.
    A bean definition may contain nested tags for constructor arguments,
    property values, lookup methods, and replaced methods. Mixing constructor
    injection and setter injection on the same bean is explicitly supported.
    ]]></xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
    <xsd:complexContent>
      <xsd:extension base="identifiedType">
        <!-- 这里表示 bean 元素中的子元素是一个 group -->
        <xsd:group ref="beanElements"/>
        <!-- 这里表示 bean 元素的属性也是一个 group -->
        <xsd:attributeGroup ref="beanAttributes"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
</xsd:element>
<!-- 这里定义了 bean 元素中的子元素信息 -->
<xsd:group name="beanElements">
  <xsd:sequence>
    <xsd:element ref="description" minOccurs="0"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:element ref="meta"/>
      <xsd:element ref="constructor-arg"/>
      <xsd:element ref="property"/>
      <xsd:element ref="qualifier"/>
      <xsd:element ref="lookup-method"/>
      <xsd:element ref="replaced-method"/>
      <xsd:any namespace="##other" processContents="strict" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:choice>
  </xsd:sequence>
</xsd:group>
```

## 装载 Bean 配置元信息

我们有多种方式来定义 Bean 的配置元信息:

1. XML
2. Properties
3. Java 注解
4. 底层 API

### 基于 XML(源码)

> 基于 XML 资源来装载 Spring 配置元信息,底层实现为 `XMLBeanDefinitionReader`

Spring Bean 配置元信息:

| XML 元素 | 使用场景 |
| :-----: | :----- : |
| <beans:beans/> | 单个 XML 资源下的多个 Spring Beans 的配置 |
| <beans:bean> | 单个 Spring Bean 定义(BeanDefinition) 配置 |
| <beans:alias/> | 为 Spring Bean 定义(BeanDefinition) 映射别名 |
| <beans:import/> | 加载外部 Spring XML 配置资源 |

我们看下源码中,XMLBeanDefinitionReader 是如何加载 Bean 配置元信息的?

- 首先看到的是,方法入口点为: `XmlBeanDefinitionReader#registerBeanDefinitions()`,这一步主要有下面的处理过程:
  - 创建 **DefaultBeanDefinitionDocumentReader**
  - **注册多个 BeanDefinition**,这一步很重要,在执行 **createReaderContext()** 的时候会创建命名空间处理器: `NamespaceHandlerResolver`

```java title=XmlBeanDefinitionReader#registerBeanDefinitions
public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
  // 创建 DefaultBeanDefinitionDocumentReader
  BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
  int countBefore = getRegistry().getBeanDefinitionCount();
  // highlight-start
  // 注册多个 BeanDefinition
  documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
  // highlight-end
  return getRegistry().getBeanDefinitionCount() - countBefore;
}
```

- 在上一步中看到的创建 *NamespaceHandlerResolver*,实际是创建一个 `DefaultNamespaceHandlerResolver` 对象
  - 需要注意的是,创建时的常量 **DEFAULT_HANDLER_MAPPINGS_LOCATION = META-INF/spring.handlers**

```java
// XmlBeanDefinitionReader#createDefaultNamespaceHandlerResolver
protected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() {
  ClassLoader cl = (getResourceLoader() != null ? getResourceLoader().getClassLoader() : getBeanClassLoader());
  // highlight-start
  return new DefaultNamespaceHandlerResolver(cl);
  // highlight-end
}

// DefaultNamespaceHandlerResolver#DefaultNamespaceHandlerResolver
public DefaultNamespaceHandlerResolver(@Nullable ClassLoader classLoader) {
  this(classLoader, DEFAULT_HANDLER_MAPPINGS_LOCATION);
}
```

- 接下来就是开始注册了,这一步会调用一开始创建的 `DefaultBeanDefinitionDocumentReader#parseBeanDefinitions`
  - **解析默认的元素标签**: 比如 bean、import、alias
    - 这里会调用 [BeanDefinitionParserDelegate](配置元信息#beandefinitionparserdelegate) 的 **parseBeanDefinitionElement** 方法
  - **解析自定义的元素标签,不同的元素标签需要对应的 handler**
    - 这里会调用 [BeanDefinitionParserDelegate](配置元信息#beandefinitionparserdelegate) 的 **parseCustomElement** 方法

```java
protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
  if (delegate.isDefaultNamespace(root)) {
    NodeList nl = root.getChildNodes();
    for (int i = 0; i < nl.getLength(); i++) {
      Node node = nl.item(i);
      if (node instanceof Element) {
        Element ele = (Element) node;
        // 如果namespace 是 beans
        if (delegate.isDefaultNamespace(ele)) {
          // highlight-start
          // 解析默认的元素
          parseDefaultElement(ele, delegate);
          // highlight-end
        }
        else {
          // highlight-start
          // 解析自定义元素
          delegate.parseCustomElement(ele);
          // highlight-end
        }
      }
    }
  }
  else {
    delegate.parseCustomElement(root);
  }
}
```

- 我们知道解析个性化元素标签的时候会通过 `NamespaceHandler#parse()` 获取 parser 解析器,然后通过 parser 解析不同的元素标签。并且这个 NamespaceHandler 是通过读取 jar 文件中的 `META-INF/spring.handlers` 获取的(利用反射),以 spring-context 为例:

```ini
http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler
http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler
http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler
http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler
http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler
```

可以看到 Spring 利用 *ContextNamespaceHandler* 来处理 context 元素,并且 ContextNamespaceHandler 注册了很多 parser 解析器,用于解析 context 命名空间下的不同元素标签

```java
public class ContextNamespaceHandler extends NamespaceHandlerSupport {
  @Override
  public void init() {
    registerBeanDefinitionParser("property-placeholder", new PropertyPlaceholderBeanDefinitionParser());
    registerBeanDefinitionParser("property-override", new PropertyOverrideBeanDefinitionParser());
    // highlight-start
    // 处理注解驱动
    registerBeanDefinitionParser("annotation-config", new AnnotationConfigBeanDefinitionParser());
    // highlight-end
    registerBeanDefinitionParser("component-scan", new ComponentScanBeanDefinitionParser());
    registerBeanDefinitionParser("load-time-weaver", new LoadTimeWeaverBeanDefinitionParser());
    registerBeanDefinitionParser("spring-configured", new SpringConfiguredBeanDefinitionParser());
    registerBeanDefinitionParser("mbean-export", new MBeanExportBeanDefinitionParser());
    registerBeanDefinitionParser("mbean-server", new MBeanServerBeanDefinitionParser());
  }
}
```

### ~~基于 Properties~~

> 基于 Properties 资源来装载 Spring 配置元信息,底层实现为 `PropertiesBeanDefinitionReader`

Spring Bean 配置元信息:

| Properties 属性名 | 使用场景                        |
| ----------------- | ------------------------------- |
| `(class)`         | Bean 类全限定名                 |
| `(abstract)`      | 是否为抽象的 BeanDefinition     |
| `(parent)`        | 指定 parent BeanDefinition 名称 |
| `(lazy-init)`     | 是否延迟初始化                  |

详细示例可以参看 [Properties 配置](Bean生命周期#properties-配置)

### 基于 Java 注解

- Spring 模式注解

  | Spring 注解 | 场景说明 | 起始版本 |
  | :---------:| :------:| :-----: |
  | `@Repository` | 数据仓储模式注解 | 2.0 |
  | `@Component` |  通用主键模式注解 | 2.5 |
  | `@Service` | 服务模式注解 | 2.5 |
  | `@Controller` | Web 控制器模式注解 | 2.5 |
  | `@Configuration` | 配置类模式注解 |  3.0 |

- Spring Bean 依赖注入注解

  | Spring 注解 | 场景说明 | 起始版本 |
  | :---------:| :------:| :-----: |
  | `@Autowired` | Bean 依赖注入,支持多种依赖查找方式 | 2.5 |
  | `@Qualifier` |  细粒度的 | 2.5 |
  | `@Resource` | 服务模式注解 | 2.5 |
  | `@Inject` | Web 控制器模式注解 | 2.5 |

### 底层实现

## 装载容器配置元信息

### 基于 XML

### 基于注解

## 拓展Spring XML 元素

## 装载外部化配置

### 基于 Properties 文件

### 基于 YAML 文件
