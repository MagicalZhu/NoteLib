---
id: 依赖来源
title: 依赖来源
---

> 主要说明了依赖的来源有哪些,比如 SpringBeanDefinition、"单例"对象、游离对象(ResolvableDependency),以及这些依赖的来源的注册入口在哪里

## 依赖查找的来源

- 查找的来源,一般有两个

  | 来源                      | 配置元数据                       |
  |:-------------------------:|:--------------------------------:|
  | **Spring BeanDefinition** | 配置文件(XML、Properties...)                       |
  |                           | Java 注解(@Bean)                  |
  |                           | Java API(BeanDefinitionBuilder)   |
  | **"单例"对象**               | API 实现                           |

- Spring **内建**的一些 **BeanDefinition**,可以参看[这里](依赖查找#注解驱动spring应用上下文-内建可查找的依赖部分)
  - 这些基本在 `AnnotationConfigUtils` 中进行注册
  - 这个只需要配置了注解配置驱动(XML 的 context 配置了 annotation-config属性、component-scan属性等)
  - <mark>这里指的是Spring 内建的 BeanDefinition,没有包含用户通过 XML 等方式注册的 BeanDefinition</mark>

- Spring 内建的一些 **单例对象**,可以参看[这里](依赖查找#abstractapplicationcontext-内建可查找的依赖)
  - 这些基本在`AbstractApplicationContext#prepareBeanFactory` 中进行注册

## 依赖注入的来源

- 注入的来源,一般下面三个

  | 来源                      | 配置元数据                       |
  |:-------------------------:|:--------------------------------:|
  | **Spring BeanDefinition** | 配置文件(XML、Properties...)                       |
  |                           | Java 注解(@Bean)                  |
  |                           | Java API(BeanDefinitionBuilder)   |
  | **单例对象**               | API 实现                           |
  | **游离对象(ResolvableDependency)**   |                          |

依赖注入的来源比依赖查找的来源多了一个**游离对象**,它们会在 *应用上下文* 启动的时候[注册](依赖来源#非-spring-容器管理对象)到容器中

```java title=AbstractApplicationContext#prepareBeanFactory
beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
beanFactory.registerResolvableDependency(ResourceLoader.class, this);
beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
beanFactory.registerResolvableDependency(ApplicationContext.class, this);
```

这些游离对象可以被注入,但是无法通过依赖查找的方式获取到:

```java
/**
 * 依赖注入和依赖查找的来源并不相同
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class DifferentSourceDemo {

    private BeanFactory beanFactory;
    private ResourceLoader resourceLoader;
    private ApplicationEventPublisher applicationEventPublisher;
    private ApplicationContext applicationContext;

    // Autowired 注解的处理在 postProcessorProperties 中,早于 Setter 注入,也早于 @PostConstruct
    @Autowired
    public DifferentSourceDemo(BeanFactory beanFactory,
                               ResourceLoader resourceLoader,
                               ApplicationEventPublisher applicationEventPublisher,
                               ApplicationContext applicationContext) {
        this.beanFactory = beanFactory;
        this.resourceLoader = resourceLoader;
        this.applicationEventPublisher = applicationEventPublisher;
        this.applicationContext = applicationContext;
    }

    @PostConstruct
    public void injectAutowiring() {
        // out: beanFactory == applicationContext:false
        System.out.println("beanFactory == applicationContext:"+(beanFactory == applicationContext));
        // out: beanFactory == applicationContext.getAutowireCapableBeanFactory():true
        System.out.println("beanFactory == applicationContext.getAutowireCapableBeanFactory():"+(beanFactory == applicationContext.getAutowireCapableBeanFactory()));
        // out: resourceLoader == applicationContext:true
        System.out.println("resourceLoader == applicationContext:"+(resourceLoader == applicationContext));
        // out: applicationEventPublisher == applicationContext:true
        System.out.println("applicationEventPublisher == applicationContext:"+(applicationEventPublisher == applicationContext));
    }

    @PostConstruct
    public void injectByLookUp() {
        // out: 无法找到org.springframework.beans.factory.BeanFactory类型的Bean!
        getBean(BeanFactory.class);
        // out: 无法找到org.springframework.core.io.ResourceLoader类型的Bean!
        getBean(ResourceLoader.class);
        // out: 无法找到org.springframework.context.ApplicationEventPublisher类型的Bean!
        getBean(ApplicationEventPublisher.class);
        // out: 无法找到org.springframework.context.ApplicationContext类型的Bean!
        getBean(ApplicationContext.class);
    }

     public <T> T getBean(Class<T> beanType) {
         try {
            return beanFactory.getBean(beanType);
         }catch (NoSuchBeanDefinitionException ex) {
             System.err.println("无法找到"+beanType.getTypeName()+"类型的Bean!");
         }
         return null;
     }

    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(DifferentSourceDemo.class);
        ctx.refresh();
        ctx.close();
    }
}
```

## Spring 容器管理、游离对象的注册

- 依赖对象

  | 来源                      | Bean 对象  | 生命周期管理 | 配置元信息 | 使用场景 |
  |:-------------------------:|:-----------------:|:---------:|:--------:|:-------:|
  | **Spring BeanDefinition** | 是                | 是         |  有  | 查找+注入 |
  | **"单例"对象**              | 是                | 否         |  无  | 查找+注入 |
  | **游离对象(ResolvableDependency)**  | 否                | 否         |  无  | 注入 |

:::caution 注意

这里所说的是否是 Bean 对象,很重要的一点就是: **是否能通过依赖查找的方式获取**,而游离对象(ResolvableDependency) 是无法通过依赖查找的方式获取的

:::

### Spring BeanDefinition

- 要素
  1. 元数据: [BeanDefinition](Bean#beandefinition)
  2. 注册入口: [BeanDefinitionRegistry#registerBeanDefinition](Bean#beandefinition-注册到ioc容器)
  3. 类型: 延迟和非延迟(lazy)
  4. 顺序: Bean 生命周期顺序按照注册顺序

#### 如何理解顺序

> BeanDefinition 的注册是通过 BeanDefinitionRegistry 的 registerBeanDefinition 方法实现的, BeanDefinitionRegistry 是一个接口,所以该方法的实现是由`DefaultListableBeanFactory#registerBeanDefinition` 实现的

在 Spring 的 XML 配置文件定义的顺序和 BeanDefinition 的注册顺序是一致的,为了保证这一点,DefaultListableBeanFactory 在实现 registerBeanDefinition 的时候,加入了一个冗余的 List 类型的成员: `beanDefinitionNames`:

```java title=DefaultListableBeanFactory#registerBeanDefinition
// highlight-start
// 一些定义的成员变量
// 存储 BeanDefinition 的 Map结构[key: beanName, value: BeanDefinition]
private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);

// 存储 beanName 的 List 集合,用于确定注册的顺序(因为 beanDefinitionMap 是无序的)
private volatile List<String> beanDefinitionNames = new ArrayList<>(256);
// highlight-end

public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
                                    throws BeanDefinitionStoreException {

  // 1. BeanDefinition 的校验
  if (beanDefinition instanceof AbstractBeanDefinition) {
    try {
      ((AbstractBeanDefinition) beanDefinition).validate();
    }
    catch (BeanDefinitionValidationException ex) {
      throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
          "Validation of bean definition failed", ex);
    }
  }
  // 2. 从 BeanDefinitionMap 中通过 beanName 查看BeanDefinition 是否已经存在
  BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
  if (existingDefinition != null) {
    // 2.1 如果存在,但是不允许进行 "BeanDefinition的覆盖",则抛出异常
    // 注意: SpringBoot 2.1 之后默认是false,即不允许 BeanDefinition的覆盖
    if (!isAllowBeanDefinitionOverriding()) {
      throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
    }
    // ...
    // 替换 BeanDefinitionMap 中原有的 BeanDefinition
    this.beanDefinitionMap.put(beanName, beanDefinition);
  }
  else {
    // 如果 BeanDefinitionMap 中不存在指定的 BeanDefinition 
    
    // 如果 Bean 在创建的过程中
    if (hasBeanCreationStarted()) {
      synchronized (this.beanDefinitionMap) {
        this.beanDefinitionMap.put(beanName, beanDefinition);
        List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
        updatedDefinitions.addAll(this.beanDefinitionNames);
        updatedDefinitions.add(beanName);
        this.beanDefinitionNames = updatedDefinitions;
        removeManualSingletonName(beanName);
      }
    }
    else {
      // 将 beanName 和 BeanDefinition 存入beanDefinitionMap
      this.beanDefinitionMap.put(beanName, beanDefinition);
      // 将 beanName 存入 beanDefinitionNames
      this.beanDefinitionNames.add(beanName);
      removeManualSingletonName(beanName);
    }
    this.frozenBeanDefinitionNames = null;
  }

  if (existingDefinition != null || containsSingleton(beanName)) {
    resetBeanDefinition(beanName);
  }
}
```

### 单例对象

- 要素
  1. 来源: 外部普通 Java 对象(不一定是 POJO)
  2. 注册入口: `SingletonBeanRegistry#registerSingleton`

- 限制
  1. 没有配置元信息, 没有生命周期的管理(Bean 的创建与销毁是开发者自省处理的)
  2. 无法实现延迟初始化 Bean (注册Bean 的时候已经创建完成了)

> 单例对象对象由 SingletonBeanRegistry的实现类 `DefaultSingletonBeanRegistry#registerSingleton` 进行注册,同时 DefaultListableBeanFactory 通过实现 ConfigurableListableBeanFactory 接口间接的实现了 `SingletonBeanRegistry的实现类`

它的处理方式很简单: 向 Map 中添加[key: beanName, value: 单例对象] 的数据,然后在 **getBean** 的时候只需要从这个 Map 中通过 beanName 取出单例对象即可,而 BeanDefinition 的话则还需要通过 BeanDefinition 元信息来创建 Bean 对象(好处就是添加生命周期管理)

```java title=DefaultSingletonBeanRegistry#registerSingleton
// highlight-start
// 一些定义的成员变量
// 缓存外部的单例对象[key: beanName, value: 单例对象] 的 Map
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
// 存储单例对象 beanName 的 LinkedHashSet 集合,是有序的,由于确保注册的单例对象的顺序
private final Set<String> registeredSingletons = new LinkedHashSet<>(256);
// highlight-end

@Override
public void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {
  Assert.notNull(beanName, "Bean name must not be null");
  Assert.notNull(singletonObject, "Singleton object must not be null");
  synchronized (this.singletonObjects) {
    Object oldObject = this.singletonObjects.get(beanName);
    if (oldObject != null) {
      throw new IllegalStateException("Could not register object [" + singletonObject +
          "] under bean name '" + beanName + "': there is already object [" + oldObject + "] bound");
    }
    addSingleton(beanName, singletonObject);
  }
}

protected void addSingleton(String beanName, Object singletonObject) {
  synchronized (this.singletonObjects) {
    // 向 singletonObjects 中添加注册的单例对象信息
    this.singletonObjects.put(beanName, singletonObject);
    this.singletonFactories.remove(beanName);
    this.earlySingletonObjects.remove(beanName);
    // 向 registeredSingletons 中添加注册的单例对象的 BeanName,是有序的
    this.registeredSingletons.add(beanName);
  }
}
```

### 非 Spring 容器管理对象

- 要素
  1. 注册入口: `ConfigurableListableBeanFactory#registerResolvableDependency`
- 限制
  1. 没有配置元信息, 没有生命周期的管理
  2. 无法实现延迟初始化 Bean
  3. 无法通过依赖查找,只能依赖注入

需要注意的是,这种注册方式没有提供 BeanName,所以进行依赖注入的时候需要依赖 Bean 的类型,如果存在两个类型一致的,那么注册的时候会被后者覆盖

```java title=DefaultListableBeanFactory#registerResolvableDependency
// highlight-start
// 一些定义的成员变量
// 缓存非 Spring 容器管理对象[key: 对象类型, value: 非托管对象] 的 Map
private final Map<Class<?>, Object> resolvableDependencies = new ConcurrentHashMap<>(16);
// highlight-end
@Override
public void registerResolvableDependency(Class<?> dependencyType, @Nullable Object autowiredValue) {
  Assert.notNull(dependencyType, "Dependency type must not be null");
  if (autowiredValue != null) {
    if (!(autowiredValue instanceof ObjectFactory || dependencyType.isInstance(autowiredValue))) {
      throw new IllegalArgumentException("Value [" + autowiredValue +
          "] does not implement specified dependency type [" + dependencyType.getName() + "]");
    }
    this.resolvableDependencies.put(dependencyType, autowiredValue);
  }
}
```

#### 测试示例

```java
/**
 * 利用 ResolvableDependency 注册非 Spring 容器托管的对象
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class ResolvableDependencyDemo {
  @Resource
  private String author;

  @PostConstruct
  public void init() {
    // out: Hello
    System.out.println(author);
  }
  public static void main(String[] args) {
      AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
      ctx.register(ResolvableDependencyDemo.class);
      // 通过 BeanFactoryPostProcessor 回调来注册
      ctx.addBeanFactoryPostProcessor(beanFactory -> {
          beanFactory.registerResolvableDependency(String.class, "Hello");
      });
      ctx.refresh();
      ctx.close();
  }
}
```

## 外部化配置

> 除了上面的几种依赖来源,Spring 还有外部化配置做为 Spring 容器的依赖来源。外部化配置来源于 SpringBoot

- 要素
  1. 类型: 非常规的 Spring 对象依赖来源

- 限制
  1. 没有配置元信息, 没有生命周期的管理
  2. 无法实现延迟初始化 Bean
  3. 无法通过依赖查找,只能依赖注入

通过 `@Value` 注解的方式将外部化配置信息注入进来

```java
/**
 * 外部化配置作为依赖来源(在 class-path 下新建一个文件: META-INF/default.properties)
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */

// @Configuration 表示是一个配置类
@Configuration
// @PropertySource 绑定外部化配置文件的路径、编码
@PropertySource(value="META-INF/default.properties",
                encoding = "UTF-8")
public class ExternalConfigDependencyDemo {
  @Value("${user.id}")
  private String id;

  @Value("${user.path}")
  private Resource resource;

  @PostConstruct
  public void init() {
    // out: userId:22
    System.out.println("userId:"+ id);
    // out: userPath:class path resource [META-INF/default.properties]
    System.out.println("userPath:"+ resource);
  }

  public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.register(ExternalConfigDependencyDemo.class);
    ctx.refresh();
    ctx.close();
  }
}
```