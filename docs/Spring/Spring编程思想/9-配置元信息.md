---
id: 配置元信息
title: 配置元信息
---

> 配置元信息基本有下面几类:
>
> 1. Bean 配置元信息: `BeanDefinition`
>     - 通过媒介(XML、Properties...) 解析 BeanDefinition
> 2. Bean 属性元信息: `PropertyValues`
> 3. 容器配置元信息
>     - 通过媒介(XML、Properties...),控制 IOC 容器的行为,比如**注解驱动、AOP 等**
> 4. 外部化配置元信息: `PropertySource`
>     - 通过资源抽象(比如 Properties、Yaml等),控制 PropertySource
> 5. Profile 元信息: `@Profile`
>     - 通过外部化配置,提供条件分支流程

## Bean 配置元信息(BeanDefinition)

> 关于 BeanDefinition 的详细可以参看 [元信息接口](Bean#元信息接口beandefinition)

- Bean 配置元信息(BeanDefinition)
  - `GenericBeanDefinition`: 通用型 BeanDefinition
  - `RootBeanDefinition`: 无 Parent 的 BeanDefinition 或者合并后的 BeanDefinition
  - `AnnotatedBeanDefinition`: 注解标注的 BeanDefinition

- **GenericBeanDefinition** 和 **RootBeanDefinition** 都继承自 `AbstractBeanDefinition`,两者最大的区别就是:前者可以设置 parent,而后者是顶层元信息,无法设置 parent。

- **AnnotatedBeanDefinition** 是面向注解的,本身它是一个接口,并且它是在 `BeanDefinition` 接口上进行拓展的,它暴露了 Bean Class 上的注解元信息(`AnnotationMetadata`)
  - 关于这个 *AnnotationMetadata* 一般采用 反射或者 `ASM 字节码` 的方式

```java
/**
 * 拓展了 BeanDefinition 接口,然后暴露了 Bean Class 上的注解元信息(AnnotationMetadata)
 *
 */
public interface AnnotatedBeanDefinition extends BeanDefinition {

    /**
     * 返回注解元信息
     */
    AnnotationMetadata getMetadata();

    @Nullable
    MethodMetadata getFactoryMethodMetadata();
}
```

## Bean 属性元信息(PropertyValue)

- Bean 属性元信息(PropertyValues)
  - 可修改的实现: `MutablePropertyValues`
  - 元素成员: `PropertyValue`
- PropertyValue 实现了 BeanMetadataAttributeAccessor, 所以间接的实现了:
  - Bean 属性存储: `AttributeAccessor`
  - Bean 元信息元素: `BeanMetadataElement`

:::caution 注意

BeanDefinition 同样的继承了 AttributeAccessor 和 BeanMetadataElement

```java title=BeanDefinition.java
public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {
  //....
}
```

:::

### AttributeAccessor

这个接口的操作很简单,就是对*attribute(属性)* 进行添加、删除、查询:

```java
public interface AttributeAccessor {
  // 设置属性
  void setAttribute(String name, @Nullable Object value);

  // 通过属性名获取属性值
  @Nullable
  Object getAttribute(String name);

  // 通过属性名删除属性,并返回删除的属性值
  @Nullable
  Object removeAttribute(String name);

  // 判断是否包含某个属性名
  boolean hasAttribute(String name);

  // 获取属性名称
  String[] attributeNames();
}
```

1. 虽然 BeanDefinition 继承自 AttributeAccessor,但是它对 BeanDefinition 的影响几乎为 0,不影响 Bean 的生成

2. 虽然它也是设置属性的,但是一般来说 Bean 的配置元信息都存储在 `PropertyValues` 中,并且通过 `getPropertyValues()` 方法可以返回一个 ***可修改的 PropertyValues***。

3. AttributeAccessor 可以用来 **存储一些中间状态,为 BeanDefinition 添加一些附加属性**

一个简单的示例,将 attribute 中的特定属性值设置到 BeanDefinition 的配置元信息中:

```java
/**
 * Bean 属性元信息
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class BeanConfigurationMetadataDemo {
  public static void main(String[] args) {
      // 创建 BeanDefinition
      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(User.class);
      builder.addPropertyValue("name", "athu");
      AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();
      //highlight-start
      // 附加属性(不会影响 Bean 的实例化、属性赋值、初始化)
      beanDefinition.setAttribute("id", 22L);
      //highlight-end
      // 注册 BeanDefinition
      DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
      beanFactory.registerBeanDefinition("user",beanDefinition);

      // 利用 BeanPostProcessor + attribute 设置属性值
      beanFactory.addBeanPostProcessor(new BeanPostProcessor() {
          @Override
          public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
              if (beanName.equals("user")) {
                  //highlight-start
                  // 获取 BeanDefinition(合并后的 BeanDefinition)
                  BeanDefinition bd = beanFactory.getBeanDefinition(beanName);
                  // 获取 设置的 attribute 属性(属性上下文)
                  Long id = (Long)bd.getAttribute("id");
                  ((User)bean).setId(id);
                  //highlight-end
              }
              return bean;
          }
      });

      User bean = beanFactory.getBean("user", User.class);
      // out: User{id=22, name='athu'}
      System.out.println(bean);
  }
}
```

### BeanMetadataElement

它只有一个方法 `getSource()`,用于表示**该 BeanDefinition 的来源是哪**?

```java
public interface BeanMetadataElement {
  @Nullable
  default Object getSource() {
    return null;
  }
}
```

比如上面的示例中,我将 BeanDefinition 的来源设置为当前测试类:

```java
/**
 * Bean 配置元信息
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class BeanConfigurationMetadataDemo {
  public static void main(String[] args) {
      // 创建 BeanDefinition
      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(User.class);
      builder.addPropertyValue("name", "athu");
      AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();
      // 附加属性(不会影响 Bean 的实例化、属性赋值、初始化)
      beanDefinition.setAttribute("id", 22L);
      //highlight-start
      // 设置 BeanDefinition 的来源
      beanDefinition.setSource(BeanConfigurationMetadataDemo.class)
      //highlight-end
      // ...
  }
}
```

## IOC 容器配置元信息

> 以 XML 资源的形式进行分析

### beans 元素

在 Spring XML 配置元信息文件中,我们可以通过对 `beans` 元素进行配置,来设置多个 bean 或者导入的 beans 的默认属性

| bean 元素属性 | 默认值  | 使用场景   |
| :---------: | :----: | :-------: |
| **profile**                 | null    | Spring Profiles 配置值                                       |
| **default-lazy-init**       | default | 当 outer beans “default-lazy-init” 属性存在时,继承该值,否则为 false |
| **default-merge**               | default | 当 outer beans “default-merge” 属性存在时,继承该值,否则为 false |
| **default-autowire**            | default | 当 outer beans “default-autowire” 属性存在时,继承该值,否则为 no |
| **default-autowire-candidates** | null    | 默认 Spring Beans 名称 pattern(通过通配符等方式模糊匹配一些 bean) |
| **default-init-method**         | null    | 默认 Spring Beans 自定义初始化方法                           |
| **default-destory-method**      | null    | 默认 Spring Beans 自定义销毁方法                             |

:::tip 关于 outer beans
比如在一个 XML 配置文件 A 中导入另一个 XML 配置元信息文件 B,那么这个 XML 文件 A 中的 beans 就是 outer beans
:::

### 应用上下文(context 元素)

在 Spring XML 配置元信息文件中,我们可以对通过 `context` 属性对应用上下文进行一些配置:

| bean 元素属性               | 使用场景                                                     |
| :---------------------------: | :------------------------------------------------------------: |
| **<context:annotation-config />** | 激活 Spring 注解驱动                                       |
| **<context:component-scan />**    | Spring @Component 以及自定义注解扫描 |
| **<context:load-time-weaver />**  | 激活 Spring LoadTimeWeaver |
| **<context:mbean-export />**      | 暴露 Spring Beans 作为 JMX Beans |
| **<context:mbean-server />**      | 将当前平台作为 MBeanServer |
| **<context:property-placeholder />** | 加载外部化配置资源作为 Spring 属性配置                           |
| **<context:property-override />**    | 利用外部化配置资源覆盖 Spring 属性值                             |

### 源码分析

#### BeanDefinitionParserDelegate

我们知道 Bean 的配置元信息会被 [BeanDefinitionParser 解析](Bean生命周期#元信息解析)。实际上,Spring 是通过一个委托 `BeanDefinitionParserDelegate` 来解析 XML 配置文件的

我们简单的看下这个类,可以看到里面定义了 bean 元素标签和属性名,并且有常见的方法:

1. [populateDefaults](配置元信息#populatedefaults)
2. `parseConstructorArgElements()`: 解析 constructor-arg 元素
3. [parseBeanDefinitionElement](配置元信息#parsebeandefinitionelement)
4. [parseCustomElement](配置元信息#parsecustomelement)

```java
public class BeanDefinitionParserDelegate {
  // beans 属性的 namespace
  public static final String BEANS_NAMESPACE_URI = "http://www.springframework.org/schema/beans";
  // 多值属性的分隔符
  public static final String MULTI_VALUE_ATTRIBUTE_DELIMITERS = ",; ";
  // ...
  // name 属性
  public static final String NAME_ATTRIBUTE = "name";
  // <bean> 元素标签名称
  public static final String BEAN_ELEMENT = "bean";
  // <meta> 元素标签名称
  public static final String META_ELEMENT = "meta";
  // id 属性
  public static final String ID_ATTRIBUTE = "id";
  // class 属性
  public static final String CLASS_ATTRIBUTE = "class";
  // ...
  // default-lazy-init 属性
  public static final String DEFAULT_LAZY_INIT_ATTRIBUTE = "default-lazy-init";
  // default-merge 属性
  public static final String DEFAULT_MERGE_ATTRIBUTE = "default-merge";
  // default-autowire  属性
  public static final String DEFAULT_AUTOWIRE_ATTRIBUTE = "default-autowire";
  // default-autowire-candidates 属性
  public static final String DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE = "default-autowire-candidates";
  // default-init-method 属性
  public static final String DEFAULT_INIT_METHOD_ATTRIBUTE = "default-init-method";
  // default-destroy-method 属性
  public static final String DEFAULT_DESTROY_METHOD_ATTRIBUTE = "default-destroy-method";

  //...
}
```

##### populateDefaults

> 该方法主要用于 填充 beans 的几个默认属性值

```java title=BeanDefinitionParserDelegate#populateDefaults
// 对 beans 填充默认值
protected void populateDefaults(DocumentDefaultsDefinition defaults, 
                      @Nullable DocumentDefaultsDefinition parentDefaults, 
                      Element root) {
  String lazyInit = root.getAttribute(DEFAULT_LAZY_INIT_ATTRIBUTE);
  if (isDefaultValue(lazyInit)) {
    lazyInit = (parentDefaults != null ? parentDefaults.getLazyInit() : FALSE_VALUE);
  }
  defaults.setLazyInit(lazyInit);
  // ...
  if (root.hasAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE)) {
    defaults.setDestroyMethod(root.getAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE));
  }
  else if (parentDefaults != null) {
    defaults.setDestroyMethod(parentDefaults.getDestroyMethod());
  }
  defaults.setSource(this.readerContext.extractSource(root));
}
```

##### parseBeanDefinitionElement

> 该方法主要是将 bean 元素解析成 BeanDefinition

```java title=BeanDefinitionParserDelegate#parseBeanDefinitionElement
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
		String id = ele.getAttribute(ID_ATTRIBUTE);
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
    // 解析 Bean 的别名
		List<String> aliases = new ArrayList<>();
		if (StringUtils.hasLength(nameAttr)) {
			String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, ",; ");
			aliases.addAll(Arrays.asList(nameArr));
		}
		String beanName = id;
		if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {
			beanName = aliases.remove(0);
		}
    // 将 Bean 标签解析为 BeanDefinition
		AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
    // ...
		return null;
	}

// 将bean元素解析成 BeanDefinition
public AbstractBeanDefinition parseBeanDefinitionElement(
                    Element ele, String beanName,
                    @Nullable BeanDefinition containingBean) {
  // ...
  try {
    AbstractBeanDefinition bd = createBeanDefinition(className, parent);
    // 解析 bean 元素中的属性
    parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
    // 解析 bean 元素的子元素标签
    parseMetaElements(ele, bd);
    parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
    parseReplacedMethodSubElements(ele, bd.getMethodOverrides());
    parseConstructorArgElements(ele, bd);
    parsePropertyElements(ele, bd);
    parseQualifierElements(ele, bd);
    bd.setResource(this.readerContext.getResource());
    bd.setSource(extractSource(ele));
    return bd;
  }
  // ...
}
```

##### parseCustomElement

> 将个性化元素标签解析到 BeanDefinition 中

主要流程:

1. 根据元素(ele) 获取命名空间的"地址",然后获取对应的 NamespaceHandler
2. 构造 ParserContext
3. 利用 NamespaceHandler#parse 解析元素,获取 BeanDefinition。执行 parse() 方法的时候,会通过元素找到对应已经注册的 BeanDefinitionParser

```java title=BeanDefinitionParserDelegate#parseCustomElement
// 将个性化元素标签解析到 BeanDefinition 中
public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) {
  String namespaceUri = getNamespaceURI(ele);
  if (namespaceUri == null) {
    return null;
  }
  // highlight-start
  // 执行 NamespaceHandler#resolve
  NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
  // highlight-end
  if (handler == null) {
    error("Unable to locate Spring NamespaceHandler for XML schema namespace [" + namespaceUri + "]", ele);
    return null;
  }
  return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));
}
```

#### XML Schema(XSD)

通过 `BeanDefinitionParser` 可以将 XML 解析得到配置元信息(Bean 配置元信息、容器配置元信息....),为此 Spring 定义了一套 XML Schema。这个 Schema 文件定义了 XML 种各个元素属性信息。

下面给出一段 XML 配置元信息文件:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/beans/spring-context.dtd"
        default-autowire="default"
       default-lazy-init="false">
    <!--激活注解驱动-->
    <context:annotation-config/>

    <!--定义一个 Bean 的配置元信息-->
    <bean id="user" class="ioc.overview.Domain.User"/>
</beans>
```

可以看到 XML 会引入 `dtd` 以及 `schema` 文件,以 *beans* 元素为例,简单的看下 schema 文件,以简单的 bean 元素为例

```xml
<xsd:element name="bean">
  <!-- 这里不是注解的意思,而是注释 -->
  <xsd:annotation>
    <xsd:documentation source="java:org.springframework.beans.factory.config.BeanDefinition"><![CDATA[
    Defines a single (usually named) bean.
    A bean definition may contain nested tags for constructor arguments,
    property values, lookup methods, and replaced methods. Mixing constructor
    injection and setter injection on the same bean is explicitly supported.
    ]]></xsd:documentation>
  </xsd:annotation>
  <xsd:complexType>
    <xsd:complexContent>
      <xsd:extension base="identifiedType">
        <!-- 这里表示 bean 元素中的子元素是一个 group -->
        <xsd:group ref="beanElements"/>
        <!-- 这里表示 bean 元素的属性也是一个 group -->
        <xsd:attributeGroup ref="beanAttributes"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
</xsd:element>
<!-- 这里定义了 bean 元素中的子元素信息 -->
<xsd:group name="beanElements">
  <xsd:sequence>
    <xsd:element ref="description" minOccurs="0"/>
    <xsd:choice minOccurs="0" maxOccurs="unbounded">
      <xsd:element ref="meta"/>
      <xsd:element ref="constructor-arg"/>
      <xsd:element ref="property"/>
      <xsd:element ref="qualifier"/>
      <xsd:element ref="lookup-method"/>
      <xsd:element ref="replaced-method"/>
      <xsd:any namespace="##other" processContents="strict" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:choice>
  </xsd:sequence>
</xsd:group>
```

## 装载 Bean 配置元信息

我们有多种方式来装载 Bean 的配置元信息:

1. XML
2. Properties
3. Java 注解

### 基于 XML

> 基于 XML 资源来装载 Spring 配置元信息,底层实现为 `XMLBeanDefinitionReader` (起始于 Spring 1.0)

Spring Bean 配置元信息:

| XML 元素 | 使用场景 |
| :-----: | :----- : |
| `<beans />`| 单个 XML 资源下的多个 Spring Beans 的配置 |
| `<bean />` | 单个 Spring Bean 定义(BeanDefinition) 配置 |
| `<alias />` | 为 Spring Bean 定义(BeanDefinition) 映射别名 |
| `<import />` | 加载外部 Spring XML 配置资源 |

### 基于 Properties(了解)

> 基于 Properties 资源来装载 Spring 配置元信息,底层实现为 `PropertiesBeanDefinitionReader` (起始于 Spring 1.0)

Spring Bean 配置元信息:

| Properties 属性名 | 使用场景                        |
| ----------------- | ------------------------------- |
| `(class)`         | Bean 类全限定名                 |
| `(abstract)`      | 是否为抽象的 BeanDefinition     |
| `(parent)`        | 指定 parent BeanDefinition 名称 |
| `(lazy-init)`     | 是否延迟初始化                  |

详细示例可以参看 [Properties 配置](Bean生命周期#properties-配置)

### 基于 Java 注解

> 基于 Java 注解 来装配 Spring 配置元信息,底层实现为 `AnnotatedBeanDefinitionReader` (起始于 Spring 3.0)

#### 模式注解

| Spring 注解 | 场景说明 | 起始版本 |
| :---------:| :------:| :-----: |
| `@Repository` | 数据仓储模式注解 | 2.0 |
| `@Component` |  通用主键模式注解 | 2.5 |
| `@Service` | 服务模式注解 | 2.5 |
| `@Controller` | Web 控制器模式注解 | 2.5 |
| `@Configuration` | 配置类模式注解 |  3.0 |

#### 依赖注入注解

| 注解 | 场景说明 | 起始版本 |
| :---------:| :------:| :-----: |
| `@Autowired` | Bean 依赖注入,支持多种依赖查找方式 | 2.5 |
| `@Qualifier` |  细粒度的 | 2.5 |
| `@Resource` | 服务模式注解 | 2.5 |
| `@Inject` | Web 控制器模式注解 | 2.5 |

#### Bean 定义注解

| 注解 | 场景说明 | 起始版本 |
| :---------:| :------:| :-----: |
| `@Bean` | 替换 XML 元素 **<bean/ >** | 3.0 |
| `@DependsOn` | 替换 XML 元素 **<bean depends-on="..."/ >** | 3.0 |
| `@Lazy` | 替换 XML 元素 **<bean lazy-init="true|false"/ >** | 3.0 |
| `@Primary` | 替换 XML 元素 **<bean primary="true|false"/ >** | 3.0 |

#### 条件装配注解

| Spring 注解 | 场景说明 | 起始版本 |
| :---------:| :------:| :-----: |
| `@Profile` |  配置化条件装配 | 3.1 |
| `@Conditional` | 编程条件装配 | 4.0 |

首先,@Conditional 注解需要传入多个`Condition`,然后匹配原则是所有的条件都要满足:

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Conditional {
  Class<? extends Condition>[] value();
}
```

需要注意的是: **@Profile 注解 是基于@Conditional 的**,我们看下源码,需要注意一个类:

- `AnnotatedTypeMetadata` : 提供一种访问注解的特殊方式,这种方式不一定需要类加载

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
// highlight-start
// ProfileCondition 就是一个判断条件
@Conditional(ProfileCondition.class)
// highlight-end
public @interface Profile {
  String[] value();
}


class ProfileCondition implements Condition {
  @Override
  public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    // 获取 @Profile 注解上的所有属性以及属性值
    MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
    if (attrs != null) {
      //取出 @Profile 注解的 value 属性值
      for (Object value : attrs.get("value")) {
        // 如果 environment 接受设置的 profile value,则返回 true
        if (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) {
          return true;
        }
      }
      return false;
    }
    return true;
  }
}
```

#### 生命周期回调注解

| 注解 | 场景说明 | 起始版本 |
| :---------:| :------:| :-----: |
| `@PostConstruct` |  Bean 初始化方法 | 2.5 |
| `@PreDestroy` |  Bean 销毁方法 | 2.5 |

### 底层实现(源码分析)

| 实现场景        | 实现类                         | 起始版本 |
| --------------- | ------------------------------ | -------- |
| XML 资源        | XmlBeanDefinitionReader        | 1.0      |
| Properties 资源 | PropertiesBeanDefinitionReader | 1.0      |
| Java 注解       | AnnotatedBeanDefinitionReader  | 3.0      |

这三者的联系与区别是: XMl 和 Properties 的方式都是面向资源的,Java 注解是面向类的

#### XML 资源

- 核心 API: `XmlBeanDefinitionReader`
  - 资源: `Resource`
  - 底层: `BeanDefinitionDocumentReader`
    - XML 解析: DOM
    - BeanDefinition 解析: `BeanDefinitionParserDelegate`
    - BeanDefinition 注册: `BeanDefinitionRegistry`

> 我们看下源码中,XMLBeanDefinitionReader 是如何加载 Bean 配置元信息的?

- 首先看到的是,方法入口点为: `XmlBeanDefinitionReader#registerBeanDefinitions()`,这一步主要有下面的处理过程:
  - **创建 DefaultBeanDefinitionDocumentReader**
  - **注册多个 BeanDefinition**
    - 这一步在执行 **createReaderContext()** 的时候会创建命名空间处理器: `NamespaceHandlerResolver`

```java title=XmlBeanDefinitionReader#registerBeanDefinitions
public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
  // 创建 DefaultBeanDefinitionDocumentReader
  BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
  int countBefore = getRegistry().getBeanDefinitionCount();
  // highlight-start
  // 注册多个 BeanDefinition
  documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
  // highlight-end
  return getRegistry().getBeanDefinitionCount() - countBefore;
}
```

- 在上一步中看到的创建 NamespaceHandlerResolver,实际是创建一个 `DefaultNamespaceHandlerResolver` 对象。需要注意的是,创建时的常量 **DEFAULT_HANDLER_MAPPINGS_LOCATION = META-INF/spring.handlers**

```java
// XmlBeanDefinitionReader#createDefaultNamespaceHandlerResolver
protected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() {
  ClassLoader cl = (getResourceLoader() != null ? getResourceLoader().getClassLoader() : getBeanClassLoader());
  // highlight-start
  return new DefaultNamespaceHandlerResolver(cl);
  // highlight-end
}

// DefaultNamespaceHandlerResolver#DefaultNamespaceHandlerResolver
public DefaultNamespaceHandlerResolver(@Nullable ClassLoader classLoader) {
  this(classLoader, DEFAULT_HANDLER_MAPPINGS_LOCATION);
}
```

- 接下来就是开始注册了,这一步会调用一开始创建的 `DefaultBeanDefinitionDocumentReader#parseBeanDefinitions`
  - **解析默认的元素标签**: 比如 bean、import、alias
    - 这里会调用 [BeanDefinitionParserDelegate#parseBeanDefinitionElement](配置元信息#parsebeandefinitionelement) 方法
  - **解析自定义的元素标签,不同的元素标签需要对应的 handler**
    - 这里会调用 [BeanDefinitionParserDelegate#parseCustomElement](配置元信息#parsecustomelement) 方法

```java title=DefaultBeanDefinitionDocumentReader#parseBeanDefinitions
protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
  if (delegate.isDefaultNamespace(root)) {
    NodeList nl = root.getChildNodes();
    for (int i = 0; i < nl.getLength(); i++) {
      Node node = nl.item(i);
      if (node instanceof Element) {
        Element ele = (Element) node;
        // 如果namespace 是 beans
        if (delegate.isDefaultNamespace(ele)) {
          // highlight-start
          // 解析默认的元素
          parseDefaultElement(ele, delegate);
          // highlight-end
        }
        else {
          // highlight-start
          // 解析自定义元素
          delegate.parseCustomElement(ele);
          // highlight-end
        }
      }
    }
  }
  else {
    delegate.parseCustomElement(root);
  }
}
```

- 我们知道解析个性化元素标签的时候会通过 `NamespaceHandler#parse()` 获取 parser 解析器,然后通过 parser 解析不同的元素标签。并且这个 NamespaceHandler 是通过读取 jar 文件中的 `META-INF/spring.handlers` 获取的(利用反射),以 spring-context 为例:

```ini
http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler
http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler
http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler
http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler
http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler
```

可以看到 Spring 利用 *ContextNamespaceHandler* 来处理 context 元素,并且 ContextNamespaceHandler 注册了很多 parser 解析器,用于解析 context 命名空间下的不同元素标签

```java
public class ContextNamespaceHandler extends NamespaceHandlerSupport {
  @Override
  public void init() {
    registerBeanDefinitionParser("property-placeholder", new PropertyPlaceholderBeanDefinitionParser());
    registerBeanDefinitionParser("property-override", new PropertyOverrideBeanDefinitionParser());
    // highlight-start
    // 处理注解驱动
    registerBeanDefinitionParser("annotation-config", new AnnotationConfigBeanDefinitionParser());
    // highlight-end
    registerBeanDefinitionParser("component-scan", new ComponentScanBeanDefinitionParser());
    registerBeanDefinitionParser("load-time-weaver", new LoadTimeWeaverBeanDefinitionParser());
    registerBeanDefinitionParser("spring-configured", new SpringConfiguredBeanDefinitionParser());
    registerBeanDefinitionParser("mbean-export", new MBeanExportBeanDefinitionParser());
    registerBeanDefinitionParser("mbean-server", new MBeanServerBeanDefinitionParser());
  }
}
```

#### Properties 资源(了解)

> 这种方式并不受欢迎,有一定的限制性

- 核心 API: `PropertiesBeanDefinitionReader`
  - 资源
    - 字节流资源: `Resource`
    - 字符流资源: `EncodedResource`
  - 底层
    - 存储: `java.util.Properties`
    - BeanDefinition 解析: API 内部实现
    - BeanDefinition 注册: `BeanDefinitionRegistry`

#### Java 注解

- 核心 API: `AnnotatedBeanDefinitionReader`
  - 资源
    - 类对象: `java.lang.Class`
  - 底层
    - 条件评估: `ConditionEvaluator`
    - Bean 范围解析: `ScopedMetadataResolver`
    - BeanDefinition 解析: `AnnotationConfigUtils#processCommonDefinitionAnnotations`
    - BeanDefinition 注册: `BeanDefinitionRegistry`

注解的 BeanDefinition 的处理,有一个特殊点需要注意:

- 代理模式 proxyMode,它有 3 个可选值:
  1. `DEFAULT`
  2. `NO`
  3. `INTERFACES` : 接口模式,基于 JDK 动态代理
  4. `TARGET_CLASS`: 类模式,基于 CGLib 提升

```java
private <T> void doRegisterBean(Class<T> beanClass, 
          @Nullable String name,
          @Nullable Class<? extends Annotation>[] qualifiers,
          @Nullable Supplier<T> supplier,
          @Nullable BeanDefinitionCustomizer[] customizers) {
  // 对 Class 对象进行评估
  AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);
  if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
    return;
  }
  // 设置实例化 supplier
  abd.setInstanceSupplier(supplier);
  // 根据 @Scope 的 proxyMode 设置代理模式
  ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
  //设置作用域
  abd.setScope(scopeMetadata.getScopeName());
  // 生成 Bean 的名称
  String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));
  // 处理一些注解(@Lazy、@DependsOn)
  AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
  if (qualifiers != null) {
    for (Class<? extends Annotation> qualifier : qualifiers) {
      if (Primary.class == qualifier) {
        abd.setPrimary(true);
      }
      else if (Lazy.class == qualifier) {
        abd.setLazyInit(true);
      }
      else {
        abd.addQualifier(new AutowireCandidateQualifier(qualifier));
      }
    }
  }
  if (customizers != null) {
    for (BeanDefinitionCustomizer customizer : customizers) {
      customizer.customize(abd);
    }
  }

  BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
  // 应用代理模式
  definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
  // 注册
  BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
```

## 装载容器配置元信息

### 基于 XML

我们知道了 XML 可以配置容器元信息,除了[上面](配置元信息#ioc-容器配置元信息) 提到了 beans 以及 context,还有很多与 Spring 容器相关的 XML 配置

| 命名空间 | 所属模块       | Schema 资源URL                                               |
| -------- | -------------- | ------------------------------------------------------------ |
| beans    | Spring-beans   | http://www.springframework.org/schema/beans/spring-beans.xsd |
| context  | Spring-context | http://www.springframework.org/schema/context/spring-context.xsd= |
| aop      | Spring-aop     | https://www.springframework.org/schema/aop/spring-aop.xsd    |
| tx       | Spring-tx      | http://www.springframework.org/schema/tx/spring-tx.xsd       |
| util     | Spring-beans   | http://www.springframework.org/schema/util/spring-util.xsd   |
| tool     | Spring-beans   | http://www.springframework.org/schema/tool/spring-tool.xsd   |

:::tip 提示
可以在 Spring 代码的 **META-INF** 目录下看到很多资源文件,其中就包含 spring.schemas、spring.handlers ...
:::

### 基于注解

#### 装配注解

> 装配注解可以装载容器的配置信息

| Spring 注解 |场景说明 | 起始版本 |
| :--------: | :---: | :-----: |
| `@ImportResource` | 替换 XML 元素 **<import/ >** | 3.0 |
| `@Import` | 导入 Configuration 类,[详细](注解处理#自定义-enable-模块驱动) | 3.0 |
| `@ComponentScan` | 扫描指定 package 下标注 [Spring 模式注解的类](配置元信息#模式注解) | 3.1 |

- 对于 @ImportResource 来说使用 BeanDefinitionReader  实现类解析导入的容器配置信息, 默认支持传入 XML、Groovy,但是也可以传入 Properties 或者其他的容器配置文件,但是需要配置相应的 *BeanDefinitionReader*

```java
/**
 * 基于注解装配配置信息
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */


// 使用  @ImportResource 导入一个容器配置信息/组件,可以导入多个
/*@ImportResource(
        locations = {"classpath:/META-INF/annotated-load-configuration.xml"}
)*/

// 支持传入 properties 文件,但是需要设置 BeanDefinition 解析器,比如这里的 PropertiesBeanDefinitionReader
@ImportResource(
        locations = {"classpath:META-INF/property-load-configuration.properties"},
        reader = PropertiesBeanDefinitionReader.class
)
public class AnnotatedLoadConfigurationDemo {
    @Bean
    public User configuratedUser() {
        return User.builder().id(33L).name("configurated-user").build();
    }

    public static void main(String[] args) {
        // 创建一个 注解配置的应用上下文
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
        context.register(AnnotatedLoadConfigurationDemo.class);
        context.refresh();
        // 依赖查询
        Map<String, User> beans = context.getBeansOfType(User.class);
        for(Map.Entry<String,User> entry : beans.entrySet()) {
            System.out.println("beanName:" + entry.getKey());
        }

        context.close();
    }
}
```

#### 配置属性注解

| Spring 注解 |场景说明 | 起始版本 |
| :--------: | :---: | :-----: |
| `@PropertySource` | 配置属性抽象 PropertySource 注解 | 3.1 |
| `@PropertySources` | @PropertySource 注解集合 | 4.0 |

这两个注解可以读取资源文件到容器中,Spring 提供 [Environment 对象](Environment抽象)使用。

## 拓展Spring XML 元素

### 步骤与示例

拓展 Spring 的 XML 一般有下面的步骤:

1. 编写 XML Schema 文件: 定义 XML 结构
    - 如果有类型的话,需要定义类型
    - 自定义元素
2. 自定义 NamespaceHandler 实现: 绑定命名空间
3. 自定义 BeanDefinitionParser 实现: XML 元素与 BeanDefinition 解析
4. 注册 XML 拓展: 命名空间与 XML Schema 映射

:::caution 示例前提
定义一个 Java Bean:

```java
@Data
public class User {
    private Integer id;
    private String name;
    private Address address;
}

public enum Address {
    CHANGZHOU,
    NANJIN,
    SUZHOU
}
```

:::

---

首先,定义一个 XML Scheme 文件,用于描述 user,需要注意: **这里为了避免 Maven 打包问题,将 xsd 文件放在了 resource 根目录**

```xml title=classpath:user.xsd
<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<xsd:schema xmlns="http://time.geekbang.org/schema/users"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            targetNamespace="http://time.geekbang.org/schema/users">

    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>

    <!--定义一个复杂类型 User-->
    <xsd:complexType name="User">
        <xsd:attribute name="id" type="xsd:integer" use="required"/>
        <xsd:attribute name="name" type="xsd:string" use="required"/>
        <xsd:attribute name="address" type="Address" use="required"/>
    </xsd:complexType>

    <!--
        定义 Address 类型(简单类型 -  枚举)
        这里的 base="xsd:string" 是基类型,即可选值的基础类型
    -->
    <xsd:simpleType name="Address">
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="CHANGZHOU"/>
            <xsd:enumeration value="NANJIN"/>
            <xsd:enumeration value="SUZHOU"/>
        </xsd:restriction>
    </xsd:simpleType>

    <!--定义 user 元素-->
    <xsd:element name="user" type="User"/>
</xsd:schema>
```

然后, 我们在 `META-INF` 下定义 `spring.schemas` 文件来注册 XML 资源, 将网络资源的 schema 映射到本地路径

```properties title=classpath:/META-INF/spring.schemas
http\://time.geekbang.org/schema/users.xsd = user.xsd
```

然后创建一个 user 元素的解析类,实现 BeanDefinitionParser。一般来说可以简单的继承 `AbstractSimpleBeanDefinitionParser`,并且重写下面两个方法:

- getBeanClass : bean 元素的类型
- doParse : 解析逻辑

```java
/**
 * user 元素的 BeanDefinitionParser
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class UserBeanDefinitionParser extends AbstractSimpleBeanDefinitionParser {
    @Override
    protected Class<?> getBeanClass(Element element) {
        return User.class;
    }

    @Override
    protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
        // 填充 BeanDefinitionBuilder 属性
        String id = element.getAttribute("id");
        String name = element.getAttribute("name");
        String address = element.getAttribute("address");
        builder.addPropertyValue("id", id);
        builder.addPropertyValue("name", name);
        builder.addPropertyValue("address", address);
    }
}

```

然后创建一个 NamespaceHandler 的实现来注册 Parser 解析器,一般只需要继承抽象类 NamespaceHandlerSupport, 实现 `init()` 方法即可

```java
/**
 * User 命名空间的处理器
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class UserNamespaceHandler extends NamespaceHandlerSupport {
    @Override
    public void init() {
        // 注册一个 BeanDefinitionParser, 用于解析的元素名称为 user
        registerBeanDefinitionParser("user", new UserBeanDefinitionParser());
    }
}
```

然后在 `META-INF` 下定义 `spring.handlers` 来注册 NamespaceHandler

```properties title=classpath:/META-INF/spring.handlers
http\://time.geekbang.org/schema/users =UserNamespaceHandler
```

最后,我们进行测试:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:users="http://time.geekbang.org/schema/users"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://time.geekbang.org/schema/users
       http://time.geekbang.org/schema/users.xsd">

    <users:user id="23" name="Antify" address="SUZHOU"/>
</beans>
```

```java 测试代码
/**
 * 测试拓展 Spring XML
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class ExtUserDemo {
    public static void main(String[] args) {
        DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);
        reader.loadBeanDefinitions("/META-INF/ext-user.xml");
        User bean = beanFactory.getBean(User.class);
        // out: User(id=23, name=Antify, address=SUZHOU)
        System.out.println(bean);
    }
}
```

### 基本原理

它的基本原理和 [XML 装载 Bean 配置元信息](配置元信息#xml-资源)基本一致

## 装载外部化配置文件

- 相关的注解驱动
  - @PropertySource
  - @PropertySources
- API
  - PropertySource
  - PropertySources

### 基于 Properties 文件

首先定义一个 Properties 的文件作为外部化配置文件:

```properties title=META-INF/property-load-configuration.properties
user.(class) =ioc.overview.Domain.User
user.id=22
user.name=user-in-properties
```

#### 基础示例

在之前的[配置属性注解](配置元信息#配置属性注解)中有提及通过 `@PropertySource` 注解来导入外部化配置文件,下面是基本的示例

```java
/**
 * 测试properties外部化配置 {@link org.springframework.context.annotation.PropertySource}
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */

// 导入了 properties 外部化配置文件
@PropertySource("classpath:META-INF/property-load-configuration.properties")
public class PropertySourceDemo {
    // 使用 @Bean 注解向容器注册一个 Bean 配置元信息
    @Bean
    public User user(@Value("${user.id}") Integer id, @Value("${user.name}")String name) {
        // 按照外部化配置来说,user = {id=22,name=user-in-properties}
        User user = new User();
        user.setId(id);
        user.setName(name);
        return user;
    }

    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(PropertySourceDemo.class);
        ctx.refresh();
        User user = ctx.getBean(User.class);
        // out: User(id=22, name=yoey, address=null)
        System.out.println(user);
        ctx.close();
    }
}
```

可以看到, *user.id* 正常的使用了 Properties 文件的数据,而 *user.name* 确不是配置文件中定义的数据。这里需要注意:**user.name 的值是Java Properties**

我们这里在上述代码的基础上,演示下获取所有的 PropertySource (PropertySource 属于 Environment)

```java
// 导入了 properties 外部化配置文件
@PropertySource("classpath:META-INF/property-load-configuration.properties")
public class PropertySourceDemo {
    // 使用 @Bean 注解向容器注册一个 Bean 配置元信息
    @Bean
    public User user(@Value("${user.id}") Integer id, @Value("${user.name}")String name) {
        // 按照外部化配置来说,user = {id=22,name=user-in-properties}
        User user = new User();
        user.setId(id);
        user.setName(name);
        return user;
    }

    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(PropertySourceDemo.class);
        ctx.refresh();
        User user = ctx.getBean(User.class);
        // out: User(id=22, name=yoey, address=null)
        System.out.println(user);
        // highlight-start
        MutablePropertySources propertySources = ctx.getEnvironment().getPropertySources();
        // [
        //      PropertiesPropertySource {name='systemProperties'},
        //      SystemEnvironmentPropertySource {name='systemEnvironment'},
        //      ResourcePropertySource {name='class path resource [META-INF/property-load-configuration.properties]'}
        //  ]
        System.out.println(propertySources);
        // out: yoey
        System.out.println(propertySources.get("systemProperties").getProperty("user.name"));
        // highlight-end
        ctx.close();
    }
}

```

可以看到,PropertySource 有三个,除了手动导入的,还有两个:

1. systemProperties
2. systemEnvironment

在 systemProperties 中已经存在了 *user.name* 属性,所以不会去手动导入的外部化配置中查询,这说明存在"优先级"

:::tip 提示
利用 @Value 获取外部化配置文件的数据
:::

#### 基本原理

应用上下文在 refresh 初始化的时候,会初始化 PropertySource:

```java
// AbstractApplicationContext#prepareRefresh
protected void prepareRefresh() {
  // ...
  // 获取环境并且验证必须的属性
  getEnvironment().validateRequiredProperties();

  // ...

}

// AbstractApplicationContext#getEnvironment
public ConfigurableEnvironment getEnvironment() {
  if (this.environment == null) {
    // 在 createEnvironment 的时候会初始化默认的配置信息
    this.environment = createEnvironment();
  }
  return this.environment;
}
```

#### 进阶示例

> 对于上述的基础示例来说,如果要让外部化配置资源的"优先级"高于默认的 systemProperties,该怎么办呢?

由于在应用上下文 refresh 的时候会添加默认的两个环境变量数据,所以只要在 refresh 之前添加自定义的外部化配置数据即可

```java
// 导入了 properties 外部化配置文件
@PropertySource("classpath:META-INF/property-load-configuration.properties")
public class PropertySourceDemo2 {
    // 使用 @Bean 注解向容器注册一个 Bean 配置元信息
    @Bean
    public User user(@Value("${user.id}") Integer id, @Value("${user.name}")String name) {
        // 按照外部化配置来说,user = {id=22,name=user-in-properties}
        User user = new User();
        user.setId(id);
        user.setName(name);
        return user;
    }

    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(PropertySourceDemo2.class);
        // highlight-start
        // 在 refresh 之前添加外部化配置数据
        // 创建一个外部化配置 MapPropertySource
        Map<String,Object> config = new HashMap<>();
        config.put("user.name", "cus-user-name");
        MapPropertySource pps = new MapPropertySource("cus-prop",  config);
        MutablePropertySources mutablePropertySources = ctx.getEnvironment().getPropertySources();
        // 将创建的外部化配置添加到 PropertySources 中
        mutablePropertySources.addFirst(pps);
        // highlight-end
        ctx.refresh();
        User user = ctx.getBean(User.class);
        // out:User(id=22, name=cus-user-name, address=null)
         System.out.println(user);

        // [
        //      MapPropertySource {name='cus-prop'},
        //      PropertiesPropertySource {name='systemProperties'},
        //      SystemEnvironmentPropertySource {name='systemEnvironment'},
        //      ResourcePropertySource {name='class path resource [META-INF/property-load-configuration.properties]'}
        // ]
        System.out.println(mutablePropertySources);
        ctx.close();
    }
}
```

### 基于 YAML 文件

- 基本类: `YamlProcessor`
  - YamlMapFactoryBean
  - YamlPropertiesFactoryBean

#### 基本示例

> 首先需要 SnakeYaml 的支持!

在导入 Maven 的依赖之后,首先定义一个 Yaml 文件:

```yml
user:
  id: 44
  name: pacos
```

其次,需要注册 YamlProcessor 的配置元信息,这里使用  XML 的方式注册。

```xml
<!--注册 YamlProcessor 的实现类-->
<bean id="ymlBean" class="org.springframework.beans.factory.config.YamlMapFactoryBean">
    <!--指定读取的 yaml 文件的路径-->
    <property name="resources" value="classpath:/META-INF/yml-load-configuration.yml"/>
</bean>
```

然后,进行测试(Yaml 信息会读取到 Map 中)

```java
/**
 * 使用 Yaml 存储外部化配置
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class YamlSourceDemo {
    public static void main(String[] args) {
        DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
        reader.loadBeanDefinitions("META-INF/ext-yml.xml");
        // 进行依赖查找
        Map<String,Object> ymlBean = factory.getBean("ymlBean", Map.class);
        // out: {user={id=44, name=pacos}}
        System.out.println(ymlBean);
    }
}
```

#### 与@PropertySource 结合

从[上面](配置元信息#基于-properties-文件)中可以看到,可以通过 @PropertySource 加载外部化配置文件,然后通过 Environment  来使用环境变量值。但是 Spring 默认没有支持 Yaml,我们有下面的实现思路:**利用 YamlProcessor 的实现类读取配置信息,然后作为"PropertySource" 添加到 Environment 中**

首先需要创建一个处理 Yaml 外部化资源的 PropertySource: **创建一个 PropertySourceFactory 的实现类,并且实现 *createPropertySource* 方法**

```java
/**
 * 自定义的 PropertySource 处理
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */
public class YamlPropertySourceFactory implements PropertySourceFactory {
    @Override
    public PropertySource<?> createPropertySource(String name, EncodedResource resource) throws IOException {
        // 读取Yaml 配置信息
        YamlPropertiesFactoryBean factoryBean = new YamlPropertiesFactoryBean();
        factoryBean.setResources(resource.getResource());

        // 将 读取到的 yaml 配置信息转为 PropertiesPropertySource 返回
        PropertiesPropertySource pps = new PropertiesPropertySource(name, factoryBean.getObject());
        return pps;
    }
}
```

然后,在 @PropertySource 中加载外部化的 Yaml 配置文件

```java
/*
 * 使用 Yaml 存储外部化配置
 *
 * @author <a href="mailto:zhuyuliangm@gmail.com">yuliang zhu</a>
 */

// 加载外部化Yaml 配置文件,并且自定义 PropertySourceFactory
@PropertySource(
        name = "yamlProperty",
        value="classpath:/META-INF/yml-load-configuration.yml",
        factory = YamlPropertySourceFactory.class)
public class YamlSourceDemo2 {

    @Bean
    public User user(@Value("${user.id}") Integer id, @Value("${user.name}")String name) {
        User user = new User();
        user.setId(id);
        user.setName(name);
        return user;
    }
    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
        ctx.register(YamlSourceDemo2.class);
        ctx.refresh();
        User user = ctx.getBean(User.class);
        // out: User(id=44, name=yoey, address=null)
        // 这里 user.name 使用的是 System Properties
        System.out.println(user);
        ctx.close();
    }
}
```

:::tip 说明
@PropertySource 支持通过`factory` 属性返回一个 `PropertySourceFactory` 接口的实现类,该接口如下:

```java
public interface PropertySourceFactory {
  // highlight-start
  // 该方法返回一个 自定义的 PropertySource 接口实现类
  PropertySource<?> createPropertySource(@Nullable String name,
                                          EncodedResource resource) throws IOException;
  // highlight-end
}
```

:::
